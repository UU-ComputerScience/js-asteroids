\documentclass[10pt,twoside,a4paper,openright]{report}

\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[parfill]{parskip}
\usepackage{txfonts}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{multicol}
\usepackage{fancyvrb}
% ty rules
\usepackage{bussproofs}
\usepackage{semantic}
% things for the semantic package
\reservestyle{\command}{\textbf}
\command{let,in,:,case,of,if,then,else,letrec,nil,cons,false,true,[]}
\mathlig{-->}{\longrightarrow}
\newcommand{\tyrel}{\sqsubseteq}

\newcommand{\bigO}[1]{\mathcal{O}{\left(#1\right)}}

\newtheorem{definition}{Definition}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
% This file is in the public domain.
% Sean Leather, 2010 March 10

%% %include spacing.fmt

%-------------------------------------------------------------------------------
% Colors
%-------------------------------------------------------------------------------


% Char literal
\colorlet{Char}{green!45!black}

% String literal
\colorlet{String}{green!45!black}

% Numeral literal
\colorlet{Numeral}{green!45!black}

% Keyword
\colorlet{Keyword}{blue!45!black}

% Module identifier
\colorlet{ModId}{Char}

% Variable identifier and symbol
\colorlet{VarId}{black}
\colorlet{VarSym}{black}

% Data constructor identifier and symbol
\colorlet{ConId}{VarId}
\colorlet{ConSym}{ConId}

% Type variable identifier
\colorlet{TVarId}{blue!45!black}

% Type constructor identifier
\colorlet{TConId}{TVarId}
\colorlet{TConSym}{TConId}

% Type class identifier
\colorlet{TClassId}{red!80!black}

% Comment
\colorlet{Comment}{gray}


%-------------------------------------------------------------------------------
% Basic commands for fonts and other formatting
%-------------------------------------------------------------------------------


% Char literal
\newcommand\Char[1]{\textcolor{Char}{\texttt{#1}}}

% Numeral literal
\newcommand\Numeral[1]{\textcolor{Numeral}{#1}}

% Keyword
\newcommand\Keyword[1]{\textcolor{Keyword}{#1}}

% Module identifier
\newcommand\ModId[1]{\mathord{\textcolor{ModId}{\mathit{#1}}}}

% Variable identifier and symbol
\newcommand\VarId[1]{\mathord{\textcolor{VarId}{\mathit{#1}}}}
\let\Varid\VarId
\newcommand\VarSym[1]{\mathbin{\textcolor{VarSym}{\mathit{#1}}}}

% Data constructor identifier and symbol
\newcommand\ConId[1]{\mathord{\textcolor{ConId}{\mathit{#1}}}}
\let\Conid\ConId
\newcommand\ConSym[1]{\mathbin{\textcolor{ConSym}{\mathit{#1}}}}

% Type variable identifier
\newcommand\TVarId[1]{\mathord{\textcolor{TVarId}{\mathit{#1}}}}

% Type constructor identifier
\newcommand\TConId[1]{\mathord{\textcolor{TConId}{\mathit{#1}}}}
% \newcommand\TConSym[1]{\mathbin{#1}}
\newcommand\TConSym[1]{\mathbin{\textcolor{TConSym}{\mathit{#1}}}}

% Type class identifier
\newcommand\TClassId[1]{\mathord{\textcolor{TClassId}{\textit{#1}}}}

% Comment
\newcommand\Comment[1]{\textcolor{Comment}{\textit{#1}}}

% Package identifier (used in text, not code/math environment)
\newcommand\PkgId[1]{\textcolor{Char}{\texttt{#1}}}


%-------------------------------------------------------------------------------
% Substitutions
%-------------------------------------------------------------------------------

% Set the basic substitution directives to use a sans-serif font.




% Comments: one-line, nested, pragmas



%-------------------------------------------------------------------------------
% Utility
%-------------------------------------------------------------------------------

% Dots - ellipsis for omitted code


% Remove vertical space


%-------------------------------------------------------------------------------
% Keywords
%-------------------------------------------------------------------------------




% Prevent conflict with typical use of 'as'

%-------------------------------------------------------------------------------
% Common symbol variables
%-------------------------------------------------------------------------------


% Due to Jeremy Gibbons
\def\doubleequals{\mathrel{\unitlength 0.01em
  \begin{picture}(78,40)
    \put(7,34){\line(1,0){25}} \put(45,34){\line(1,0){25}}
    \put(7,14){\line(1,0){25}} \put(45,14){\line(1,0){25}}
  \end{picture}}}



% format .                       = "\cdot "


% Dot - for use with forall


% Exponentiation - avoid conflict with spacing.fmt



%-------------------------------------------------------------------------------
% Common module names
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
% Common type names
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
% Common class names
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
% Types with single letters
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
% Type variables
%-------------------------------------------------------------------------------




%-------------------------------------------------------------------------------
% Type variables with subscript indexes
%-------------------------------------------------------------------------------







%-------------------------------------------------------------------------------
% Value variables with subscript indexes
%-------------------------------------------------------------------------------








% -----------------------------------------------------------------------------
% GENERIC
% -----------------------------------------------------------------------------






%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{exists.fmt}%
\makeatletter

\newcommand\hsexists{\global\let\hsdot=\hsperiodonce}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput

\newcommand{\js}[0]{JavaScript\xspace}
\newcommand{\jss}[0]{JavaScripts\xspace}
\newcommand{\oohaskell}[0]{{\rm OO}Haskell\xspace}
\renewcommand{\familydefault}{\sfdefault}

\renewenvironment{quote}
{\list{}{\rightmargin\leftmargin}%
\item\relax\small\begin{em}}
{\end{em}\endlist}

\DefineVerbatimEnvironment%
{OCaml}{Verbatim}
{xleftmargin=10mm,numbers=left,numbersep=2mm,
frame=single,label=OCaml}

\pagestyle{headings}

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\renewcommand{\chaptermark}[1]{\markboth{\ #1}{}}

\bibliographystyle{plain}

\date{\today}

\begin{document}

\begin{titlepage}

\begin{center}
  \text{\large Master of Science Thesis}\\[2cm]
  \text{\Huge wxHaskell for the web}\\[0.5CM]
  \text{\large \emph{Substituting C++ with Haskell and \js}}\\[4.5CM]
  \text{\large by}\\[0.5cm]
  \text{\Large Ruben Alexander de Gooijer}\\[0.5cm]
  \large \today\\[0.5cm]
  % \text{INF/SCR-09-60}\\[0.5cm]
  \vfill
  \includegraphics[scale=.5]{resources/uulogo.png}\\[1cm]
\end{center}

\begin{minipage}{0.7\textwidth}
\begin{flushleft} \large
Center for Software Technology\\
Dept. of Information and Computing Sciences\\
Utrecht University\\
Utrecht, the Netherlands
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Daily Supervisor:} \\
dr. A. Dijkstra \\
\emph{Second Supervisor:} \\
prof. dr. S.D. Swierstra
\end{flushright}
\end{minipage}

\end{titlepage}

\begin{abstract}
Traditionally applications were built to run on top of a desktop platform, but this is changing rapidly and the web is now becoming the default deployment platform. Especially, with the new HTML5 standard the web becomes an even more attractive platform for many hybrid client/server applications. In Haskell one of the goto libraries for building graphical user interfaces is wxHaskell. We are motivated by the idea of using the high level abstractions of wxHaskell to develop type-safe client-side web applications in Haskell. With the recent advent of a \js back-end for UHC this has become an attainable goal. As a proof of concept we have ported a feature-light version of the wxAsteroids game from the original wxHaskell paper to the browser leaving the source code almost untouched. We have developed several tools that have helped us realizing the implementation. First, we improved the existing \js FFI, its surrounding infrastructure, and created interfaces to the necessary platform interfaces. Second, we have developed a library for Object-Oriented programming in Haskell, inspired by OOHaskell, that contrary to OOHaskell does not dependent on functional dependencies. This library has enabled us to maintain the wxHaskell interfaces while substituting the wxWidgets C++ implementation for one written in Haskell implemented in terms of HTML5.

\end{abstract}

\clearpage

\tableofcontents

\chapter{Introduction}

\section{On a historical note}
\label{ch:researchquestion}

The internet has become a low cost model for delivering content and applications to end-users. Although historically based around a page-centric model there recently has been a shift taking place diverging from latter model to one wherein the page becomes a more active participant in the interaction of the user with the application \cite{ajax}. Essentially taking the page-centric model and transforming it into a more desktop like experience where updates to the graphical user interface appear more or less instantaneous. To take advantage of the high reachability, centralized maintenance, and low distribution costs of the web platform many applications nowadays start out their life as web applications. Furthermore, many traditional applications that could benefit from the web platform are being rewritten such that they can
be deployed on the web. A new class of Internet applications has come to light, often coined as the next generation of Internet applications or \emph{Rich Internet Applications} \cite{allaire:2002}, which try to offer the high level of interactivity that users are accustomed to from desktop applications.

Because the Internet standards were not initially built with this particular usage in mind there are many issues that needed to be resolved to develop  RIAs on top of these standards. Several companies have tried to workaround the limitations by providing the extra functionality through a
browser plugin \cite{ghoda2010introducing,young2008adobe,weaver2007javafx}. However, with the recent resurgence in the amount of browsing platforms and the availability of more adequate standards have rendered these approaches partially redundant and or inadequate. The same capabilities are now either built in natively or can be simulated on top of the new standards \cite{html5}.

Although the capabilities of web browsers have significantly improved they still lack many of
the functionalities that desktop programmers have grown accustomed to. This gap in 
functionality is bridged by the development of graphical user interface (GUI) toolkits that offer things 
like layout and window management, more comprehensive widget sets, and mechanisms to integrate application data.
Accessory to the development of RIAs is the increasing complexity of client-side applications.
The client-side can no longer be regarded as merely a view on the application's data. 
It has gained a multitude of responsibilities such as the management of complex application state, 
synchronization of state with the server,  validation of user input, etc. Consequently the client becomes 
tightly coupled with the server and needs to have in-depth knowledge about its data types and calling conventions. 
This can very quickly become a maintenance problem and a source for bugs when the different tiers (client, server, database) use different formalisms without providing some automated mapping between them \cite{Cooper06links:web}. 
The dynamically typed language JavaScript which is at the foundation of every interactive web application worsens the problem \cite{Mikkonen:2008:WA-:1443226.1444030, Mikkonen:2007:UJR:1698202}. Many people attempted to mitigate the problems by creating new languages \cite{dart,burnham2011coffeescript,cappuccino}, appropriate tooling \cite{bolin2010closure}, libraries \cite{zammetti2009practical,russell2008dojo,lindley2009jquery}, and any combination of these.

\section{Motivation}
\label{sec:webbackendwxHaskell}

The recent addition of a JavaScript back-end to the \emph{Utrecht Haskell Compiler} (UHC) \cite{Dijkstra:2009:AUH:1596638.1596650} 
opens up the possibility to create client-side web applications using Haskell. The compiler translates the UHC Core language (a minimal functional language) to a JavaScript program which may run directly in the browser (supported by a small runtime system).

The use of Haskell will likely induce a performance penalty, but in return offer many advantages over JavaScript: type safety, laziness, compiler optimizations, etc. Furthermore, thinking ahead, when augmented with a Haskell server-side component it is possible to automatically get data type consistency between client and server. This tier-less approach to programming web applications resembles that of the Google Web Toolkit (GWT) \cite{hanson2007gwt} and the proprietary WebSharper \cite{Bjornson:2010:CRG:2050135.2050148}.

% Problem description

To move Haskell forward into the space of web programming, and in particular that of RIAs the presence of tooling for
creating Graphical User Interfaces (GUI) is key. Although Haskell has already quite some existing GUI toolkits \footnote{For a full list of the available GUI libraries in Haskell see \url{http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries}}, none of them run in the browser. There has been a previous attempt to alleviate this problem, but unfortunately it depends on a proprietary (albeit widespread) browser plugin \cite{wxflashkell}. We have similar goals, but do not want to depend on a proprietary plugin that bypasses the web standards. 

% Interlude

Because there are already many Haskell libraries for constructing desktop GUIs in Haskell it makes sense to retrofit an existing one such that it may run in the web browser. This allows us to benefit from years of experience constructing programming interfaces for GUI development and expedites porting existing desktop applications to the web (typically considered a large undertaking). 

% What are the main approaches

There are two disparate lines of programming GUIs in Haskell: using Functional Reactive Programming (FRP), or the traditional imperative event handler based approach. With FRP widgets (Window Gadgets) are typically viewed as stream processors - taking an input stream and producing an output stream. GUIs are formed by composing widgets using combinators that take two or more widgets and compose them into a single larger widget. The combinators designate how the constituent inputs are routed such that they may become outputs of the larger whole. A GUI application, from the FRP perspective, is therefore often viewed as a network of communicating widgets in which data flow is made explicit. The imperative approach is less explicit about its data flow. A typical imperative-style GUI is constructed by creating new instances of widgets, composing them in a tree-like structure, connecting callbacks to widgets allowing an application to react to event occurrences, and at the end initialize the GUI application by entering an \emph{event loop} that detects events and dispatches them to the appropriate event handlers. This is the more traditional approach to program GUI applications and its lack of explicit data flow makes is much more flexible compared to the FRP approach at the expense of purity and ease of reasoning.

% Compare FRP vs Imperative for suitability

FRP is still active research and is slowly moving out of academia, but has thus far not yet really caught on as a popular way to construct GUIs. There also seems to be no general consensus on which FRP approach is best. On the contrary, the imperative approach has seen wide adoption with many GUIs constructed using it. Furthermore, existing FRP seem to often use advanced language extensions not supported by UHC which would make porting the interface arduous or maybe even impossible. Because of this practical issue and the fact that FRP is not well established as a GUI programming technique we lean towards the safe side and opt for a more imperative approach.

% Oke, but which imperative lib?

The most prominent imperative-style GUI toolkits for Haskell are Gtk2HS \cite{gtk2hs} and wxHaskell \cite{wxhaskell}. Both wrap existing C/C++ GUI toolkits (GTK+ \cite{gtk+}, wxWidgets \cite{smart2006cross}) in Haskell and expose a more abstract interface. Comparatively wxHaskell offers nicer abstractions than Gtk2Hs does. The difficulty with both libraries is that they provide a mere interface to the functionality implemented in a foreign language. Porting any of them to the browser would require the reimplementation of this functionality. Because wxHaskell already works across desktop platforms and offers more evolved abstractions we choose to base our work on wxHaskell. 

\section{Research problem}
\label{ch:problemdefinition}

The absence of an approach for programming client-side web GUIs in Haskell has led us to formulate our problem through the following research question: 

\begin{itemize}
	\item \emph{How can wxHaskell be made to run in the web browser?}
\end{itemize}

In order to provide a suitable answer to this insidiously simple question we will investigate the different options for making wxHaskell run in the web browser, pick one, and demonstrate its viability by porting the implementation of wxAsteroids, a clone of the classic Asteroids game also used by wxHaskell to demonstrate its design and capabilities.

\section{Outline}

The outline of this thesis is as follows. In chapter \ref{chap:background} we provide some background information on GUI toolkits, the architecture of wxHaskell, the web browser platform, and the UHC compiler. Chapter \ref{chap:designspace} explores the different options for porting wxHaskell to the web. After picking a particular implementation path chapter \ref{chap:jsffi} continues with developing the necessary tooling for interfacing with \js from within Haskell. Subsequently, in chapter \ref{chap:lightoo} we develop an OO programming library which we use in chapter \ref{chap:wxasteroids} to implement a subset of wxHaskell necessary for the wxAsteroids game to work. Finally, we wrap up with a conclusion in chapter \ref{chap:conclusion}.
\chapter{Background}
\label{chap:background}

\section{On the role of GUI toolkits}

Before GUI toolkits existed every programmer constructed its own interface elements. Obviously the result
was a lack of consistency between different user interfaces and abysmal reuse. This state of affairs
led to the invention of the GUI toolkit to aid consistency and rapid development through reuse. 
Toolkits typically provide well integrated library of standardized widgets and
a framework that deals with the low-level intricacies of graphic manipulation and event handling. The 
application programmer no longer needs to worry about consistency and may reuse existing interface elements. The GUI toolkit is a generic piece of software and as such does not deal with application specific logic. However, through its framework it provides the programmer with the possibility of integrating application specific functions that react to user input.

GUI toolkits have strong roots inside the object-oriented programming language (OOP) community \cite{Krasner:1988:CUM:50757.50759}, one of the many reasons why todays GUIs are more often created in object-oriented languages. Although GUI programming is not particularly
tied to OOP, there is a clear correspondence between OOP concepts and those necessary to effectively model user interfaces. Object identity,
state encapsulation, and inheritance all play an important role in many current GUI toolkit implementations.

\begin{figure}[h]
\center
\includegraphics[scale=.3]{resources/GUIstack.png}
\caption{Unix desktop GUI stack \cite{Gansner:1992:FUI:131302.131315}.}
\label{fig:desktopguistack}
\end{figure}

Figure \ref{fig:desktopguistack} shows where a GUI toolkit is typically situated on a desktop stack.
Although the figure represents Unix-like environments it is quite similar to that of other operating systems.
Libraries like GTK+ \cite{gtk+} and Qt \cite{qt} are situated at the foundational level and communicate
through XLib with the X Window System \cite{x}.

The following sections describe the constituents of a GUI toolkit from a high level perspective. 

\subsection{Graphical representation}

\emph{From an abstract interface description to pixels on the screen.}

\noindent An important part of what GUI libraries facilitate is the composition of an abstract interface description out of widgets.
It is the responsibility of the GUI library to effectively communicate this abstract description to the underlying layer
instructing a display device to display the correct image. Providing a balance between flexibility and standardization of
graphical elements is key to every GUI library. Consequently widgets are typically parameterized over a large class
of attributes (border style, background color, ...) allowing the programmer to influence the style and eventual location of
their widgets. Often, however, the exact placement of widgets is not desirable \emph{per se} and so called layout managers 
may be used that take in many widgets and provide for the automatic alignment of widgets.

By virtue of being a communication mechanism GUIs never exist in isolation but take the role of intermediary between
a human and application. The host operating system may run multiple applications simultaneously 
of which an arbitrary number may use the screen to display their GUIs. The screen thus receives a stream
of possibly interleaved drawing instructions and it suddenly becomes unclear what
the end result will be. For instance, with access to the whole screen applications may erase (partially) each others GUIs by drawing 
at overlapping coordinates. To allow fair use of the display hardware and 
resolve the ambiguity of what will be displayed on screen a central coordination mechanism must be put in place. 

The \emph{X Window System} \cite{x} is such a central coordinating system.
It defines the concept of a \emph{window}, a looking glass through which the user can interact
with a computer program. In practical terms this means that it is a rectangular area on the screen capable of displaying
graphics and receiving input. Every window is contained within another window. The \emph{root window}
is at the top of the window hierarchy and spans the whole screen. The direct children of the root window
are called top-level windows and are treated as special by what is called a \emph{Window Manager}. They are typically
decorated with a title bar, a set of buttons (minimize, maximize, close), and may be moved around and resized.
The window concept helps X with distinguishing applications allowing it to handle clipping \footnote{Clipping is a procedure that identifies if a picture is outside or inside a particular "clipping" area} problems effectively
and implement flexible and efficient event handling mechanisms (see \ref{sec:userinput}).

\begin{figure}[h]
\center
\includegraphics[scale=.6]{resources/Some_X_windows.png}
\caption{A possible placement of windows. \newline \url{http://en.wikipedia.org/wiki/File:Some_X_windows.svg}}
\label{fig:windows}
\end{figure}

On Unix-line operating systems the \emph{X Window System} \cite{Scheifler:1986:XWS:22949.24053} is the most commonly used windowing system 
and many modern GUI toolkits are built on top of it \cite{gtk+,qt}.  It provides a network-transparent window system through a client-server architecture where the server distributes user input to and accepts display instructions from its clients.
The client communicates with the server and \emph{vice versa} through the \emph{X Window Protocol}.
It is however uncommon that this happens directly and most GUI toolkits built on top of the \emph{XLib library} \cite{gettys1990xlib}.
Worthy of mentioning is that the client and server need not be on different machines and the standard situation on a desktop environment
is that both reside on the same machine.

\begin{figure}[h]
\center
\includegraphics[scale=.6]{resources/xlib_helloworld.png}
\caption{A GUI running on Ubuntu 11.10 using XLib see appendix \ref{app:xlib_helloworld}.}
\label{fig:xlib_helloworld}
\end{figure}

Figure \ref{fig:xlib_helloworld} shows the output of a traditional "Hello World" program written using XLib.
What happens is that the application (client) opens a connection to the X server 
and requests the creation of a new top-level window. The request is intercepted by the \emph{Window Manager}
which \emph{reparents} the window such that it becomes a descendant of a decorated window with a title bar
and control buttons. The program proceeds by sending a command instructing the X server to draw the string 
\emph{"hello world"} to the screen. The server delegates the request to the device driver responsible for
managing the graphics hardware.

Now that we almost hit rock bottom we move back up the layers of abstraction and
just above the GUI toolkit we find what are called \emph{User Interface Markup Languages}.
These languages, often dialects of \emph{Extensible Markup Language} (XML), provide a declarative way of specifying a GUI making
it easier to construct GUIs by not bothering the programmer with the distractions of the implementation language.
Furthermore, the implementation of visual construction and manipulation tools becomes arguably
easier. The presence of these tools ushered in a new era in which the programmer is no longer the predominant factor in the process of
constructing GUIs (at least for the graphical part). There is a \emph{scala} of different UI markup languages 
but some of the common ones are: XUL, XAML, and the arguably incomplete XHTML. 

\subsection{User input} 
\label{sec:userinput}

\emph{From a mouse click to a button clicked event}

Typically a user interacts with a computer program through input devices such as a mouse, keyboard, or touch pad.
Upon interaction the device drivers should be aware of changes in device state. How this happens actually depends on
the input device. It may happen through a hardware interrupt or by continuously polling for changes. A GUI registers
interest in device state changes. Once a state change occurs the GUI is notified and it invokes the appropriate
application logic which may perform arbitrary computations and provide the user with visual feedback.
The essence of this process is clearly captured by Fruit \cite{fruit}, expressing
the top level GUI as a Yampa \cite{yampa} signal function (SF):

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{SimpleGUI}\mathrel{=}\Conid{SF}\;\Conid{GUIInput}\;\Conid{Picture}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \emph{GUIInput} type is a snapshot of the input device state. The \emph{Picture} type contains
the new visual representation in response to the \emph{GUIInput}. Although accurate as
a top level description it is not representative for internal widgets, whom are likely to observe additional
arbitrary values:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{GUI}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{SF}\;(\Conid{GUIInput},\Varid{a})\;(\Conid{Picture},\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Conid{SimpleGUI}\VarSym{â‰…}\Conid{GUI}\;()\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In between observing a state change at the device driver level and transforming it into a high level event a lot may happen.
Take for example any GUI toolkit based on top of the X Windowing System. When X receives input it designates the \emph{owner} window.
The window abstraction makes this process efficient and straightforward. 
Each window is assigned a particular part of the screen, stacking order, and focus. Based on these properties X can distill
which windows are visible and thus eligible for receiving events. Dependent on whether the window owner (an application) has registered
interest in the particular event the event will be discarded or dispatched to the application. The application (GUI toolkit) takes notice of these events through what is called an \emph{event loop} which dispatches events to the appropriate event handlers. Event handlers have intimate knowledge of the GUI and may interpret a low level \emph{mouse clicked} event as
a high level \emph{button clicked} event. Although obviously a simplification, leaving out many details, it roughly corresponds to what happens.

\subsection{Application integration}

\emph{From a static user interface to an interactive application.}

Widgets know how to build visual representations out of their abstract descriptions and interpret low level user input as high level semantic actions. To be of any use they allow the integration of application specific logic invoked upon the occurrence of an internal widget event (e.g. button clicked, item selected). These fragments of application specific logic are often supplied through \emph{callback} functions, similar to how the lower level events are captured by the GUI toolkit.
These callback functions, and all other code with access to the application state, may modify the state effectively rendering the widget's visual representation out of sync. The most basic GUI toolkits leave it up to the programmer to manually keep the GUI in sync with the application state.

State synchronization is not only a problem at the level of application integration, but also internally at the level of widget design. To remedy this problem typical implementations of the Model-View-Controller (MVC) pattern use the \emph{Observer Pattern} to keep the view(s) synchronized with the model.

The MVC pattern, first described by Smalltalk \cite{Krasner:1988:CUM:50757.50759}, follows the design principle \emph{Separation of Concerns} to separate out the distinct aspects of widgets - application state (model), visual representation (view), input events (controller) - which makes for a modular GUI library design. The MVC pattern has seen wide spread adoption (albeit in deviating forms) as a technique for developing GUI toolkits \cite{javaswing} \footnote{For a list of MVC frameworks see \url{http://en.wikipedia.org/wiki/Model-view-controller}}. 

The \emph{Observer Pattern} has a strong resemblance with reactive programming techniques wherein a data flow graph is constructed such that changes can be automatically propagated to the data dependencies. 
Reactive programming techniques vary in explicitness about the data flow graph constructed. The Functional Reactive Programming (FRP) approach is typically very explicit about the data flow graph by using arrows to express data dependencies. Explicitness requires more thought, but allows for much better reasoning about what happens as a reaction to a certain event. Further advantages of FRP are that it is much easier to construct composite events (e.g. drap and drop) and because data flow is usually much more granular state changes may cause more efficient repainting.

An alternative approach to state synchronization is \emph{data binding} which under the surface also uses the \emph{Observer Pattern} but typically offers a more end-to-end approach to synchronization. It allows the programmer to create for example a data binding for a text field to a particular record in a database. The data binding will ensure that modifications to the text field's contents will automatically be propagated to the database. 

\section{wxHaskell: a quick overview}
\label{sec:wxhaskell}

wxHaskell \cite{wxhaskell} is a GUI library for Haskell that wraps around the wxWidgets C++ library \cite{smart2006cross} offering a more declarative interface for programming GUIs. It aims to provide a library that is efficient, portable across platforms, retains a native look-and-feel, provides a lot of standard functionality, good abstractions, and is type safe where possible.
The author notes that there are no intrinsic difficulties with achieving these desired properties, but that it takes a large initial effort followed by an enduring maintenance effort. Many previous attempts by the Haskell community to construct GUI toolkits have underestimated the amount of work that goes into maintenance and eventually turned out to fail. To avoid this pitfall wxHaskell builds on top of wxWidgets, a widely supported industrial-strength widget toolkit that eases the development of cross platform GUI applications.

The design of wxHaskell divides into four distinct increasingly abstract layers with at the bottom layer the low-level details of interfacing with C and at the top layer a declarative interface for programming GUIs:

\begin{enumerate}
   \item {\bf wxDirect}: responsible for generating the Haskell wrappers and foreign import declarations from C signatures.
   \item {\bf wxC}: provides the coupling of Haskell with wxWidgets. The wxWidgets FFI declarations are wrapped in Haskell functions that perform conversions between C and Haskell types and the converse.
   \item {\bf wxCore}: uses wxC to expose the core wxWidgets Haskell interface.
   \item {\bf wx}: uses wxCore to provide the user with a more declarative interface for programming wxWidgets. It also contains a combinator library to specify layouts.
\end{enumerate}

In wxHaskell the development of GUI applications is centered around the imperative IO monad, something which in general Haskell programmers would like to avoid. Though because of Haskell's treatment of IO computations as first-class values the library can reach a much higher level of abstraction than can typically be attained in any other language lacking such treatment. Still, wxHaskell employs implicit data flow across event handlers through the use of mutable state.

Inside the bottom layer wxHaskell communicates with wxWidgets by using Haskell's C FFI. In order to retain type safety for widget operations wxHaskell wraps pointers to widgets inside a subtyping hierarchy by using \emph{phantom types}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Object}\;\Varid{a}\mathrel{=}\Conid{Ptr}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CWindow}\;{}\<[15]%
\>[15]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{CFrame}\;{}\<[15]%
\>[15]{}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{Window}\;{}\<[14]%
\>[14]{}\Varid{a}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Object}\;(\Conid{CWindow}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Frame}\;{}\<[14]%
\>[14]{}\Varid{a}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Window}\;(\Conid{CFrame}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Both \ensuremath{\Conid{CWindow}} and \ensuremath{\Conid{CFrame}} are considered phantom types, they lack a corresponding data declaration and thus only exist at compile time. Using type synonyms the subtyping relationship is encoded. Note that the type variable is left polymorphic, however often operations may want to specify that they expect and or produce an exact type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{frame}\ConSym{::}[\mskip1.5mu \Conid{Prop}\;(\Conid{Frame}\;())\mskip1.5mu]\to \TConId{IO}\;(\Conid{Frame}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This is accomplished by applying the type to \ensuremath{()} (unit) making it monomorph. For example in the function \ensuremath{\Varid{frame}}, it takes a list of properties definable on a \ensuremath{\Conid{Frame}} or any supertype and produces an instance of a \ensuremath{\Conid{Frame}}.

Objects encapsulate state and provide methods for state manipulation. A typical pattern is to provide so called \emph{getters} and \emph{setters} for state manipulation. wxHaskell captures association of a particular attribute with a widget using the \ensuremath{\Conid{Attr}} type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{title}\ConSym{::}\Conid{Attr}\;(\Conid{Window}\;\Varid{a})\;\TConId{String}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A value of type \ensuremath{\Conid{Attr}} bundle both \emph{getter} and \emph{setter}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Attr}\;\Varid{w}\;\Varid{a}\mathrel{=}\Conid{Attr}\;(\Varid{w}\to \TConId{IO}\;\Varid{a})\;(\Varid{w}\to \Varid{a}\to \TConId{IO}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It does not contain any state but simply provides access to an object's accessor functions. Two helper functions are defined that allow both the retrieval of a value and the assignment of a list of values to an object:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{get}\ConSym{::}\Varid{w}\to \Conid{Attr}\;\Varid{w}\;\Varid{a}\to \TConId{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{set}\ConSym{::}\Varid{w}\to [\mskip1.5mu \Conid{Prop}\;\Varid{w}\mskip1.5mu]\to \TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

When a value is combined with an attribute it is called a \emph{property}. Properties are represented by the \ensuremath{\Conid{Prop}} type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}c<{\hspost}@{}}%
\column{4E}{@{}l@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}c<{\hspost}@{}}%
\column{30E}{@{}l@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Prop}\;\Varid{w}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\exists \Varid{a}\hsexists \hsdot{\circ }{.}(\Conid{Attr}\;\Varid{w}\;\Varid{a}){}\<[30]%
\>[30]{}\ConSym{:=}{}\<[30E]%
\>[35]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid {}\<[4E]%
\>[7]{}\exists \Varid{a}\hsexists \hsdot{\circ }{.}(\Conid{Attr}\;\Varid{a}\;\Varid{w}){}\<[30]%
\>[30]{}\ConSym{:\char126 }{}\<[30E]%
\>[35]{}(\Varid{a}\to \Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid {}\<[4E]%
\>[7]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note the use of existential quantification which allows multiple properties of different value types to be stored in a homogeneous list.
The following example combines all the features described thus far to capitalize the \ensuremath{\Varid{title}} of a \ensuremath{\Conid{Window}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{capitalizeTitle}\ConSym{::}\Conid{Window}\;\Varid{a}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{capitalizeTitle}\;\Varid{w}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{t}\leftarrow \Varid{get}\;\Varid{w}\;\Varid{title}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{set}\;\Varid{w}\;[\mskip1.5mu \Varid{title}\ConSym{:=}\Varid{map}\;\Varid{toUpper}\;\Varid{t}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The definition of \ensuremath{\Varid{title}} is fine because its a fairly unique attribute, however an attribute like \ensuremath{\Varid{text}} is very common and shared by many widgets. Because attributes often overlap and user defined widgets might also want to reuse the same attribute wxHaskell uses type classes to model shared attributes.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{Textual}\;\Varid{w}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{text}\ConSym{::}\Conid{Attr}\;\Varid{w}\;\TConId{String}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{Textual}\;(\Conid{Window}\;\Varid{a})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{text}\mathrel{=}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Where phantom types provide vertical reuse, \emph{ad hoc} overloading provided by type classes allows for horizontal reuse.
Though wxHaskell has many other features such as layout combinators, event handling, further discussion of features is postponed to the appropriate places in the upcoming chapters.

\section{The target platform}

The web browser has become a complex beast serving as a deployment platform for an ever increasing amount of web pages and applications. In this section we will provide a very brief overview of the core technologies used to built web pages and applications.

\subsection{DOM}

The \emph{Document Object Model} is a cross-platform and language-independent standard for representing and interacting with objects defined in XHTML documents. It is the interface through which web browser expose their internal state of a web page for \js to interact with. 

\subsection{Graphical representation}

Web browsers offer several technologies for rendering graphics, standardized by the World Wide Web Consortium (W3C) \footnote{\url{http://www.w3.org/}}. This section provides a brief overview of the three major standards and describes their individual merits.

\subsubsection{Canvas}

The Canvas is an element in the DOM that can be used by JavaScript to perform basic drawing operations. The drawing operations are performed upon a bitmap surface that has no recollection about what is actually drawn. This makes the canvas applicable for things like animations, image manipulation, games, or anything that draws a large number of objects that are not necessarily interactive. Consequently event handlers maybe attached to the element itself but not to its contents. If such behavior is required it either has to be written from scratch or be simulated by overlaying XHTML elements. Noteworthy is that the Canvas API very much resembles the level of abstraction offered by many well known graphics APIs such as Java2D \footnote{\url{http://java.sun.com/products/java-media/2D/index.jsp}}.

\subsubsection{SVG}

Scalable Vector Graphics (SVG) \cite{svgprimer} is a XML markup language for creating vector graphics. SVG is a strictly higher level drawing facility than the Canvas. It remembers everything it drew inside a scene graph allowing it to be more intelligent in repainting its composites and support interactivity on every object it has drawn, contrary to Canvas. Furthermore, it tightly integrates with the DOM which makes cooperation with other web technologies such as XHTML and CSS easier.

\subsubsection{XHTML - CSS}

Cascading StyleSheets (CSS) apply visual styling to the structure of an XML HyperText Markup Language (XHTML) or to SVG. XHTML roughly defines a set of text elements, elements for attaching semantic meaning to other elements, media elements (video, audio), and a collection of form elements for user input. Each element may be have event handlers attached. The combination XHTML - CSS offers more in terms of standard facilities compared to Canvas and SVG but lacks the flexibility of both in terms of flexible drawing primitives. This deficiency is usually compensated by either using browser plugins, or more recently by embedding Canvas and SVG elements in XHTML documents augmenting the XHTML experience \footnote{A hybrid HTML5 game, Canvas, XHTML, and CSS \url{http://www.cuttherope.ie/}}.

\subsection{Interactive web pages with JavaScript}

JavaScript/ECMAScript is a dynamically typed prototype-based language. It is the primary means for turning static web pages into highly interactive web applications. The web browser (the host environment) allows access to the elements of a web page by exposing its functionality to JavaScript through the Document Object Model (DOM). JavaScript features objects, first class - higher order - and variadic functions amongst other things \cite{ecmascript}.

\section{UHC}

\begin{figure}[h]
\center
\includegraphics[scale=.4]{resources/uhc_pipeline.png}
\caption{The UHC pipeline.}
\label{fig:uhcpipeline}
\end{figure}

The Utrecht Haskell Compiler is an experimental compiler for Haskell 98 plus some additional language extensions, developed at the University of Utrecht 
\cite{Dijkstra:2009:AUH:1596638.1596650}. Its purpose is more geared towards being a language experimentation platform as opposed to being a industrial-strength compiler like the Glasgow Haskell Compiler (GHC) \cite{ghc}. Internally the compiler is organized into different language variants. Each variant may be compiled separately making language experimentation significantly easier. The compilation proceeds by pushing a Haskell through a series of transformations, expressed as algebras using the Utrecht University Attribute Grammar system (UUAG) \cite{Swierstra:1998:Combinator}, which result in intermediate languages that get progressively closer to the target platform. 

Figure \ref{fig:uhcpipeline} displays the compilation pipeline targeting JavaScript. In the first phase the input Haskell program is desugared into Essential Haskell (EH) a desugared variant of Haskell. EH is transformed into the Core language which constitutes a very minimal functional language resembling the lambda calculus. Subsequently the JavaScript backend hooks into the compilation process and translates Core to JavaScript. It links the compiled source program together with its base library dependencies and the \emph{Runtime System} (RTS) inside a single XHTML document.
\chapter[Exploring the design space]{wxHaskell for the web: exploring the design space}
\label{chap:designspace}

\emph{Bridging the wxWidgets gap}

The goal of this thesis is to show how a subset of wxHaskell can be ported to the web browser. However, as always, there are many routes that lead to Rome. In section \ref{sec:wxhaskell} we briefly discussed the layered architecture of wxHaskell. Before we pick a particular implementation path we first consider the different ways we can cut the cake. Because wxWidgets is written in C++ and all its implementations are in terms of desktop technology there is no chance of reusing any code. Without wxWidgets, wxHaskell is just a small layer of abstractions. Somehow the gap left by wxWidgets needs to be filled with an implementation in terms the browser technology whilst trying to maintain the old programming interface. In figure \ref{fig:wxweboptions} the different options are aligned next to the original wxHaskell set-up. They only differ in where the line is drawn separating Haskell from \js. In this chapter we will discuss each option individually, weigh their pros and cons, and pick one approach that will dictate the further developments in this thesis.

\begin{figure}[h]
\center
\includegraphics[scale=.5]{resources/mapping.png}
\caption{Design options: orange: C++, yellow: JavaScript, blue: Haskell}
\label{fig:wxweboptions}
\end{figure}

\section{Port wxC in Haskell (A)}

The intention of this approach is to leave the original \emph{wxC} interface intact, swap its implementation with equivalent functionality provided by some \js GUI toolkit, augmented with some additional \js wrapper code to overcome mismatches in functionality. With the \js GUI toolkits maturing there are quite some options that provide approximately the same functionality as wxWidgets. 

In order to access all the features of the underlying \js GUI toolkit there is a significant amount of boilerplate code required. Assuming that we may generate this boilerplate automatically from an API description there still remains lots of subtle porting work in order to nicely fit the functionality with the \emph{wxC} interface. From a Haskell perspective we end up in a rather strange situation wherein we are trying to sustain an imperative programming interface for an C++ API by porting its calls to a \js API inside Haskell which does not natively support OO programming. Furthermore, the obtained solution will from a Haskell point of view not be very portable as the majority of the functionality is still implemented in a foreign language. Also, changing to another GUI toolkit requires a total rewrite.

{\bf Advantages:}
\begin{itemize}
   \item We get a large tested and maintained code base almost for free;
   \item Ideally, it is a drop in replacement for \emph{wxC} requiring no change in the above layers.
\end{itemize}

{\bf Disadvantages:}
\begin{itemize}
   \item Connecting two OO interfaces inside Haskell will not result in idiomatic Haskell;
   \item The majority of the functionality is still written in \js and thus cannot benefit from compiler optimizations;
   \item Tight coupling to \js GUI toolkit results in poor portability and a high degradation risk;
   \item Poor extensibility from within Haskell.
\end{itemize}

\section{Port wxC in \js (B)}

Option B draws the line between Haskell and \js a little bit further down. The key idea is to port the wxWidgets API to \js and perform the actual implementation in \js. This has as advantage over \emph{A} that it leads to a much more natural implementation. It does leave open the question whether there exists a reasonable semantics preserving mapping from C++ to \js. The fact that most web browsers implement the DOM in C++ and provide a \js API to access its functionality would suggest that there is. Also, the similarity between the wxWidgets \js API and its C++ version will likely ease the implementation of the Haskell interface code. This can be explained by the nature of the mapping which will necessarily depend on the set of language features formed by lowest common denominator of C++ and \js, ruling out the use of idiosyncratic features of \js which make it particularly hard to bolt a type safe Haskell interface on top. 

With a set-up much like wxHaskell it inherits many of its architectural properties. For instance, the \js code base does not take part in the compilation process which complicates linking and optimization. This might lead to suboptimal code and larger binaries. Furthermore, every interaction with the wxWidgets implementation induces cross language communication inflicting a performance penalty. In wxPython (a Python wrapper for wxWidgets) widgets are extensible through inheritance just like in C++. However, in Haskell there is no direct equivalent to inheritance. This will eventually limit the flexibility of the end-user gets when using the library.

{\bf Advantages:}
\begin{itemize}
   \item Resembles the wxHaskell approach;
   \item Avoids many difficulties of interfacing with \js from Haskell by providing a C++ like interface in \js;
   \item See advantages of option A.
\end{itemize}

{\bf Disadvantages:}
\begin{itemize}
   \item The majority of the library is implemented in \js;
   \item Not portable from a Haskell perspective;
   \item Not easily extensible from within Haskell.
\end{itemize}

\section{Replace wxCore with a Haskell implementation (C)}

We can also try to move the wxWidgets implementation as much as possible into Haskell thereby reducing the platform dependent code to a mininum greatly improving portability. With a major part of the code base in Haskell we may reap all of its benefits such as compiler optimizations, type safety, etc. Though implementing wxWidgets in Haskell is easier said than done. To stay true to wxWidgets we should port is OO design to Haskell, because Haskell was not envisioned as a OO language with typical features like: subtyping, inheritance, encapsulation; it is not clear at all to us whether this is even possible without extending the language. Fortunately, the authors of \oohaskell have shown that Haskell can indeed be used to model the typical, and some of the more advanced features of OO languages by using some common language extensions. We could use \oohaskell to transport the OO design to Haskell were it not that we are bound by UHC's features that does not yet include functional dependencies. The feasibility of the approach therefore hinges on the question whether there exists some other solution which works using UHC and is as powerful as \oohaskell or less powerful but still powerful enough to model the standard features of any OO language. 

{\bf Advantages:}
\begin{itemize}
   \item Will result in a Haskell GUI library that is easier to port to other platforms besides the web platform;
   \item Increased extensibility with the core design writtein in Haskell;
   \item A larger Haskell code base can benefit from compiler optimizations, type safety, etc. 
\end{itemize}

{\bf Disadvantages:}
\begin{itemize}
   \item The non-idiomatic use of Haskell will likely result in a less efficient implementation.
\end{itemize}

\section{Conclusion}

All three options are potentially viable solutions. Option \emph{A} seems to be the least promising approach, because of its many disadvantages compared to the other two options. Option \emph{B} is the most practical option and will most likely be directly useful. However, from a long term perspective it impairs portability of the whole code base across different target platforms/languages and does not benefit much from Haskell as language. Admittedly, this argument is weakened by the fact that the web platform is one of the most widely used standardized platforms available and will without doubt continue to be so in the foreseeable future. However, with the rate at which new GUI toolkits crop up it is hard to say which one will survive, and with a community of Haskell programmers not particulaly fond of \js as a language it is hard to imagine that they would want to maintain a large \js code base. Option C is also from an academic perspective a more interesting path to take, because to the best of our knowledge porting a real-world OO design to Haskell has not been done before. For the above reasons we choose to continue with option C. Next, we will look into interfacing with \js of which the outcomes will also be useful for options A and B.
\chapter{Interfacing with JavaScript}
\label{chap:jsffi}

The Utrecht Haskell Compiler can compile Haskell down to \js, however for a \js program to be of any real use it must be able to interface with the target platform. The Haskell Foreign Function Interface (FFI) addendum describes a framework for interfacing to foreign languages from within Haskell \cite{ffi}. It instantiates the framework for the C calling convention (which should be supported by all Haskell implementations), and leaves open the possibility of extending it to other calling conventions. The C calling convention is significantly different from \js's, therefore UHC has gained a new one specifically tailored for \js \cite{jcu}.

In many aspects Haskell and \js are each others opposites making it sometimes non-obvious how \js functionality should be mapped onto Haskell and \emph{vice versa}. This quickly becomes apparent when one tries to come up with meaningful type signatures for imported \js functionality. Further, Haskell data types differ quite a bit from the ones in \js leaving open the question on how to deal with conversions between the two different representations. 
When we started our research the \js FFI was work in progress, and at times our efforts mingled with that of the authors of \cite{jcu}. Our work can hence be viewed as a natural continuation of theirs with as goal making \js programming more bearable. We make the following contributions:
\begin{itemize}
  \item extend the existing infrastructure for programming with the \js FFI;
  \item augment the FFI with a new keyword for creating \js objects, and a simple way to incorporate external \js dependencies;
  \item provide a model for primitive \js types, together with type checking and marshalling functions.
\end{itemize}

The outline of the chapter is as follows: section \ref{sec:jsffi_intro} introduces the \js FFI, section \ref{sec:ty-untyped} discusses the possibilities of maintaining type-safety, section \ref{sec:marshalling} describes a simple approach for converting Haskell values from and to \js, section \ref{sec:jsidioms} shows how the \js FFI can be used to model common \js idioms.

\section{Introduction}
\label{sec:jsffi_intro}

The UHC \js FFI extends the \emph{callconv} production of the FFI grammar, found in the Haskell FFI addendum \cite{ffi}, with a new keyword \ensuremath{\Keyword{js}}.

\begin{tabbing}\tt
~decl~~~~~~\char58{}\char61{}~~\char39{}import\char39{}~callconv~\char91{}safety\char93{}~~impent~var~\char58{}\char58{}~ftype\\
\tt ~~~~~~~~~~~~\char124{}~~\char39{}export\char39{}~callconv~~~~~~~~~~~expent~var~\char58{}\char58{}~ftype\\
\tt ~callconv~~\char58{}\char61{}~~\char39{}ccall\char39{}~\char124{}~\char46{}\char46{}~\char124{}~\char39{}js\char39{}
\end{tabbing}

Which calling convention is used determines how the compiler interprets the \emph{impent} and \emph{expent} strings. A formal grammar for the \emph{impent} section is given in \cite{jcu} describing a small subset of \js with only few non-\js parts used for expressing the connection between the formal arguments of a Haskell function and their position in the \js expression. Here we present a revised version of the grammar:

\begin{alltt}
impent   ::= "wrapper" | "dynamic" | jscc
expent   ::= "any string"

jscc     ::= ident '.js ' jsexpr     -- JS expression with external dependency
           | jsexpr 
jsexpr   ::= '\{\}'                    -- Haskell constructor to JS Object
           | 'new'? ptrnOrId post*   -- JS expression
post     ::= '.' ptrnOrId            -- object field
           | '[' jsexpr ']'          -- array indexing
           | '(' args ')'            -- function call
args     ::= \(\epsilon\)
           | '%*'                    -- match all arguments
           | ptrnOrId (,ptrnOrId)* 
arg      ::= '%' int                 -- index a specific argument
           | literal
ptrnOrId ::= arg 
           | ident

literal  ::= 'any character' | "any character" 
ident    ::= letter (letter | integer)*
\end{alltt}

The grammar is extended with the possibility to specify external \js dependencies, the \ensuremath{\Keyword{new}} keyword for instantiating objects, and some ambiguity issues are resolved that arose from using specific combinations of \emph{match all arguments} and \emph{index a specific argument} in a single expression.

Every \emph{jsexpr} is transformed into a valid \js expression iff it is provided with a correct argument mapping (there are currently no checks in place ensuring this is the case).  Furthermore, the FFI does not check whether the imported functionality is actually present at runtime. We imagine that this could be implemented in the future by inserting runtime checks or parsing external sources statically verifying the presence of the imported functionality (not a trivial problem).

With the \js FFI in place we illustrate its use by a typical use case: displaying an alert message.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 window.alert(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{alert}\ConSym{::}\Varid{a}\to \TConId{IO}\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 'Hello~World!'\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{helloWorldStr}\ConSym{::}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{main}\mathrel{=}\Varid{alert}\;\Varid{helloWorldStr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Running \ensuremath{\Varid{main}} will result in the alert shown on the left in figure \ref{fig:browser_hello}. We have imported \ensuremath{\Varid{alert}} such that it can only run inside the IO monad, because we know that it has the side-effect of displaying a message box. There is, however, nothing preventing us from importing \ensuremath{\Varid{alert}} as a pure function. It is the programmer's responsibility judge whether the imported functionality is pure or not. Also, note that the first argument of \ensuremath{\Varid{alert}} can be any value. We could just as well apply it to a Haskell string:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{main'}\mathrel{=}\Varid{return}\;\Char{\char34 Hello~World!\char34}\rightarrowtail \Varid{alert}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The result of running \ensuremath{\Varid{main'}} is shown in the right in figure \ref{fig:browser_hello}. Because \ensuremath{\Varid{alert}} accepts any type as argument and the representation of strings in Haskell differs from \js we get garbage as output.

\begin{figure}[h]
\center
\includegraphics[scale=.4]{resources/browser_helloworld.png}
\includegraphics[scale=.4]{resources/unintented_helloworld.png}
\caption{The result of evaluating \ensuremath{\Varid{main}} on the left, and \ensuremath{\Varid{main'}} on the right.}
\label{fig:browser_hello}
\end{figure}

The problem with \ensuremath{\Varid{alert}} is fairly innocent, however it gets worse with a function like \emph{plus2}:

\begin{tabbing}\tt
~function~plus2\char40{}x\char41{}~\char123{}\\
\tt ~~~return~x~\char43{}~2\char59{}\\
\tt ~\char125{}
\end{tabbing}

In general \js functions can take any number of arguments with any number of types and in all but few cases result in a \emph{TypeError} \cite{jstypesys}. Conform \js we leave the first argument of \emph{plus2} polymorph:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 plus2(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{plus2}\ConSym{::}\Varid{a}\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, again \ensuremath{\Varid{plus2}} does not prevent us from passing in e.g. a boolean instead of a number. When we do \js will coerce the boolean to a number, perform the addition, and return the result with the coercion going unnoticed. While in some cases this is intended behavior, there are many more cases where these coercions are plain programming errors. The silent coercions make it difficult to localize bugs and it gets worse when the size of the code base increases. The fact that tools such as Google Closure \cite{bolin2010closure} are created, that help with type checking, proves that this is in fact a real problem. In the next section we will see how we can give functions like \ensuremath{\Varid{alert}} and \ensuremath{\Varid{plus2}} a better type signature.

\section{Typing the Untyped}
\label{sec:ty-untyped}

In terms of type systems Haskell and \js are each others opposites. Haskell has a strong static type system, i.e. the type rules are checked at compile-time and type inconsistencies are reported to the user. A program that passes the type checker is sound with respect to the type-rules (i.e. if a program is well-typed it cannot cause type errors), hence type consistency checks can be omitted which leads to faster object code. On the other hand in \js all type checking happens at runtime, types are never specified, variables derive their types from the value they point to at runtime, and type inconsistencies are resolved by implicit type conversions.

The \js FFI opens up the beautifully consistent Haskell world to the unsafe \js world. We would like to move away from importing \js functions with all arguments left polymorph to a situation where we can be more precise about a function's type. This should lead to more idiomatic Haskell and thus allow us to benefit from static guarantees made by the Haskell type system. Before we can annotate functions with more precise types we first need a Haskell model of the \js types. We imagine that these annotations may in the future be used to automatically insert runtime type checks, but for now we will resort to manual type checking. We will discuss the proposed \js type model, type checking, and how to deal with union types. 

\subsection{A model for \js types}
\label{subsec:modeljstypes}

The \js language definition \cite{ecmascript} describes several primitive types: undefined, null, boolean, number, and string; as well as several kinds of objects (plain objects, wrapper objects, function objects, array objects, regex objects). The primitive types bool, number, and string each have a corresponding wrapper object with an bi-directional conversion between each pair. Some operations (like \emph{+}) only work for particular primitive types. When these functions receive a value of an other type than the expected type they automatically coerce the value to the expected type.

Of the primitive types we only model \emph{undefined} and \emph{null}. For the others we only model their wrapper object letting it range over values of the primitive type as well as their wrapper object. We piggyback on the coercion semantics of \js, which ensures that we can always use a primitive type as if it were a wrapper object. Furthermore, we have \ensuremath{\Conid{JSAny}} range over all \js types. Figure \ref{fig:js-typehierarchy} shows how the types are related to each other.

\begin{figure}[h]
\begin{tikzpicture}[level distance=10mm,level/.style={sibling distance=30mm/#1}, font={\small}]
\node {JSAny}
  child { 
    node {JSUndefined}
  }
  child {
    node {JSNull}
  }
  child {
     node {JSObject} {
          child {
            node {JSBool}
          }
          child {
            node {JSString}
          }
          child {
            node {JSFunction} 
          }
          child {
            node {JSRegex}
          }
          child {
            node {JSArray}
          }
          child {
            node {$\dots$}
          }
      }
  };
\end{tikzpicture}
\caption{A model of the \js types.}
\label{fig:js-typehierarchy}
\end{figure}

To translate the model to Haskell we make fruitful use of opaque types for \emph{undefined} and \emph{null}, and of phantom types to model a hierarchy of types \cite{wxhaskell,Fluet:2006:PTS:1180085.1180088}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{JSAny}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSUndefined}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSUndefined}\mathrel{=}\Conid{JSAny}\;\Conid{CJSUndefined}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSNull}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSNull}\mathrel{=}\Conid{JSAny}\;\Conid{CJSNull}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSObject}\;{}\<[17]%
\>[17]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSObject\char95 }\;{}\<[17]%
\>[17]{}\Varid{a}{}\<[20]%
\>[20]{}\mathrel{=}\Conid{JSAny}\;(\Conid{CJSObject}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSObject}{}\<[20]%
\>[20]{}\mathrel{=}\Conid{JSObject\char95 }\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSBool}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSBool}\mathrel{=}\Conid{JSObject}\;\Conid{CJSBool}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{JSString}\mathrel{=}\Conid{JSObject}\;\Conid{PackedString}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSFunction}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSFunction\char95 }\;\Varid{a}\mathrel{=}\Conid{JSObject}\;(\Conid{CJSFunction}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CJSRegex}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSRegex}\mathrel{=}\Conid{JSObject}\;\Conid{CJSRegex}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{JSArray}\;\Varid{v}\mathrel{=}\Conid{JSObject}\;(\Conid{BoxArray}\;\Varid{v}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Both \ensuremath{\Conid{PackedString}} and \ensuremath{\Conid{BoxArray}} are UHC specific types used internally for representing respectively plain strings and arrays. \ensuremath{\Conid{JSObject\char95 }} and \ensuremath{\Conid{JSFunction\char95 }} take an additional type parameter which can later be refined to either extend the hierarchy, or make a function type explicit. Note that we do not have a type for \js numbers because all non-aggregate types like \ensuremath{\TConId{Int}}, \ensuremath{\TConId{Float}} and \ensuremath{\TConId{Double}} are shared with the \js. \ensuremath{\TConId{Integer}} is the only exception, because \js has no native support for arbitrary-precision integers an \ensuremath{\TConId{Integer}} value is wrapped by the RTS inside a BigInt object. 

With the model for \js types we can now give both \ensuremath{\Varid{alert}} and \ensuremath{\Varid{helloWorldStr}} a more precise type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 'Hello~World!'\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{helloWorldStr}\ConSym{::}\Conid{JSString}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 window.alert(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{alert}\ConSym{::}\Conid{JSString}\to \TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The DOM defines many interfaces for communicating with the web browser. Each interface corresponds to an object in \js, and we can now easily model these interface types by extending \ensuremath{\Conid{JSObject\char95 }}. As example we use the \emph{Node} interface:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{CNode}\;{}\<[13]%
\>[13]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Node\char95 }\;{}\<[13]%
\>[13]{}\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{JSObject}\;(\Conid{CNode}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Node}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Node\char95 }\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{nodeType}} function is defined for any \emph{Node}. Using the new type we just introduced we can easily express this by leaving the extension of the node polymorph:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \%1.nodeType\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{nodeType}\ConSym{::}\Conid{Node\char95 }\;\Varid{a}\to \TConId{IO}\;\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now \ensuremath{\Varid{nodeType}} can be applied to all objects that are \emph{at least} of type \emph{Node}. This is works using ordinary type unification and enables a form of subtype polymorphism.

Despite all the effort we may spend on typing \js functionality there are plenty opportunities to undo any assumptions made about the types at runtime, e.g. nothing prevents us from changing the definition of \emph{window.alert} to:

\begin{tabbing}\tt
~window\char46{}alert~\char61{}~undefined\char59{}
\end{tabbing}

There is not much we can do about this and similar to the Closure compiler we are forced to make some assumptions about the runtime behavior to ensure consistency:
\begin{itemize} 
  \item all imported JavaScript functions and object properties do not change types at runtime;
  \item prototype chains do not change at runtime.
\end{itemize}

\subsection{Type checking}

% The problem

As soon as data crosses the language border performing runtime type checks to preserve type safety becomes inevitable \cite{Abadi89dynamictyping}. Take for example the \emph{createElement} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 document.createElement(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{createElement}\ConSym{::}\Conid{JSString}\to \TConId{IO}\;(\Conid{Element}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Dependent on which string we pass to \ensuremath{\Varid{createElement}} we get back a different subtype of \emph{Element}. For this function to be useful we must be able to determine the actual return type by discriminating on the value's type at runtime. Once we have verified the value to be of a particular, more specific, type we may interpret it as such using a cast.

% The dynamics solution

One approach to implement runtime type checking of \js values would be to reuse the \ensuremath{\Conid{Data}.\TConId{Dynamic}} machinary which works by packing together a value with its type representation \ensuremath{\Conid{TypeRep}} in a data type called \ensuremath{\TConId{Dynamic}}. A \ensuremath{\TConId{Dynamic}} supports type safe projection of its contained value by comparing its \ensuremath{\Conid{TypeRep}} against an expected \ensuremath{\Conid{TypeRep}}. The difficulty lies in constructing a (\ensuremath{\Conid{TypeRep}}) for a given \js value. There are two design alternatives: delegate the task to the runtime system or perform the mapping inside Haskell. The first approach leaks knowledge of data type compilation into the RTS thereby complicating it. The second, does not, but requires a larger family of type checking functions from the RTS to build up the \ensuremath{\Conid{TypeRep}} in Haskell.

Both design alternatives deserve further exploration, but we leave this as future work and for now resort to a much simpler approach. We simply extend the RTS with a family of type checking functions that given a value return either true or false dependent on whether the value's type matches the expected type. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isNull},\Varid{isUndefined},\Varid{isBool},\Varid{isString},{}\<[E]%
\\
\>[B]{}\Varid{isChar},\Varid{isInt},\Varid{isDouble},\Varid{isFloat},\Varid{isNumber},\Varid{isObject},\Varid{isFunction}\ConSym{::}\Varid{a}\to \TConId{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type checking functions are implemented in terms of \emph{typeof}, which given a value returns a string describing its type. Here are the implementations of \ensuremath{\Varid{isFunction}} and \ensuremath{\Varid{isBool}}:

\begin{multicols}{2}
  \begin{tabbing}\tt
~~~primIsFunction~\char61{}~function\char40{}a\char41{}~\char123{}\\
\tt ~~~~~return~PrimMkBool\char40{}\\
\tt ~~~~~~~typeof~a~\char61{}\char61{}\char61{}~\char34{}function\char34{}\\
\tt ~~~~~\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~\\
\tt ~~~primIsBool~\char61{}~function\char40{}a\char41{}~\char123{}\\
\tt ~~~~~return~PrimMkBool\char40{}\\
\tt ~~~~~~~~~~typeof~a~\char61{}\char61{}\char61{}~\char34{}boolean\char34{}~\\
\tt ~~~~~~~\char124{}\char124{}~\char95{}primIsA\char40{}a\char44{}~Boolean\char41{}\\
\tt ~~~~~\char41{}\char59{}\\
\tt ~~~\char125{}
\end{tabbing}
  \vfill
  \columnbreak
  \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 primIsBool(\%*)\char34}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{isBool}\ConSym{::}\Varid{a}\to \TConId{Bool}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 primIsFunction(\%*)\char34}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{isFunction}\ConSym{::}\Varid{a}\to \TConId{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

The implementation reflects our decision to treat primitive and wrapper types as one and the same. We use \emph{PrimMkBool} to directly create values of the Haskell type \ensuremath{\TConId{Bool}}. It embodies knowledge about how the compiler represents data types; like many other functions defined in the RTS. The \emph{primIsA} function checks whether an object is exactly of some type by inspecting its constructor value.

\begin{tabbing}\tt
~\char95{}primIsA~\char61{}~function\char40{}a\char44{}~b\char41{}~\char123{}\\
\tt ~~~if\char40{}typeof~a~\char61{}\char61{}\char61{}~\char34{}object\char34{}~\char38{}\char38{}~a~\char33{}\char61{}\char61{}~null~\char38{}\char38{}~typeof~b~\char61{}\char61{}\char61{}~\char34{}function\char34{}\char41{}~\char123{}\\
\tt ~~~~~return~a\char46{}constructor~\char61{}\char61{}~b\char59{}\\
\tt ~~~\char125{}\\
\tt ~~~return~false\char59{}\\
\tt ~\char125{}
\end{tabbing}

To transitively test whether an object is of particular type we implement another function in terms of \emph{instanceof}:

\begin{tabbing}\tt
~primIsInstanceOf~\char61{}~function\char40{}a\char44{}~b\char41{}~\char123{}\\
\tt ~~~if\char40{}typeof~a~\char61{}\char61{}\char61{}~\char34{}object\char34{}~\char38{}\char38{}~typeof~b~\char61{}\char61{}\char61{}~\char34{}function\char34{}\char41{}~\char123{}\\
\tt ~~~~~return~PrimMkBool\char40{}a~instanceof~b\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~~~return~PrimMkBool\char40{}false\char41{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

\pagebreak

Using \emph{primIsInstanceOf} we can implement the \emph{cast} function we mentioned earlier on which guards the type conversion with a type check.

\begin{multicols}{2}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{JSCtor}\;\Varid{a}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jsCtor}\ConSym{::}\Varid{a}\to \Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cast}\ConSym{::}\Conid{JSCtor}\;\Varid{b}\Rightarrow \Varid{a}\to \TConId{Maybe}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{cast}\;\Varid{a}\ConSym{::}\TConId{Maybe}\;\Varid{b}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{if}\;\Varid{instanceOf}\;\Varid{a}\;(\Varid{jsCtor}\;(\bot \ConSym{::}\Varid{b})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Keyword{then}\;\Conid{Just}\;(\Varid{unsafeCoerce}\;\Varid{a}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Keyword{else}\;\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\vfill
\columnbreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 primInstanceOf(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{instanceOf}\ConSym{::}\Varid{a}\to \Varid{b}\to \TConId{Bool}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{JSCtor}\;(\Conid{HTMLDivElement}\;())\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jsObjectConstructor}\;\anonymous \mathrel{=}\Varid{htmlDivelementType}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 HTMLDivElement\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{htmlDivelementType}\ConSym{::}\Conid{HTMLDivElement}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

With \ensuremath{\Varid{cast}} we can define a function \ensuremath{\Varid{createDivElement}} for creating \emph{HTMLDivElement}s in terms of \ensuremath{\Varid{createElement}}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{createDivElement}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{e}\leftarrow \Varid{createElement}\;\Varid{divString}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{case}\;\Varid{cast}\;\Varid{e}\ConSym{::}\TConId{Maybe}\;(\Conid{HTMLDivElement}\;())\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Just}\;\Varid{x}{}\<[14]%
\>[14]{}\to \Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Nothing}{}\<[14]%
\>[14]{}\to \Varid{error}\;\Char{\char34 Something~went~wrong\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Representing union types}
\label{chap:ffi:uniontypes}

Many \js functions take/return an union of types, best illustrated by an example:

\begin{tabbing}\tt
~function~foo\char40{}b\char41{}~\char123{}\\
\tt ~~~if\char40{}b\char41{}~\char123{}\\
\tt ~~~~~return~\char34{}an\char34{}\char59{}~~~~\char40{}1\char41{}\\
\tt ~~~\char125{}~else~\char123{}\\
\tt ~~~~~return~false\char59{}~~~\char40{}2\char41{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}

The if statement works for any type by coercing its argument to a value of type \emph{boolean}. Dependent on which branch is taken the result of \emph{foo} will either be of type \emph{string} (1) or \emph{boolean} (2). Keeping up the spirit of providing type annotation \emph{foo}'s type can be best described by: 

\begin{tabbing}\tt
~foo~\char58{}\char58{}~a~\char45{}\char62{}~JSBool~\char43{}~JSString
\end{tabbing}

where it takes any type to an union containing either a \ensuremath{\Conid{JSBool}} or \ensuremath{\Conid{JSString}}. The question is: how do we effectively represent a union of types in Haskell? In the following section we will discuss three different approaches: hand-made universes, dynamics, and extensible sums. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 foo\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 foo}\ConSym{::}\Varid{a}\to \VarSym{?}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection{Hand-made universes}

The standard Haskell library comes with the \ensuremath{\TConId{Either}\;\Varid{a}\;\Varid{b}} data type with which we can represent a binary union.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\TConId{Either}\;\Varid{a}\;\Varid{b}\mathrel{=}L\;\Varid{a}\mid R\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can use \ensuremath{\TConId{Either}} to wrap \ensuremath{\Varid{\char95 foo}}, scrutinize the return value using a type check, and associate it with either a \ensuremath{L} or \ensuremath{R} tag. The use of \ensuremath{\Varid{unsafeCoerce}} is unavoidable because we gain knowledge about the types \emph{at runtime} that cannot be legitimized at compile-time. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{foo}\ConSym{::}\Varid{a}\to \TConId{Either}\;\Conid{JSString}\;\Conid{JSBool}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{let}\;\Varid{ret}\;\Varid{r}{}\<[15]%
\>[15]{}\mid \Varid{isString}\;{}\<[27]%
\>[27]{}\Varid{r}{}\<[30]%
\>[30]{}\mathrel{=}L\;{}\<[39]%
\>[39]{}(\Varid{unsafeCoerce}\;\Varid{r}){}\<[E]%
\\
\>[15]{}\mid \Varid{isBool}\;{}\<[27]%
\>[27]{}\Varid{r}{}\<[30]%
\>[30]{}\mathrel{=}R\;{}\<[39]%
\>[39]{}(\Varid{unsafeCoerce}\;\Varid{r}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{in}\;\Varid{ret}\;(\Varid{\char95 foo}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 foo(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{\char95 foo}\ConSym{::}\Varid{a}\to \Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Even though the above encoding works fine it does not generalize nicely to n-ary union types. Especially the manual injection and projection of nested \ensuremath{\TConId{Either}} data types quickly becomes cumbersome. 

\subsubsection{Dynamics}

Using the \ensuremath{\Conid{Data}.\TConId{Dynamic}} library we can hide values of different types in a single value of type \ensuremath{\TConId{Dynamic}}. To make the running example a bit more interesting we cook up a new function with a slightly more complicated type (implementation is not important):

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bar}\ConSym{::}\Conid{JSNull}\VarSym{+}\TConId{Int}\to \Conid{JSBool}\VarSym{+}\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The argument and result type of \ensuremath{\Varid{bar}} collapse into a \ensuremath{\TConId{Dynamic}} type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bar}\ConSym{::}\TConId{Dynamic}\to \TConId{Dynamic}{}\<[E]%
\\
\>[B]{}\Varid{bar}\;\Varid{d}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Keyword{let}\;\Varid{jsVal}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Keyword{case}\;\Varid{fromDynamic}\;\Varid{d}\ConSym{::}\TConId{Maybe}\;\Conid{JSNull}\;\Keyword{of}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{Just}\;\Varid{v}{}\<[22]%
\>[22]{}\to \Varid{unsafeCoerce}\;\Varid{v}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Conid{Nothing}{}\<[22]%
\>[22]{}\to \Keyword{case}\;{}\<[31]%
\>[31]{}\Varid{fromDynamic}\;\Varid{d}\ConSym{::}\TConId{Maybe}\;\TConId{Int}\;\Keyword{of}{}\<[E]%
\\
\>[31]{}\Conid{Just}\;\Varid{v}{}\<[41]%
\>[41]{}\to \Varid{unsafeCoerce}\;\Varid{v}{}\<[E]%
\\
\>[31]{}\Conid{Nothing}{}\<[41]%
\>[41]{}\to \Varid{error}\;\Char{\char34 impossible\char34}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{ret}\;\Varid{r}{}\<[16]%
\>[16]{}\mid {}\<[16E]%
\>[19]{}\Varid{isString}\;{}\<[29]%
\>[29]{}\Varid{r}{}\<[32]%
\>[32]{}\mathrel{=}\Varid{toDyn}\;(\Varid{unsafeCoerce}\;\Varid{r}\ConSym{::}\Conid{JSString}){}\<[E]%
\\
\>[16]{}\mid {}\<[16E]%
\>[19]{}\Varid{isBool}\;{}\<[29]%
\>[29]{}\Varid{r}{}\<[32]%
\>[32]{}\mathrel{=}\Varid{toDyn}\;(\Varid{unsafeCoerce}\;\Varid{r}\ConSym{::}\Conid{JSBool}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Keyword{in}\;\Varid{ret}\;(\Varid{\char95 bar}\;\Varid{jsVal}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 bar(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{\char95 bar}\ConSym{::}\Varid{a}\to \Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To invoke \ensuremath{\Varid{bar}} we pre- and suffix it with dynamic unwrapping and wrapping calls. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\Varid{fromDynamic}\hsdot{\circ }{.}\Varid{bar}\hsdot{\circ }{.}\Varid{toDyn})\;\Varid{\char95 null}\ConSym{::}\TConId{Maybe}\;\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Unfortunately, the projection (\ensuremath{\Varid{fromDynamic}}) and injection (\ensuremath{\Varid{toDyn}}) functions only work on monomorphic types that are instances of \ensuremath{\TClassId{Typeable}}. Because \ensuremath{\Varid{\char95 bar}} does not care about the type of its argument we can freely use \ensuremath{\Varid{unsafeCoerce}} as an escape hatch making the type system forget that it actually knows the type of \ensuremath{\Varid{v}}. In the result position we can use the same trick to let the type system learn about the new types.

Using dynamics is significantly simpler when dealing with n-ary union types compared to hand-made universes. However, there are several shortcomings:
\begin{itemize}
  \item limited to injecting and projecting monomorphic types;
  \item the \ensuremath{\TConId{Dynamic}} type has no descriptive value.
\end{itemize} 

Unfortunately, the fact that dynamics are limited to monomorphic types does not align well with our encoding of objects. Suppose we have a function with type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{getNodeType}\ConSym{::}\Conid{Node}\;\Varid{a}\VarSym{+}\Conid{JSNull}\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A value of type \ensuremath{\Conid{Node}\;\Varid{a}} cannot be injected into a \ensuremath{\TConId{Dynamic}}. What we can do is temporarily make the type monomorph by flagging the type parameter position with a special data type.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{TyVar}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{deriving}\;\TClassId{Typeable}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using a pair of injection and projection functions we can turn a polymorphic into a monomorpic type and the other way around.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prjNode}\ConSym{::}\TConId{Dynamic}\to \exists \Varid{a}\hsexists \hsdot{\circ }{.}\TConId{Maybe}\;(\Conid{Node}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{prjNode}\mathrel{=}\Varid{unsafeCoerce}\hsdot{\circ }{.}(\Varid{fromDynamic}\ConSym{::}\TConId{Dynamic}\to \TConId{Maybe}\;(\Conid{Node}\;\Conid{TyVar})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{injNode}\ConSym{::}\Conid{Node}\;\Varid{a}\to \TConId{Dynamic}{}\<[E]%
\\
\>[B]{}\Varid{injNode}\mathrel{=}\Varid{toDyn}\hsdot{\circ }{.}(\Varid{unsafeCoerce}\ConSym{::}\Conid{Node}\;\Varid{a}\to \Conid{Node}\;\Conid{TyVar}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{prjNode}} function returns a value of type \ensuremath{\TConId{Maybe}\;(\Conid{Node}\;\Varid{a})} where the type variable \ensuremath{\Varid{a}} is existentially quantified over preventing the caller from instantiating it to anything other than a polymorphic type variable. 
Unfortunately, the function pair is type specific, and we would like to abstract from the specifics using a type class:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{Iso}\;\Varid{f}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inj}\ConSym{::}\Varid{f}\;\Varid{a}\to \TConId{Dynamic}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\ConSym{::}\TConId{Dynamic}\to \exists \Varid{a}\hsexists \hsdot{\circ }{.}\TConId{Maybe}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, it turns out that this does not help much as the nested types cannot be directly used to create instances of \ensuremath{\Conid{Iso}} for. First, they need to be wrapped inside a newtype such that they can be partially applied.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}c<{\hspost}@{}}%
\column{45E}{@{}l@{}}%
\column{49}{@{}>{\hspre}l<{\hspost}@{}}%
\column{62}{@{}>{\hspre}c<{\hspost}@{}}%
\column{62E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{newtype}\;\Conid{One}\;{}\<[16]%
\>[16]{}\Varid{a}\;\Varid{x}{}\<[25]%
\>[25]{}\mathrel{=}\Conid{One}\;{}\<[34]%
\>[34]{}\{\mskip1.5mu \Varid{unOne}{}\<[45]%
\>[45]{}\ConSym{::}{}\<[45E]%
\>[49]{}\Varid{a}\;\Varid{x}{}\<[62]%
\>[62]{}\mskip1.5mu\}{}\<[62E]%
\\
\>[B]{}\Keyword{newtype}\;\Conid{Two}\;{}\<[16]%
\>[16]{}\Varid{a}\;\Varid{b}\;\Varid{x}{}\<[25]%
\>[25]{}\mathrel{=}\Conid{Two}\;{}\<[34]%
\>[34]{}\{\mskip1.5mu \Varid{unTwo}{}\<[45]%
\>[45]{}\ConSym{::}{}\<[45E]%
\>[49]{}\Varid{a}\;(\Varid{b}\;\Varid{x}){}\<[62]%
\>[62]{}\mskip1.5mu\}{}\<[62E]%
\\
\>[B]{}\Keyword{newtype}\;\Conid{Three}\;{}\<[16]%
\>[16]{}\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{x}{}\<[25]%
\>[25]{}\mathrel{=}\Conid{Three}\;{}\<[34]%
\>[34]{}\{\mskip1.5mu \Varid{unThree}{}\<[45]%
\>[45]{}\ConSym{::}{}\<[45E]%
\>[49]{}\Varid{a}\;(\Varid{b}\;(\Varid{c}\;\Varid{x})){}\<[62]%
\>[62]{}\mskip1.5mu\}{}\<[62E]%
\\
\>[B]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The programmer still needs to manually inject and project its type in and out of a member of the newtype family, nothing is gained in terms of usability. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;(\Conid{Typeable1}\;\Varid{a},\Conid{Typeable1}\;\Varid{b})\Rightarrow \Conid{Iso}\;(\Conid{Two}\;\Varid{a}\;\Varid{b})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{inj}{}\<[11]%
\>[11]{}\mathrel{=}\Varid{toDyn}\hsdot{\circ }{.}(\Varid{unsafeCoerce}\ConSym{::}\Varid{a}\;(\Varid{b}\;\Varid{x})\to \Varid{a}\;(\Varid{b}\;\Conid{TyVar}))\hsdot{\circ }{.}\Varid{unTwo}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{prj}\;\Varid{d}{}\<[11]%
\>[11]{}\mathrel{=}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Keyword{case}\;\Varid{fromDynamic}\;\Varid{d}\ConSym{::}\TConId{Maybe}\;(\Varid{a}\;(\Varid{b}\;\Conid{TyVar}))\;\Keyword{of}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Nothing}{}\<[16]%
\>[16]{}\to \Conid{Nothing}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Conid{Just}\;\Varid{x}{}\<[16]%
\>[16]{}\to \Conid{Just}\;(\Conid{Two}\mathbin{\$}\Varid{unsafeCoerce}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection{Extensible unions}

Using type classes binary unions can be generalized to n-ary union types with automatic injection and projection functions \cite{modularintrp,alacarte}. The trick is to rely on a right-associative nesting of types, and let type class instances generically traverse the type structure to either inject or project a type. First, we define a binary union:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Varid{a} + \Varid{b}{}\<[15]%
\>[15]{}\mathrel{=}\Conid{L}\;\Varid{a}\mid \Conid{R}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Keyword{infixr}\;\Numeral{5} + {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using nested constructor applications of this data type we can write, e.g., a ternary union:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{R}\;(\Conid{R}\;\Conid{True})\ConSym{::}\TConId{Int} + \TConId{String} + \TConId{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The injection and projection functions of the \ensuremath{\Conid{SubType}} type class automatically find value level injections and projections for values of type \ensuremath{ + }. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{SubType}\;\Varid{sub}\;\Varid{sup}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{inj}{}\<[9]%
\>[9]{}\ConSym{::}\Varid{sub}\to \Varid{sup}{}\<[32]%
\>[32]{}\Comment{  -{}-\enskip  injection}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{prj}{}\<[9]%
\>[9]{}\ConSym{::}\Varid{sup}\to \TConId{Maybe}\;\Varid{sub}{}\<[32]%
\>[32]{}\Comment{  -{}-\enskip  projection}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The implementation of \ensuremath{\Varid{inj}} and \ensuremath{\Varid{prj}} is covered by the following instances:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\Conid{SubType}\;\Varid{a}\;\Varid{a}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inj}\mathrel{=}\Varid{id}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\mathrel{=}\Conid{Just}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{SubType}\;\Varid{a}\;(\Varid{a} + \Varid{b})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inj}{}\<[14]%
\>[14]{}\mathrel{=}\Conid{L}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\;(\Conid{L}\;\Varid{x}){}\<[14]%
\>[14]{}\mathrel{=}\Conid{Just}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\;\anonymous {}\<[14]%
\>[14]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\Conid{SubType}\;\Varid{a}\;\Varid{c})\Rightarrow \Conid{SubType}\;\Varid{a}\;(\Varid{b} + \Varid{c})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{inj}{}\<[14]%
\>[14]{}\mathrel{=}\Conid{R}\hsdot{\circ }{.}\Varid{inj}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\;(\Conid{R}\;\Varid{x}){}\<[14]%
\>[14]{}\mathrel{=}\Varid{prj}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{prj}\;\anonymous {}\<[14]%
\>[14]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first instance states that \ensuremath{\Conid{SubType}} is reflexive. The second instance states for injection that if we have a value of type \ensuremath{\Varid{a}} we can inject it into \ensuremath{\Varid{a} + \Varid{b}}, and for projection that provided with a value of type \ensuremath{\Varid{a} + \Varid{b}} we can project out its value if it matches \ensuremath{\Conid{L}}. The third instance asserts for injection that provided we can inject a value of type \ensuremath{\Varid{a}} into \ensuremath{\Varid{c}} we can also inject \ensuremath{\Varid{a}} into a larger type \ensuremath{\Varid{b} + \Varid{c}} by composing the first injection with an additional \ensuremath{\Conid{R}}, and for projection that provided we can project \ensuremath{\Varid{a}} out of \ensuremath{\Varid{c}} we can also project out \ensuremath{\Varid{a}} from a larger type \ensuremath{\Varid{b} + \Varid{c}} if its value matches \ensuremath{\Conid{R}}.

Using extensible unions we may rewrite \ensuremath{\Varid{bar}} such that its type becomes much more informative compared to the dynamics approach.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bar}\ConSym{::}\Conid{JSNull} + \TConId{Int}\to \Conid{JSString} + \Conid{JSBool}{}\<[E]%
\\
\>[B]{}\Varid{bar}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{let}\;\Varid{jsVal}\mathrel{=}{}\<[E]%
\\
\>[4]{}\hsindent{6}{}\<[10]%
\>[10]{}\Keyword{case}\;\Varid{prj}\;\Varid{a}\ConSym{::}\TConId{Maybe}\;\Conid{JSNull}\;\Keyword{of}{}\<[E]%
\\
\>[10]{}\hsindent{1}{}\<[11]%
\>[11]{}\Conid{Just}\;\Varid{v}{}\<[20]%
\>[20]{}\to \Varid{unsafeCoerce}\;\Varid{v}{}\<[E]%
\\
\>[10]{}\hsindent{1}{}\<[11]%
\>[11]{}\Conid{Nothing}{}\<[20]%
\>[20]{}\to {}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Keyword{case}\;\Varid{prj}\;\Varid{a}\ConSym{::}\TConId{Maybe}\;\TConId{Int}\;\Keyword{of}{}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{Just}\;\Varid{v}{}\<[24]%
\>[24]{}\to \Varid{unsafeCoerce}\;\Varid{v}{}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{Nothing}{}\<[24]%
\>[24]{}\to \Varid{error}\;\Char{\char34 impossible\char34}{}\<[E]%
\\[\blanklineskip]%
\>[4]{}\hsindent{4}{}\<[8]%
\>[8]{}\Varid{ret}\;\Varid{r}{}\<[15]%
\>[15]{}\mid {}\<[18]%
\>[18]{}\Varid{isString}\;{}\<[28]%
\>[28]{}\Varid{r}\mathrel{=}\Varid{inj}\;(\Varid{unsafeCoerce}\;\Varid{r}\ConSym{::}\Conid{JSString}){}\<[E]%
\\
\>[15]{}\mid {}\<[18]%
\>[18]{}\Varid{isBool}\;{}\<[28]%
\>[28]{}\Varid{r}\mathrel{=}\Varid{inj}\;(\Varid{unsafeCoerce}\;\Varid{r}\ConSym{::}\Conid{JSBool}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{in}\;\Varid{ret}\;(\Varid{\char95 bar}\;\Varid{jsVal}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Similar to the dynamics approach a call to \ensuremath{\Varid{bar}} should be wrapped with projection and injection functions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\Varid{prj}\hsdot{\circ }{.}\Varid{bar}\hsdot{\circ }{.}\Varid{inj})\;\Varid{\char95 null}\ConSym{::}\TConId{Maybe}\;\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It gets interesting if union types also contain polymorphic types:

\ensuremath{\Varid{getNodeType}\ConSym{::}\Conid{Node}\;\Varid{a} + \Conid{JSNull}\to \TConId{IO}\;\TConId{Int}}

Suppose we want to call \ensuremath{\Varid{getNodeType}} with a value of a type that unifies with \ensuremath{\Conid{Node}\;\Varid{a}}. Injecting this value into the argument type is going to fail, unless we provide a type annotation which instantiates the type variable to a concrete type matching the given type. For example, we could apply \ensuremath{\Varid{getNodeType}} to a HTMLElement as follows:

\ensuremath{\Varid{getNodeType}\;(\Varid{inj}\;(\bot \ConSym{::}\Conid{HTMLElement}\;())\ConSym{::}\Conid{HTMLElement}\;() + \Conid{JSNull})}

We can even inject a polymorphic value of type \ensuremath{\Conid{Node}\;\Varid{a}} given that we provide type annotations, and use scoped type variables to ensure that identically named type variables are considered the same. The same rules hold for projection.

\ensuremath{\Varid{getNodeType}\;(\Varid{inj}\;(\bot \ConSym{::}\Conid{Node}\;\Varid{a})\ConSym{::}\Conid{Node}\;\Varid{a} + \Conid{JSNull})}

Of the three alternatives this one is the clear winner. It requires less boilerplate compared to the first approach, and provides more informative types than the second. Also, it is more flexible than dynamics as it naturally allows polymorphic types inside a union type as long as they do not overlap.  

\section{Marshalling}
\label{sec:marshalling}

Aggregate Haskell types do not map directly onto \js types. The difference in data representation calls for conversions functions between Haskell data, and their \js equivalent. There are cases where such a mapping is obvious, e.g. a \ensuremath{\TConId{Bool}} simply maps to the \js boolean type. However, there are also cases where such a mapping is less obvious, e.g. in the case of \ensuremath{\TConId{Maybe}\;\Varid{a}}. To express the mapping between Haskell values, \js values, and \emph{vice versa} we imagine two mapping functions \ensuremath{\Varid{haskToJS}} and \ensuremath{\Varid{jsToHask}} for some of the standard Haskell types:

\begin{multicols}{2}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{haskToJS}\ConSym{::}\Conid{Haskell}\to \Conid{JS}{}\<[E]%
\\
\>[B]{}\Varid{haskToJS}\;(){}\<[21]%
\>[21]{}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{haskToJS}\;\Conid{True}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{true}{}\<[E]%
\\
\>[B]{}\Varid{haskToJS}\;\Conid{False}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{false}{}\<[E]%
\\
\>[B]{}\Varid{haskToJS}\;\Char{\char34 \char34}{}\<[21]%
\>[21]{}\mathrel{=}\Char{\char34 \char34}{}\<[E]%
\\
\>[B]{}\Varid{haskToJS}\;\Conid{Nothing}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{null}{}\<[E]%
\\
\>[B]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\vfill
\columnbreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{jsToHask}\ConSym{::}\Conid{JS}\to \Conid{Haskell}{}\<[E]%
\\
\>[B]{}\Varid{jsToHask}\;\bot {}\<[21]%
\>[21]{}\mathrel{=}(){}\<[E]%
\\
\>[B]{}\Varid{jsToHask}\;\Varid{true}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\Varid{jsToHask}\;\Varid{false}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\Varid{jsToHask}\;\Char{\char34 \char34}{}\<[21]%
\>[21]{}\mathrel{=}\Char{\char34 \char34}{}\<[E]%
\\
\>[B]{}\Varid{jsToHask}\;\Varid{null}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\\
\>[B]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

Besides the obvious mappings there are also a few interesting ones. In particular, unit (\ensuremath{()}) which is most often used as a dummy value for expressing that a function returns no meaningful result, hence it maps naturally to the \js \emph{undefined} value returned when a function has no result. Also, \ensuremath{\Conid{Nothing}} which we could have mapped to undefined, but did not because there is a subtle difference between undefined and null. An undefined value is most often used in cases where something really is undefined, e.g. when accessing a non-existent object property, whereas null can be used by the programmer to explicitly state that something is not defined very much like \ensuremath{\Conid{Nothing}}. 

Because both mappings are only defined for of few standard Haskell types, and they both range over a set of types in their argument as well as in their result type, we model them using a type class:

\begin{multicols}{2}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{ToJS}\;\Varid{a}\;\Varid{b}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{toJS}\ConSym{::}\Varid{a}\to \Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\vfill
\columnbreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{FromJS}\;\Varid{a}\;\Varid{b}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{fromJS}\ConSym{::}\Varid{a}\to \TConId{Maybe}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

Although for the standard types there exist a bidirectional mapping this may not always be to case for very instance of either class, which is why we use separate type classes. Also, because converting from a \js value to a Haskell value may go wrong the \ensuremath{\Varid{fromJS}} function is partial.

For booleans the implementation is straight-forward.

\begin{multicols}{2}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\Conid{ToJS}\;\TConId{Bool}\;\Conid{JSBool}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{toJS}\;\Conid{True}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{jsTrue}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{toJS}\;\Conid{False}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{jsFalse}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 true\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jsTrue}{}\<[11]%
\>[11]{}\ConSym{::}\Conid{JSBool}{}\<[E]%
\\
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 false\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{jsFalse}\ConSym{::}\Conid{JSBool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\vfill
\columnbreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\Conid{FromJS}\;\Conid{JSBool}\;\TConId{Bool}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{fromJS}\;\Varid{v}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Keyword{if}\;\Varid{isBool}\;\Varid{v}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Keyword{then}\;\Keyword{if}\;\Varid{jsEq}\;\Varid{jsTrue}\;\Varid{v}{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Keyword{then}\;\Conid{Just}\;\Conid{True}{}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Keyword{else}\;\Conid{Just}\;\Conid{False}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Keyword{else}\;\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

The \ensuremath{\Varid{jsEq}} function is a wrapper around the \js strict equality operator. Every time a \ensuremath{\Conid{JSBool}} is converted to a \ensuremath{\TConId{Bool}} some type checking is performed. For booleans this conversion is relatively inexpensive, but for list-like structures this can become much more expensive. Hence, in the future compiler support for other strings representations (using overloaded strings) is unavoidable in order to gain performance. For now the conversion of Haskell to \js strings takes linear time in the length of the string. 

Until now we have only considered simple Haskell types, but when interfacing to \js libraries it is very useful to be able to convert a Haskell record to plain \js object. The authors of \cite{jcu} posited some design alternatives, and decided on a solution where with the help of the RTS a record can be converted to a \js object by forcing its components WHNF. The functionality is exposed through the FFI using the "\{\}" notation.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{JSBook\char95 }{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{JSBook}\mathrel{=}\Conid{JSObject\char95 }\;\Conid{JSBook\char95 }{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \char123 \char125 \char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mkJSBook}\ConSym{::}\Conid{Book}\to \TConId{IO}\;\Conid{JSBook}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{Book}\mathrel{=}\Conid{Book}\;\{\mskip1.5mu \Varid{author}\ConSym{::}\Conid{JSString},\Varid{title}\ConSym{::}\Conid{JSString},\Varid{pages}\ConSym{::}\TConId{Int}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{book}\mathrel{=}\Varid{mkJSBook}\;(\Conid{Book}\;\{\mskip1.5mu \Varid{author}\mathrel{=}\Varid{toJS}\;\Char{\char34 me\char34},\Varid{title}\mathrel{=}\Varid{toJS}\;\Char{\char34 story\char34},\Varid{pages}\mathrel{=}\Numeral{123}\mskip1.5mu\}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The result of applying \ensuremath{\Varid{mkJSBook}} to a \ensuremath{\Conid{Book}} value is a simple \js object:

\begin{tabbing}\tt
~\char123{}author~\char58{}~\char34{}me\char34{}\char44{}~title~\char58{}~\char34{}story\char34{}\char44{}~pages~\char58{}~123\char125{}
\end{tabbing}

The opposite conversion is left for the programmer to implement.

\section{JavaScript Idioms}
\label{sec:jsidioms}

In this section we will explore how the \js FFI can be used to deal with common \js idioms.

\subsection{Instantiating objects}

In \js objects are instantiated using the \emph{new} keyword. Its absence in the former incarnation of the \js FFI has led us to consider lifting it into a primitive function.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 primNew('B',~\%1,~\%2)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{newB}\ConSym{::}\Varid{a}\to \Varid{b}\to \TConId{IO}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~function~primNew\char40{}obj\char41{}~\char123{}\\
\tt ~~~var~args~\char61{}~Array\char46{}prototype\char46{}slice\char46{}call\char40{}arguments\char41{}\char59{}~\\
\tt ~~~args\char46{}shift\char40{}\char41{}\char59{}~\\
\tt ~~~var~l~\char61{}~arg\char46{}length\char59{}\\
\tt ~~~switch\char40{}l\char41{}~\char123{}\\
\tt ~~~~~case~0\char58{}~return~new~obj\char59{}\\
\tt ~~~~~case~1\char58{}~return~new~obj\char40{}args\char91{}0\char93{}\char41{}\char59{}\\
\tt ~~~~~case~2\char58{}~return~new~obj\char40{}args\char91{}0\char93{}\char44{}~args\char91{}1\char93{}\char41{}\char59{}\\
\tt ~~~~~case~3\char58{}~return~new~obj\char40{}args\char91{}0\char93{}\char44{}~args\char91{}1\char93{}\char44{}~args\char91{}2\char93{}\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~~~throw~new~Error\char40{}\char39{}Too~many~arguments\char44{}~not~supported\char46{}\char39{}\char41{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

Unfortunately, the lifted version does not scale to an arbitrary number of constructor arguments. There are other solutions such as implementing it as a method on the Function object, suggested in \cite{crockford2008javascript}. However, since its part of the language we simply choose to expand the \js FFI. Its usage is no different from that in \js:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 new~String(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{newString}\ConSym{::}\Conid{JSString}\to \TConId{IO}\;\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Higher-order call}

\js functions can be passed as arguments to other functions. If we want to pass a Haskell function to a higher-order \js function we must first wrap it as a \js function. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 twice(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 twice}\ConSym{::}\Conid{JSFunction\char95 }\;(\TConId{IO}\;())\to \TConId{IO}\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 wrapper\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 twice\char95 hof}\ConSym{::}\TConId{IO}\;()\to \Conid{JSFunction\char95 }\;(\TConId{IO}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{twice}\ConSym{::}\TConId{IO}\;()\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{twice}\mathrel{=}\Varid{\char95 twice}\hsdot{\circ }{.}\Varid{\char95 twice\char95 hof}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~function~twice\char40{}f\char41{}~\char123{}\\
\tt ~~~f\char40{}\char41{}\char59{}\\
\tt ~~~f\char40{}\char41{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

The \ensuremath{\Conid{JSFunction\char95 }} type can be seen as a small box wrapped around the original Haskell function, which can be used by regular \js code as if it were a normal function. However, internally the Haskell calling convention is maintained, and when it returns back into the \js world its return value is evaluated to WHNF. 

It is not uncommon for \js functions to return a function, the \ensuremath{\Varid{createCounter}} is an example of such a function. When invoked it returns a new function that at every call increments a variable and returns it.

\begin{tabbing}\tt
~function~createCounter\char40{}\char41{}~\char123{}\\
\tt ~~~var~i~\char61{}~0\char59{}\\
\tt ~~~return~function\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~i\char43{}\char43{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}

We can import \emph{createCounter} just like any other function, except that when we invoke it we use the dual of "wrapper", called "dynamic", which takes a \js function and returns a Haskell function wrapping the \js function.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 createCounter()\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{createCounter}\ConSym{::}\TConId{IO}\;(\Conid{JSFunction}\;(\TConId{IO}\;\TConId{Int})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 dynamic\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{mkCountFunc}\ConSym{::}\Conid{JSFunction}\;(\TConId{IO}\;\TConId{Int})\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


We can now use \ensuremath{\Varid{createCounter}} to create a counter function, which we use to print incrementing numbers to the screen.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{main}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{counter}\leftarrow \Varid{createCounter}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{count}\mathrel{=}\Varid{mkCountFunc}\;\Varid{counter}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mapM\char95 }\;(\lambda \Varid{m}\to \Varid{m}\rightarrowtail \Varid{print})\;[\mskip1.5mu \Varid{count},\Varid{count},\Varid{count}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection{Exporting Haskell functions}

When integrating with existing code it is useful to be able to call Haskell functionality from \js. The FFI \emph{export} directive provides such functionality by exporting a Haskell function under a stable name. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{minus}\ConSym{::}\TConId{Int}\to \TConId{Int}\to \TConId{Int}{}\<[E]%
\\
\>[B]{}\Varid{minus}\;\Varid{x}\;\Varid{y}\mathrel{=}\Varid{x}\VarSym{-}\Varid{y}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Varid{export}\;\Keyword{js}\;\Char{\char34 minus\char34}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{minus}\ConSym{::}\TConId{Int}\to \TConId{Int}\to \TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The compiler generates a wrapper around the \ensuremath{\Varid{minus}} function, and it can be called using the name given to it in the export declaration prefixed with the module name.

\subsection{Behavior of this}

In \js the \emph{this} keyword has a rather peculiar semantics different from many other OO like languages. It is different in that it is dynamic, i.e. it adapts to whatever object it is called through. This, in combination with higher-order functions, can cause problems with what \emph{this} is expected to refer to inside the body of a wrapped function. 

For example, in jQuery\footnote{\url{http://www.jquery.com}}, when an event handler is triggered jQuery executes the handler with \emph{this} set to the event source. The problem is that we do not have access to \emph{this}, and because our Haskell callback is wrapped by the compiler such that jQuery can execute it as a normal \js function the event source is also lost. There seems to be no general solution to this problem. This solution proposed in \cite{jcu} is to reify \emph{this} as an additional parameter to the callback function using a helper function:

\begin{tabbing}\tt
~function~wrappedThis\char40{}f\char41{}~\char123{}\\
\tt ~~~return~function\char40{}\char41{}~\char123{}\\
\tt ~~~~~var~args~\char61{}~Array\char46{}prototype\char46{}slice\char46{}call\char40{}arguments\char41{}\char59{}\\
\tt ~~~~~args\char46{}unshift\char40{}this\char41{}\char59{}\\
\tt ~~~~~return~f\char46{}apply\char40{}this\char44{}~args\char41{}\char59{}\\
\tt ~~~\char125{}~\\
\tt ~\char125{}
\end{tabbing}

We illustrate how this is done for registering click events:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \%1.click(\%2)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 registerClick}\ConSym{::}\Conid{JQuery}\to \Conid{JSFunction}\;(\Conid{EventSource}\to \TConId{IO}\;())\to \TConId{IO}\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 wrapper\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mkCb}\ConSym{::}(\Conid{EventSource}\to \TConId{IO}\;())\to \TConId{IO}\;(\Conid{JSFunction}\;(\Conid{EventSource}\to \TConId{IO}\;())){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 wrappedThis(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mkWrappedThis}\ConSym{::}\Conid{JSFunction}\;(\Varid{a}\to \TConId{IO}\;())\to \TConId{IO}\;(\Conid{JSFunction}\;(\Varid{a}\to \TConId{IO}\;())){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{registerClick}\ConSym{::}\Conid{JQuery}\to (\Conid{EventSource}\to \TConId{IO}\;())\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{registerClick}\;\Varid{jq}\;\Varid{f}\mathrel{=}\Varid{mkCb}\;\Varid{f}\rightarrowtail \Varid{mkWrappedThis}\rightarrowtail \Varid{\char95 registerClick}\;\Varid{jq}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Optional arguments}

In \js all function arguments are optional by default. When an argument is not provided it simply defaults to \emph{undefined}.

\begin{tabbing}\tt
~function~foo\char40{}x\char44{}~y\char41{}~\char123{}\\
\tt ~~~if\char40{}\char33{}y\char41{}~\char123{}\\
\tt ~~~~~y~\char61{}~0\char59{}~\char47{}\char47{}~default~value\\
\tt ~~~\char125{}\\
\tt ~~~return~x~\char43{}~y\char59{}\\
\tt ~\char125{}\\
\tt ~foo\char40{}3\char41{}\char59{}
\end{tabbing}

The closest correspondence in Haskell to optional arguments is an argument of type \ensuremath{\TConId{Maybe}}, or when there are many options a record with defaults for every selector. The easiest way to deal with \js functions with optional arguments is to import several versions of the same function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 foo(\%1)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{foo1}\ConSym{::}\TConId{Int}\to \TConId{Int}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 foo(\%1,~\%2)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{foo2}\ConSym{::}\TConId{Int}\to \TConId{Int}\to \TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Although this is an easy solution it is far from pretty, and quickly explodes when the number of optional arguments increases. A better option would be to import the function with all of its arguments, and write a wrapper function that uses a \ensuremath{\TConId{Maybe}} for all optional arguments. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 foo(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 foo}\ConSym{::}\TConId{Int}\to \Varid{a}\to \TConId{Int}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{foo}\ConSym{::}\TConId{Int}\to \TConId{Maybe}\;\TConId{Int}\to \TConId{Int}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;\Varid{a}\;\Conid{Nothing}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{\char95 foo}\;\Varid{a}\;\Varid{jsUndefined}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;\Varid{a}\;(\Conid{Just}\;\Varid{x})\mathrel{=}\Varid{\char95 foo}\;\Varid{a}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Global state}

\js is at its core a language with mutable state, i.e. at each statement the value pointed to by a variable may change. The ability to import global state is a practical necessity. In Haskell to goto model for mutable state are IORefs. However, they are meant for modeling mutable references to immutable Haskell values, not references to mutable \js values. We want changes to the global state to immediately reflect in our reads, i.e. in effect two consecutive reads of the same piece of global state may yield entirely different values. 

We create an interface, very similar to that of IORef, for importing mutable \js state. The differences lie in the creation of a mutable reference, and the ability to distinguish between read and read-write references.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Wraps a getter and setter }{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Lens}\;\Varid{a}\mathrel{=}\Conid{Lens}\;(\TConId{IO}\;\Varid{a})\;(\Varid{a}\to \TConId{IO}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  Use a phantom type as flag for read or read and write capabilities}{}\<[E]%
\\
\>[B]{}\Keyword{newtype}\;\Conid{JSRef}\;\Varid{t}\;\Varid{a}\mathrel{=}\Conid{JSRef}\;(\Conid{Lens}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\TClassId{Read}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{ReadWrite}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{newJSRef}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;\Varid{a}\to (\Varid{a}\to \TConId{IO}\;())\to \Conid{JSRef}\;\Conid{ReadWrite}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{newReadOnlyJSRef}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;\Varid{a}\to \Conid{JSRef}\;\TClassId{Read}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{readJSRef}{}\<[19]%
\>[19]{}\ConSym{::}\Conid{JSRef}\;\Varid{t}\;\Varid{a}\to \TConId{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{writeJSRef}{}\<[19]%
\>[19]{}\ConSym{::}\Conid{JSRef}\;\Conid{ReadWrite}\;\Varid{a}\to \Varid{a}\to \TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As a simple example on how \ensuremath{\Conid{JSRef}}s can be used we import a piece of global \js state (x), and an accompanying mutator (mutX).

\begin{multicols}{2}
\begin{tabbing}\tt
~x~\char61{}~0\char59{}\\
\tt ~function~mutX\char40{}\char41{}~\char123{}\\
\tt ~~~~x~\char43{}\char61{}~10\char59{}\\
\tt ~\char125{}
\end{tabbing}
\vfill
\columnbreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 x\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{readVarX}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 mutX()\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{mutX}\ConSym{::}\TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{multicols}

We disallow writes to \emph{x}, and hence create a read-only \ensuremath{\Conid{JSRef}}. The following fragment illustrates how
changes made by the \ensuremath{\Varid{mutX}}, outside the grip of Haskell, are reflected in the value read through \ensuremath{\Varid{readJSRef}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{globSt}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{refX}\leftarrow \Varid{newReadOnlyJSRef}\;\Varid{readVarX}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{x}\leftarrow \Varid{readJSRef}\;\Varid{refX}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{putStr}\;(\Varid{show}\;\Varid{x}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mutX}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{x}\leftarrow \Varid{readJSRef}\;\Varid{refX}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{putStr}\;(\Varid{show}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Conid{JSRef}} interface is not only useful for importing global state, but also for modeling a more Haskell like interface to object properties. Furthermore, using \ensuremath{\Conid{JSRef}} instead of \ensuremath{\Conid{IORef}} for partially applying event handlers with global state solves the problem of having stale values, where the authors of \cite{jcu} struggled with. 

\subsection{Variadic functions}

\js functions can take an arbitrary number of arguments. A typical example of such a function is the string concatenation function \emph{concat} (a pure function). Similar to how we dealt with optional arguments we can import \emph{concat} by importing different versions. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \%1.concat(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{concat1}\ConSym{::}\Conid{JSString}\to \Conid{JSString}\to \Conid{JSString}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \%1.concat(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{concat2}\ConSym{::}\Conid{JSString}\to \Conid{JSString}\to \Conid{JSString}\to \Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, this is a poor choice as it does not truly uphold the semantics of \emph{concat}. A better option would be to use the \js \emph{apply} function. Where \emph{apply} is defined as:

\begin{tabbing}\tt
~fun\char46{}apply\char40{}thisArg\char91{}\char44{}~argsArray\char93{}\char41{}
\end{tabbing}

Its first argument is where \emph{this} is going to point to when \emph{fun} is called, and the second argument is an array with function arguments. Using \text{\tt apply} we can rewrite \ensuremath{\Varid{concat}} such that it works for an arbitrary number of arguments.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 \%1.concat.apply(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 concat}\ConSym{::}\Conid{JSString}\to \Conid{JSString}\to \Conid{JSArray}\;\Conid{JSString}\to \Conid{JSString}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{concat}\ConSym{::}\Conid{JSString}\to \Conid{JSArray}\;\Conid{JSString}\to \Conid{JSString}{}\<[E]%
\\
\>[B]{}\Varid{concat}\;\Varid{x}\;\Varid{xs}\mathrel{=}\Varid{\char95 concat}\;\Varid{x}\;\Varid{x}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

While we think this to be an acceptable encoding it still does not truly encode variadic functions. It has been shown that variadic functions can be simulated in Haskell using type classes\cite{typesafefuncforio, Asai:2009:TDC:1743339.1743382}, but they are not commonly used and we instead stick with the more lightweight approach. 

\section{Linking \js libraries}

Web applications are constructed using a multitude of technologies. They use HTML in combination with CSS to convey rendering information to the browser, and use \js for adding interactivity to an otherwise static rendering of the HTML tree. The technology triad constitutes the corner stone of every web application, which is served to the end-user by means of a HTML document that links all necessary \js and CSS resources together.

In the current UHC pipeline, shown in figure \ref{fig:uhcpipeline}, a Haskell program is compiled down to \js, and linked into a single HTML file together with all its module dependencies, and the RTS. Without optimizations UHC uses a HTML script tag to link each dependency into the HTML file. With whole program linking turned on it links all dependencies into a single file. 

The compilation pipeline delivers a very basic web application. There are, however, many possible configurations to packacke a web application. It need not even be a single binary, but may be spread over several independent units that may be loaded using variety of linking strategies. Furthermore, how a web application is assembled and deployed depends very much on the type of web application. Of all these aspects UHC currently does not address:

\begin{itemize}
  \item external \js dependencies;
  \item inclusion of CSS files;
  \item inclusion of HTML markup;
  \item post-processing.
\end{itemize}

Although it is possible to let UHC deal with all these issues we deem it not wise to do so. The purpose of UHC is to compile Haskell to \js, and the different concerns of assembling, post-processing, and application distribution should be the task of some other software product. In the future UHC should no longer generate a HTML file itself, but produce a manifest containing a list of dependencies with which other tools can create a web application.

Contrary to the assemble process, the specification of external \js dependencies is a something UHC should allow for. \js FFI declarations import functionality that may depend on the presence of some external \js library. To make the compiler aware of external dependencies there should some interface for conveying this information to the compiler. The dependencies could be specified in a special dependency file, but this requires a new file format, and adds to the semantic distance between the \js FFI declarations and the supporting \js code. A better approach would be to reuse the existing infrastructure and specify the dependencies at either module or function level.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Module level}{}\<[E]%
\\
\>[B]{}\Comment{\{-\#\enskip  INCLUDE "jquery.js" \enskip\#-\}}{}\<[E]%
\\
\>[B]{}\Keyword{module}\;\Conid{JQuery}\;\Keyword{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  Function level}{}\<[E]%
\\
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 jquery.js~\%1.append(\%*)\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{append}\ConSym{::}\Varid{a}\VarSym{â†’}\Varid{b}\VarSym{â†’}\TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Specifying dependencies at the module level has as advantage that is it not necessary to repeat it for every function. However, this ease of use comes at the cost of loosing granularity in the linking process. Also, for flexibility reasons, the task of resolving the filename to an absolute location should be a responsibility of the compiler (search paths should be supplied as a compiler option).

We have implemented a proof of concept for the function level interface, because GHC has deprecated the language pragma, and the function level interface provides more granularity. We found that there was no infrastructure present for letting \emph{Haskell Interface} (HI) files carry external dependencies of any sorts. Hence, in the current implementation only dependencies specified in the \emph{Main} module will be considered during the linking process. In the future this should, evidently, be extended to all modules. 

% \section{Automated \js FFI generation}

% The usefulness of using Haskell to program web applications will greately increase if there would exist interfaces to HTML5 and popular \js libraries. Given the extend of these APIs the manual creation and maintenance of such interfaces would require a significant effort, hence we look into the possibilities of automatically generating them. 

% The interface exposed to \js by the web browser are defined in a language neutral format called the \emph{Web Interface Definition Language} (WebIDL). Unfortunately, the WebIDL definition does not come with an official parser. There used to be automated tooling from the \emph{York Haskell Compiler} to read WebIDL and generate Haskell definitions, but this project seems to be abandoned. 

% Apart from interfacing with the web standards the possibility of interfacing to existing JavaScript library is equally important. We see two potential options: interface extraction through type inference, or through type annotations. Type inference is, however, shown to be non trivial \cite{Vardoulakis:2010:CFA2}. DoctorJS \footnote{\url{http://doctorjs.org/}} provides a partial implementation, but although it seems promising its still far from finished. An alternative provided by some libraries is the use of explicit type annotations (JSDoc) for functions, constructors, and variable definitions. The disadvantage of this approach is that type annotations, located in comment blocks, are not checked for consistency by the language. Also, JSDoc is still work in progress and the tool support for extracting JSDoc annotations (not only for generation documentation) from \js source code is still in its developing stages. 

% Concluding, given the current state of the art it seems impossible to write an interface generator without spending significant effort on it. However, the development of such a tool will in the long run be a determining factor in the adoption of the UHC \js backend. For now manually crafted interfaces will have to do.


\section{Related work}

The omnipresence of \js makes it an attractive target language. There have already been many attempts at compiling languages to \js\footnote{A listing of languages that compile to \js: \url{https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS}}, of which the Google Web Toolkit (GWT) \cite{hanson2007gwt} (Java to \js) has undoubtedly seen most traction among the commercial programming community. Unlike GWT the compilation of Haskell to \js is still very much in its developing stages. Especially the FFI to \js is still under developed. In the following sections we will discuss some of the more prolific attempts at compiling Haskell to \js, and in particular how their FFI implementation compares to UHC's. 

\subsection{York Haskell Compiler}

YHC was the first to compile Haskell to \js \cite{yhc}. It translated the intermediate Core language to \js (similar to UHC), and had tool support for converting IDL definitions to Haskell, emulation of threading on top of \emph{window.setInterval} and CPS, exception handling, an abstraction layer on top of DOM functionality, and a library for building widgets with inter-widget communication based on \cite{Noble95gadgets:lazy}. As a way to communicate with \js it used a special function called \ensuremath{\Varid{unsafeJS}}, which for example could be used to convert some value to a string:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{unsafeToString}\;\Varid{a}\mathrel{=}\Varid{unsafeJS}\;\Char{\char34 return~new~String(exprEval(a));\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{unsafeJS}} function is passed a string containing a \js expression, where the function parameters are brought into scope in the \js expression under an identical name. The same mechanism was used to implement primitive RTS operations:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{global\char95 YHC'\char95 Primitive'\char95 primIntegerAdd}\;\Varid{a}\;\Varid{b}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{unsafeJS}\;\Char{\char34 return~exprEval(a)~+~exprEval(b);\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Where in YHC the runtime evaluation strategy leaks into the FFI, UHC hides it from the programmer through its FEL. Unfortunately, due to amount of work that comes with maintaining a compiler, and the recognition that GHC is the leading Haskell compiler, the authors have decided to discontinue support for the YHC project.

\subsection{GHCJS}

The GHCJS project generates \js based on the STG output it gets by hooking into the GHC compilation pipeline. It appears as if the focus of the project thus far has been mainly on the compilation part, and not so much on the FFI. Its FFI is rather primitive, and piggybacks on the C calling convention:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Varid{ccall}\;\Char{\char34 logResult\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{logResult}\ConSym{::}\Conid{Ptr}\;\Conid{JSObject}\to \TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There, however, seems no support for anything else but function calls. Also, being no experts on the possibilities of GHC hooks, we imagine that the decision to overload the C calling convention is born out of necessity. Modifying the GHC front-end to add new syntax will probably require a fork, which is a severe price to pay. This is where the first-class compiler support for a \js back-end, like with UHC, really shines as it provides for maximum flexibility. 

\subsection{Haste}

Haste \cite{haste} was born out of dissatisfaction with the pre-existing Haskell to \js compilers. Similar to GHCJS it hooks into the STG phase of GHC, however it does make quite a few different design decisions. For instance, it chooses to not support concurrency, leave out on-demand code loading, and use a symbolic intermediate between STG and \js to make many simplifications and optimizations possible. 

Haste also uses the C calling conventions for interfacing with \js:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Varid{ccall}\;\Varid{foo}\ConSym{::}\TConId{Int}\to \TConId{IO}\;\Conid{JSString}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The author also shows that the C calling convention can be used to model callbacks. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Varid{ccall}\;\Varid{cb}\ConSym{::}(\Conid{JSString}\to \TConId{IO}\;())\to \TConId{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, the programmer needs to be careful when invoking the callback. A lot of RTS details shine through
at this point:

\begin{tabbing}\tt
~function~cb\char40{}callback\char44{}~\char95{}state\char95{}of\char95{}the\char95{}world\char41{}~\char123{}\\
\tt ~~~~~A\char40{}callback\char44{}~\char91{}\char91{}1\char44{}\char39{}Hello\char44{}~world\char33{}\char39{}\char93{}\char44{}~0\char93{}\char41{}\char59{}\\
\tt ~~~~~return~\char91{}1\char44{}~\char34{}new~state~of~the~world\char34{}\char93{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

Although \emph{dynamic} and \emph{wrapper} can be both implemented using this functionality there is no syntax and automatic wrapping/unwrapping support. Finally, Haste allows external \js dependencies to be included, not based on FFI imports, but simply by providing it as a compilation parameter.

\section{Conclusion, Discussion \& Future Work}

In this chapter we have continued the work of \cite{jcu} by extending the existing infrastructure for programming with the \js FFI. We did this by providing a model for \js types in Haskell, together with type checking and marshalling functions, further we augmented the FFI with a new keyword for creating \js objects, and a simple way to incorporate external \js dependencies. 

There is, however, much work to be done before the \js back-end is ready for prime time. The inefficiencies caused by mismatches in data representation should eventually be solved by the compiler, e.g. for strings this could be done by implementing overloaded strings. Also, the large number of thunks generated by Haskell programs are a major cause performance problems in the web browser. Support for strictness annotations and analyses in UHC would likely improve this situation. Also, more research is necessary into what the best intermediate representation is for generating \js code. The decision to compile from Core to \js has not been made because it is the best match, but for reasons of simplicity. Besides the performance issues it is definitely worth the effort to look into what it takes to support: automatically generated FFI definitions, concurrency, asynchronous server calls, \ensuremath{\Conid{Data}.\TConId{Dynamic}} as library for type checking \js, automatic insertion of type checks based on FFI type annotations, exceptions, and better error reporting.
\chapter[A lightweight OO DSL]{A lightweight approach to Object-Oriented programming in Haskell}
\label{chap:lightoo}

We are motived to explore the possibilities of Object-Oriented (OO) programming in Haskell by our desire to port  wxWidget's design to Haskell. While Haskell was not originally envisioned as a language for OO programming there have been several attempts at forging it into a OO language either by: extending the language with subtype polymorphism \cite{Nordlander01polymorphicsubtyping}, or embedding a DSL (OOHaskell) with the help of some common language extensions \cite{OOHaskell}. The latter approach has shown that Haskell's type-class-bounded and parametric polymorphism together with multi-parameter type classes and functional dependencies is expressive enough to model even the more advanced features of modern OO languages. 

Because we do not intend to extend Haskell our interest goes out to \oohaskell. The model used by \oohaskell to encode objects and their types is based on polymorphic, extensible records of closures, and favors encapsulation by procedural abstraction over existential types \cite{Pierce_object-orientedprogramming}. Haskell records are not polymorphic and extensible, hence \oohaskell makes heavy use of the HList library \cite{hlist} which models polymorphic extensible records through advanced type-level programming using functional dependencies. In their paper the authors also discuss several more primitive OO encodings. With one standing out in particular as bearing most resemblance with \oohaskell. It is described in section 3.4 \emph{"Mutable objects, with tail polymorphism"} and attempts to reify extensible records on top of regular records by leaving the so called tail of the record polymorph. After discussing the alternative encodings the authors venture into the more involved aspects of OO programming using the superior HList encoding. Several subjects such as code reuse, casting, self-returning methods, and more advanced forms of subtyping are left undiscussed for the more primitive encodings discharging them as: involved, requiring lots of boilerplate, or even infeasible. 

It would make sense to reuse \oohaskell were it not that UHC does not yet support functional dependencies. Driven by the practical necessity of a working OO approach not dependent on functional dependencies we attempt to stretch the possibilities of the \emph{"Mutable objects, with tail polymorphism"} approach and try to make its limitations manifest by submitting it to the different scenarios \oohaskell is submitted to. The outline and examples in this chapter will therefore, to a large extent, be shamelessly based on \oohaskell.  

Our contribution consists of an extensive exploration of the \emph{"Mutable objects, with tail polymorphism"} approach where we augment the original approach with a generic up and downcast operation and a combinator for expressing inheritance. Furthermore, we generalize the approach to a restricted form of parameterized classes. All results are bundled inside a ready to use library which comes with useful combinators and macros for deriving some of the boilerplate.

\section{Introduction}

\subsection{What is Object-Oriented programming?}

The fundamental concepts of OO programming originated in Simula 67 \cite{Holmevik:1994:CSH:612489.612573}. Later Smalltalk \cite{Goldberg:1983:SLI:273} extended and refined the concepts of Simula 67 by treating everything as an object (even a class) and uniformly interpreted all operations as passing messages to objects. Since Simula 67 and Smalltalk, OO languages have evolved and many varieties exist today which would make it pretentious to suggest we can provide a fitting answer to the section's title. However, there exists a common conception among researchers about what features are typically found in OO languages. According to Benjamin C. Pierce \cite{tpl} the fundamental feature set consists of:

\begin{enumerate}
  \item {\bf Multiple representations}. Objects with the same interface may use entirely different representations, i.e. an object interface is an abstract representation of the many possible instantiations. Method invocation works irrespective of the object representation. 

  \item {\bf Encapsulation}. The internal representation of an object is hidden such that only its methods may access it. 

  \item {\bf Subtyping}. The type of an object can be described by its interface, nominal name, or both. Often we want to write functionality which depends only on a part of an object's type. It would be too restrictive if we limit the functionality to work on \emph{exactly} one object type. Subtyping loosens this restriction allowing  functionality to work for many types as long as the expected type is related to the given type through the subtyping relation.

  \item {\bf Inheritance}. It is common for objects to share behavior with other objects. Inheritance is a mechanism which allows a particular form of behavior sharing; it accomplishes this by allowing the incremental extension of classes with the possibility to override pre-existing behavior. A class acts as a template for object instantiation. By extending a class we obtain a subclass which is just a regular class. 

  \item {\bf Open recursion}. Typically, an OO language allows the body of an object method to refer to other methods of the same object using a special identifier usually called \emph{this} or \emph{self}. In combination with inheritance it is essential that \emph{self} is \emph{late-bound} allowing it to refer to methods defined at a later point.
\end{enumerate}

\subsection{Outline}

In the section \ref{sec:shapes} we provide a high-level overview of the library. In section \ref{sec:tp-rec} we incrementally develop the type-independent part of the library. In section \ref{sec:ty-per} we look at the library from a type perspective and develop generic casting operations, discuss self-returning methods, and generalize the approach to a restricted form of parameterized classes. In section \ref{sec:discussion} we conclude with a discussion about the usability and efficiency of the library and provide some directions for future work. 

\section{The `shapes` example}
\label{sec:shapes}

The `shapes` example \footnote{See \url{http://onestepback.org/articles/poly/} for a multi-lingual collection of implementations in both OO as well as non-OO languages} combines the typical aspects found in OO languages into a single crisp benchmark.

\begin{figure}[h]
\center
\includegraphics[scale=.6]{resources/shapes.png}
\caption{An UML diagram for the shapes example. The boxes are subdivided into three compartments. The top-level compartment contains the class name, beneath it is a list of member variables prefixed with +/- respectively public or private, and at the bottom a list of methods. The arrows indicate an inheritance relationship, and bold faced text denotes an abstract method.}
\label{fig:shapesuml}
\end{figure}

Figure \ref{fig:shapesuml} shows the abstract class \emph{Shape} with two concrete subclasses \emph{Rectangle} and \emph{Circle}. A \emph{Shape} maintains a position and provides methods to directly \emph{moveTo} a new position, move relative to current position \emph{rMoveTo}, or \emph{draw} the \emph{Shape} in question. \emph{Rectangle} and \emph{Circle} augment their superclass with additional geometric data and implement the \emph{abstract} \emph{draw} method. To exercise subtype polymorphism different kinds of shapes are placed inside a collection containing shapes. The collection is then iterated over drawing each individual shape.

We first show the implementation of the `shapes` example in Java followed by an implementation in Haskell using our library.

\subsection{Shapes in Java}
\label{subsec:shapesjava}

The \emph{Shape} class can trivially be translated to Java:

\begin{tabbing}\tt
~public~abstract~class~Shape~\char123{}\\
\tt ~~~private~int~x\char59{}\\
\tt ~~~private~int~y\char59{}\\
\tt ~\\
\tt ~~~public~Shape\char40{}int~newx\char44{}~int~newy\char41{}~\char123{}\\
\tt ~~~~~x~\char61{}~newx\char59{}\\
\tt ~~~~~y~\char61{}~newy\char59{}\\
\tt ~~~\char125{}\\
\tt ~\\
\tt ~~~public~int~getX\char40{}\char41{}~\char123{}~return~x\char59{}~\char125{}\\
\tt ~~~public~int~getY\char40{}\char41{}~\char123{}~return~y\char59{}~\char125{}\\
\tt ~~~public~void~setX\char40{}int~newx\char41{}~\char123{}~x~\char61{}~newx\char59{}~\char125{}\\
\tt ~~~public~void~setY\char40{}int~newy\char41{}~\char123{}~y~\char61{}~newy\char59{}~\char125{}\\
\tt ~\\
\tt ~~~public~void~moveTo\char40{}int~newx\char44{}~int~newy\char41{}~\char123{}\\
\tt ~~~~~x~\char61{}~newx\char59{}\\
\tt ~~~~~y~\char61{}~newy\char59{}\\
\tt ~~~\char125{}\\
\tt ~\\
\tt ~~~public~void~rMoveTo\char40{}int~deltax\char44{}~int~deltay\char41{}~\char123{}\\
\tt ~~~~~moveTo\char40{}getX\char40{}\char41{}~\char43{}~deltaX\char44{}~getY\char40{}\char41{}~\char43{}~deltay\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~\\
\tt ~~~public~abstract~void~draw\char40{}\char41{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

The \emph{Shape} constructor receives an x and y coordinate of type \emph{int} and assigns them to its private member variables. The \emph{draw} method is marked as abstract. Subclasses stay abstract if they do not implement \emph{draw} or add new abstract methods. 

Here follows the definition of \emph{Rectangle}:

\begin{tabbing}\tt
~public~class~Rectangle~extends~Shape~\char123{}\\
\tt ~~~\\
\tt ~~~\char47{}\char47{}~Private~attributes\\
\tt ~~~private~int~width\char59{}\\
\tt ~~~private~int~height\char59{}\\
\tt ~\\
\tt ~~~\char47{}\char47{}~Constructor\\
\tt ~~~Rectangle\char40{}int~newx\char44{}~int~newy\char44{}~int~newwidth\char44{}~int~newheight\char41{}~\char123{}\\
\tt ~~~~~super\char40{}newx\char44{}~newy\char41{}\char59{}\\
\tt ~~~~~width~~\char61{}~newwidth\char59{}\\
\tt ~~~~~height~\char61{}~newheight\char59{}~~\\
\tt ~~~\char125{}\\
\tt ~\\
\tt ~~~\char47{}\char47{}~Accessors\\
\tt ~~~public~int~getWidth\char40{}\char41{}~\char123{}~return~width\char59{}~\char125{}\\
\tt ~~~public~int~getHeight\char40{}\char41{}~\char123{}~return~height\char59{}~\char125{}\\
\tt ~~~public~void~setWidth\char40{}int~newwidth\char41{}~\char123{}~width~\char61{}~newwidth\char59{}~\char125{}\\
\tt ~~~public~void~setHeight\char40{}int~newheight\char41{}~\char123{}~height~\char61{}~newheight\char59{}~\char125{}\\
\tt ~\\
\tt ~~~~~\char47{}\char47{}~Implementation~of~the~abstract~draw~method\\
\tt ~~~public~void~draw\char40{}\char41{}~\char123{}\\
\tt ~~~~~System\char46{}out\char46{}println\char40{}\\
\tt ~~~~~~~~~~\char34{}Drawing~a~Rectangle~at\char58{}\char40{}\char34{}\\
\tt ~~~~~~~\char43{}\char43{}~getX\char40{}\char41{}~\char43{}\char43{}~\char34{}\char44{}\char34{}~\char43{}\char43{}~getY\char40{}\char41{}\\
\tt ~~~~~~~\char43{}\char43{}~\char34{}\char41{}\char44{}~width~\char34{}~\char43{}\char43{}~getWidth\char40{}\char41{}~\\
\tt ~~~~~~~\char43{}\char43{}~\char34{}\char44{}~height~\char34{}~\char60{}\char60{}~getHeight\char40{}\char41{}\\
\tt ~~~~~\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}

\emph{Circle} is defined similarly, we elide its full definition for the sake of brevity. 

\begin{tabbing}\tt
~public~class~Circle~extends~Shape~\char123{}\\
\tt ~~~Circle\char40{}int~newx\char44{}~int~newy\char44{}~int~newradius\char41{}~\char123{}\\
\tt ~~~~~super\char40{}newx\char44{}~newy\char41{}\char59{}\\
\tt ~~~~~\char46{}\char46{}\char46{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}

Next, we put different kinds of shapes into a single collection of shapes. Inserting a \emph{Rectangle} and \emph{Circle} into a collection where shapes are expected exercises the language's ability to perform subtype polymorphism.

\begin{tabbing}\tt
~Shape\char91{}\char93{}~scribble~\char61{}~new~Shape\char91{}2\char93{}\char59{}\\
\tt ~scribble\char91{}0\char93{}~\char61{}~new~Rectangle\char40{}10\char44{}~20\char44{}~5\char44{}~6\char41{}\char59{}\\
\tt ~scribble\char91{}1\char93{}~\char61{}~new~Circle\char40{}15\char44{}~25\char44{}~8\char41{}\char59{}\\
\tt ~for\char40{}int~i~\char61{}~0\char59{}~i~\char60{}~2\char59{}~i\char43{}\char43{}\char41{}~\char123{}\\
\tt ~~~scribble\char91{}i\char93{}\char46{}draw\char40{}\char41{}\char59{}\\
\tt ~~~scribble\char91{}i\char93{}\char46{}rMoveTo\char40{}100\char44{}~100\char41{}\char59{}\\
\tt ~~~scribble\char91{}i\char93{}\char46{}draw\char40{}\char41{}\char59{}\\
\tt ~\char125{}
\end{tabbing}

We iterate over the list and draw the individual shapes to the screen.

\subsection{Shapes in Haskell}
\label{subsec:shapeshaskell}

We will now show how the shapes example is transcribed to Haskell using our library for OO programming. The library works with regular Haskell records, the \ensuremath{\Conid{Data}.\TConId{Dynamic}} library, and uses the C pre-processor (CPP) to derive some of the necessary boilerplate.

First, we transcribe the interface of the \emph{Shape} class as a Haskell record. Analogous to a Java interface.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}c<{\hspost}@{}}%
\column{4E}{@{}l@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IShape}\;\Varid{a}\mathrel{=}\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{getX}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{getY}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{setX}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{setY}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{moveTo}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{Int}\to \TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{rMoveTo}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{Int}\to \TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{draw}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},{}\<[4E]%
\>[7]{}\Varid{\char95 shapeTail}{}\<[19]%
\>[19]{}\ConSym{::}\Conid{Record}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  Derive boilerplate }{}\<[E]%
\\
\>[B]{}DefineClass_{macro}\;(\Conid{Shape},\Conid{IShape},\Varid{shapeTail},,\Numeral{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Record selectors correspond to methods in the \emph{Shape} class. There is a \emph{single} special method \ensuremath{\Varid{\char95 shapeTail}} for the extension of the record or as we shall call it \emph{the tail of the record}. It is an artifact of our dependence on regular Haskell records and cannot be abstracted over. The technique of leaving the tail polymorph is known as type extension through polymorphism \cite{Burton:1990:TET:77606.214515}. Finally, we use a CPP macro for deriving some of the boilerplate for manipulating records (see section \ref{sec:boilerplate}).

The implementation of \emph{Shape} is given by \ensuremath{\Varid{shape}} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  An implementation of the shapes interface}{}\<[E]%
\\
\>[B]{}\Varid{shape}\;\Varid{newx}\;\Varid{newy}\;\Varid{concreteDraw}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Create references for private state}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{x}\leftarrow \Varid{newIORef}\;\Varid{newx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{y}\leftarrow \Varid{newIORef}\;\Varid{newy}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Return a Shape}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{getX}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{readIORef}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{getY}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{readIORef}\;\Varid{y}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{setX}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{writeIORef}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{setY}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{writeIORef}\;\Varid{y}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{moveTo}{}\<[18]%
\>[18]{}\mathrel{=}\lambda \Varid{newx}\;\Varid{newy}\to \Keyword{do}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{self}\VarSym{\#}\Varid{setX}\mathbin{\$}\Varid{newx}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{self}\VarSym{\#}\Varid{setY}\mathbin{\$}\Varid{newy}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{rMoveTo}{}\<[18]%
\>[18]{}\mathrel{=}\lambda \Varid{deltax}\;\Varid{deltay}\to \Keyword{do}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{x}\leftarrow \Varid{self}\VarSym{\#}\Varid{getX}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{y}\leftarrow \Varid{self}\VarSym{\#}\Varid{getY}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}(\Varid{self}\VarSym{\#}\Varid{moveTo})\;(\Varid{x}\VarSym{+}\Varid{deltax})\;(\Varid{y}\VarSym{+}\Varid{deltay}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{draw}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{concreteDraw}\;\Varid{self}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{\char95 shapeTail}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It takes the two initial values for \ensuremath{\Varid{x}} and \ensuremath{\Varid{y}}, an implementation for the \ensuremath{\Varid{draw}} method, an extension of the record, a self-reference, and returns an instance of \emph{Shape} (i.e. a value of \ensuremath{\Conid{IShape}}). The \ensuremath{\Varid{concreteDraw}} parameter makes it explicit that we cannot obtain an instance of \emph{Shape} unless we provide it with an implementation of \emph{draw}. Consequently, we can easily create instances of \emph{Shape} without creating a subclass -- analogous to an anonymous inner class in Java. The \ensuremath{\Keyword{clazz}} combinator, only used for classes with no parent class, brings two additional parameters into scope \ensuremath{\Varid{tail}} and \ensuremath{\Varid{self}}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{clazz}\;\Varid{cont}\;\Varid{tail}\;\Varid{self}\mathrel{=}\Varid{tail}\rightarrowtail \lambda \Varid{t}\to \Varid{cont}\;\Varid{t}\;\Varid{self}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{tail}} parameter represents the extension of the record and should only be used at the tail position, \ensuremath{\Varid{\char95 shapeTail}} in this case. Interestingly, \ensuremath{\Varid{self}} is an explicit parameter of the function whereas in most OO languages it is implemented as an language primitive. For stylistic purposes we use some syntactic sugar to distinguish between regular functions and methods:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Reverse application}{}\<[E]%
\\
\>[B]{}(\VarSym{\#})\ConSym{::}\Varid{a}\to (\Varid{a}\to \Varid{b})\to \Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{o}\VarSym{\#}\Varid{f}\mathrel{=}\Varid{f}\;\Varid{o}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \emph{Rectangle} interface is transcribed similar to \emph{Shape}'s the only difference is that we use a different macro for deriving the boilerplate.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IRectangle}\;\Varid{a}\mathrel{=}\Conid{IRectangle}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 getWidth}{}\<[21]%
\>[21]{}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 getHeight}{}\<[21]%
\>[21]{}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 setWidth}{}\<[21]%
\>[21]{}\ConSym{::}\TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 setHeight}{}\<[21]%
\>[21]{}\ConSym{::}\TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 rectangleTail}{}\<[21]%
\>[21]{}\ConSym{::}\Conid{Record}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  Boilerplate for record manipulation and subtype axioms}{}\<[E]%
\\
\>[B]{}DefineSubClass_{macro}\;(\Conid{Rectangle},\Conid{Shape},\Conid{IRectangle},\Varid{rectangleTail},,,,\Numeral{1},){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Here follows the implementation of the \emph{Rectangle}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}c<{\hspost}@{}}%
\column{5E}{@{}l@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}c<{\hspost}@{}}%
\column{10E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rectangle}\;\Varid{x}\;\Varid{y}\;\Varid{width}\;\Varid{height}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Comment{  -{}-\enskip  Create a new object generator by connecting the records of shape and rectangle}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{rectangle'}\mathbin{`\Keyword{extends}`}\Varid{shape}\;\Varid{x}\;\Varid{y}\;\Varid{draw})\;\Varid{noOverride}\;\Varid{set\char95 Shape\char95 Tail}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{rectangle'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{w}\leftarrow \Varid{newIORef}\;\Varid{width}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{h}\leftarrow \Varid{newIORef}\;\Varid{height}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{IRectangle}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{6}{}\<[13]%
\>[13]{}\Varid{\char95 getWidth}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{readIORef}\;{}\<[43]%
\>[43]{}\Varid{w}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},{}\<[10E]%
\>[13]{}\Varid{\char95 getHeight}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{readIORef}\;{}\<[43]%
\>[43]{}\Varid{h}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},{}\<[10E]%
\>[13]{}\Varid{\char95 setWidth}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{writeIORef}\;{}\<[43]%
\>[43]{}\Varid{w}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},{}\<[10E]%
\>[13]{}\Varid{\char95 setHeight}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{writeIORef}\;{}\<[43]%
\>[43]{}\Varid{h}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},{}\<[10E]%
\>[13]{}\Varid{\char95 rectangleTail}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Comment{  -{}-\enskip  The implementation of the abstract draw method}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{draw}\;\Varid{self}\mathrel{=}\Varid{printLn}\;({}\<[E]%
\\
\>[4]{}\hsindent{5}{}\<[9]%
\>[9]{}\Char{\char34 Drawing~a~Rectangle~at:(\char34}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Varid{self}\VarSym{\#}\Varid{getX}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Char{\char34 ,~\char34}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Varid{self}\VarSym{\#}\Varid{getY}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Char{\char34 ),~width~\char34}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Varid{self}\VarSym{\#}\Varid{getWidth}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\VarSym{<<}{}\<[5E]%
\>[9]{}\Char{\char34 ,~height~\char34}\VarSym{<<}\Varid{self}\VarSym{\#}\Varid{getHeight}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}){}\<[3E]%
\ColumnHook
\end{hscode}\resethooks

We use the \ensuremath{\Keyword{extends}} combinator in order to make \emph{Rectangle} a subclass of \emph{Shape}. It combines the implementation of \emph{Rectangle} given by \ensuremath{\Varid{rectangle'}} with that of its superclass. The right-hand side of \ensuremath{\Keyword{extends}} is analogous to the call to super in the Java example. In between the extension of the superclass with its subclass there is an opportunity to override functionality defined in the superclass. The function that allows for this to happen is also passed as a parameter to \ensuremath{\Keyword{extends}}. Because \emph{Rectangle} does not override any functionality we simply pass in \ensuremath{\Varid{noOverride}} which is essentially the identity function.

Notice how we left out the underscore prefix on the method invocations inside the \ensuremath{\Varid{draw}} implementation, because objects are represented as a nested records we need a helper method to invoke for instance \ensuremath{\Varid{\char95 getWidth}}. The implementation of these helper functions corresponds to the top-down unwrapping of the record extensions until the target method is reached.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}c<{\hspost}@{}}%
\column{27E}{@{}l@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}c<{\hspost}@{}}%
\column{40E}{@{}l@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Boilerplate for explicit method lookup}{}\<[E]%
\\
\>[B]{}\Varid{getWidth}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\Varid{\char95 getWidth}{}\<[27]%
\>[27]{}\hsdot{\circ }{.}{}\<[27E]%
\>[30]{}\Varid{unRecord}{}\<[40]%
\>[40]{}\hsdot{\circ }{.}{}\<[40E]%
\>[43]{}\Varid{\char95 shapeTail}{}\<[E]%
\\
\>[B]{}\Varid{getHeight}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\Varid{\char95 getHeight}{}\<[27]%
\>[27]{}\hsdot{\circ }{.}{}\<[27E]%
\>[30]{}\Varid{unRecord}{}\<[40]%
\>[40]{}\hsdot{\circ }{.}{}\<[40E]%
\>[43]{}\Varid{\char95 shapeTail}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  etc.}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In an OO language the method lookup algorithm takes care of these method lookups starting at the callee tracing the pointers until the relevant method is found. Our method lookup works the other way around by starting at the top. 

We leave out the implementation of \emph{Circle} which is conceptually no different from \emph{Rectangle} and continue with the implementation of the scribble loop:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarId{s_1}\leftarrow \Keyword{new}\mathbin{\$}\Varid{rectangle}\;\Numeral{10}\;\Numeral{20}\;\Numeral{5}\;\Numeral{6}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarId{s_2}\leftarrow \Keyword{new}\mathbin{\$}\Varid{circle}\;\Numeral{15}\;\Numeral{25}\;\Numeral{8}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Create a single homogeneous list of shapes }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Shape is short for: IShape ()}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;{}\<[8]%
\>[8]{}\Varid{scribble}{}\<[18]%
\>[18]{}\ConSym{::}[\mskip1.5mu \Conid{IShape}\;()\mskip1.5mu]{}\<[E]%
\\
\>[8]{}\Varid{scribble}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{consUb}\;\VarId{s_1}\;(\Varid{consUb}\;\VarId{s_2}\;\Varid{nilUb}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Iterate over the homogeneous list with a monadic version of map discarding the result}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{sequence\char95 }\mathbin{\$}\Varid{map}\;{}\<[20]%
\>[20]{}(\lambda \Varid{shape}\to \Keyword{do}{}\<[E]%
\\
\>[20]{}\hsindent{3}{}\<[23]%
\>[23]{}\Varid{shape}\VarSym{\#}\Varid{draw}{}\<[E]%
\\
\>[20]{}\hsindent{3}{}\<[23]%
\>[23]{}(\Varid{shape}\VarSym{\#}\Varid{rMoveTo})\;\Numeral{100}\;\Numeral{100}{}\<[E]%
\\
\>[20]{}\hsindent{3}{}\<[23]%
\>[23]{}\Varid{shape}\VarSym{\#}\Varid{draw}){}\<[E]%
\\
\>[3]{}\hsindent{12}{}\<[15]%
\>[15]{}\Varid{scribble}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We use the \ensuremath{\Keyword{new}} combinator to new create object instances. Unlike Java or any other OO language with subtype polymorphism we cannot simply place \ensuremath{\VarId{s_1}\ConSym{::}\Conid{Rectangle}} and \ensuremath{\VarId{s_2}\ConSym{::}\Conid{Circle}} inside a list of shapes, so we use a helper function \ensuremath{\Varid{consUb}} to automatically convert their types to \emph{Shape} before we cons them onto the list.

\begin{tabbing}\tt
~ghci\char62{}~myOOP\\
\tt ~Drawing~a~Rectangle~at\char58{}\char40{}10\char44{}~20\char41{}\char44{}~width~5\char44{}~height~6\\
\tt ~Drawing~a~Rectangle~at\char58{}\char40{}110\char44{}~120\char41{}\char44{}~width~5\char44{}~height~6\\
\tt ~Drawing~a~Circle~at\char58{}\char40{}15\char44{}25\char41{}\char44{}~radius~8\\
\tt ~Drawing~a~Circle~at\char58{}\char40{}115\char44{}125\char41{}\char44{}~radius~8
\end{tabbing}

\section{Objects in Haskell}
\label{sec:tp-rec}

In this section we will incrementally develop the object encoding used by our library. Similar to \oohaskell we follow the examples from the OCaml tutorial \cite{ocaml}.

\subsection{Objects as tail-polymorphic records}
\label{subsec:tp-records}

\begin{quote}
"The class point below defines one instance variable varX and two methods getX and
moveX. The initial value of the instance variable is 0. The variable varX is declared mutable.
Hence, the method moveX can change its value.", \emph{section 3.1}
\end{quote}
\vspace{10pt}
\begin{OCaml}
class point =
  object
    val mutable varX = 0
    method getX = varX
    method moveX d = varX <- varX + d
end;;
\end{OCaml}

In a first attempt at transcribing the one-dimensional \emph{Point} class we map its interface to a record and let every method correspond to a selector.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Point}\mathrel{=}\Conid{Point}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{getX}{}\<[14]%
\>[14]{}\ConSym{::}\TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{moveX}{}\<[14]%
\>[14]{}\ConSym{::}\TConId{Int}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{point}} function instantiates a \emph{Point} by creating a new value of type \ensuremath{\Conid{Point}}. It models the mutable variable \emph{varX} as an \ensuremath{\Conid{IORef}} lexically scoped over the record. Here objects are closures of records\footnote{Objects as closures in Scheme: \url{ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/swob.txt}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{point}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{varX}\leftarrow \Varid{newIORef}\;\Numeral{0}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{Point}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Varid{getX}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{moveX}{}\<[16]%
\>[16]{}\mathrel{=}\lambda \Varid{d}\to \Varid{modifyIORef}\;\Varid{varX}\;((\VarSym{+})\;\Varid{d}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A method is a function which works on and belongs to an object, i.e. it has access to the state encapsulated by the object. Using \ensuremath{\Varid{point}} we can write some basic OO code:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myFirstOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\leftarrow \Varid{point}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{getX}\rightarrowtail \Varid{print}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{3}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{getX}\rightarrowtail \Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~\char62{}~myFirstOOP\\
\tt ~0\\
\tt ~3
\end{tabbing}

There are a couple of problems with the encoding. In a typical OO language methods and data are for efficiency reasons modeled as separate entities such that methods can be shared among objects of the same type. Because efficiency is not our primary concern we stick with the conceptually simpler approach where data and methods are modeled as a single entity. Of a more pressing nature is the impossibility to extend objects with additional methods. For this reason, amongst other things, the authors of \oohaskell resort to using extensible records \cite{hlist}. Instead of lifting the Haskell 98 restriction we stick with regular records and use a poor man's approach to extensible records called type extension through polymorphism \cite{Burton:1990:TET:77606.214515}, which can easily be modeled using a parameterized record type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Point}\;\alpha\mathrel{=}\Conid{Point}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 pointTail}\ConSym{::}\alpha{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Conid{Point}} type is modified to take a type parameter ($\alpha$) which represents the extension/tail of the record together with a special method for manipulating it. To account for the extension of \ensuremath{\Conid{Point}} the \ensuremath{\Varid{point}} function is also modified to take an additional parameter representing a computation that will result in the tail: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}c<{\hspost}@{}}%
\column{5E}{@{}l@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{point}\;\Varid{tail}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{record}\leftarrow \Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{Point}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\VarSym{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},{}\<[5E]%
\>[8]{}\Varid{\char95 pointTail}\mathrel{=}\Varid{record}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now that we can extend \ensuremath{\Conid{Point}} with another record we also want to have a way of closing the record extension.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{emptyRecord}\ConSym{::}\TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{emptyRecord}\mathrel{=}\Varid{return}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{emptyRecord}} represents the end of a record extension. Like before we can construct a \ensuremath{\Varid{point}} object, but we now first apply it to the \ensuremath{\Varid{emptyRecord}}:

\begin{tabbing}\tt
~myFirstOOP~\char61{}~do\\
\tt ~~~~p~\char60{}\char45{}~point~emptyRecord\\
\tt ~~~~\char46{}\char46{}\char46{}
\end{tabbing}

We create an extension of \ensuremath{\Conid{Point}} called \ensuremath{\Conid{Point2D}} for representing points in the 2-dimensional plane.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{point2d}\;\Varid{tail}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{point}\;\Varid{point2d'}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{point2d'}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{varY}{}\<[13]%
\>[13]{}\leftarrow \Varid{newIORef}\;\Numeral{0}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{record}{}\<[13]%
\>[13]{}\leftarrow \Varid{tail}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{return}\;\Conid{Point2D}\;\{\mskip1.5mu {}\<[E]%
\\
\>[5]{}\hsindent{3}{}\<[8]%
\>[8]{}\Varid{\char95 getY}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{readIORef}\;\Varid{varY}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},\Varid{\char95 moveY}{}\<[22]%
\>[22]{}\mathrel{=}\lambda \Varid{d}\to \Varid{modifyIORef}\;\Varid{varY}\;((\VarSym{+})\;\Varid{d}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},\Varid{\char95 point2DTail}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{record}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We omit the interface definition of \ensuremath{\Conid{Point2D}} as its signature can be easily inferred from the implementation. The fact that we pass \ensuremath{\Varid{point2d'}} to \ensuremath{\Varid{point}} clearly expresses that a 2d-point is constructed out of a \ensuremath{\Conid{Point}} linked to a \ensuremath{\Conid{Point2D}}. This becomes even clearer when we look at the type:

\begin{tabbing}\tt
~\char62{}\char58{}t~point2d~emptyRecord\\
\tt ~Point~\char40{}Point2D~\char40{}\char41{}\char41{}
\end{tabbing}

The type structure revealed by our encoding is in fact equivalent to the phantom type structure used in \cite{Finne:1999:CHH:317765.317790} to model a type safe interface to external OO code, which was later formalized in\cite{Fluet:2006:PTS:1180085.1180088}. However, contrary to the phantom types our encoding has meaningful Haskell inhabitants.  

We have already encoded a small hierarchy of points. To accompany colored points we can simply extend the hierarchy:

\begin{tikzpicture}
[level distance=15mm,level/.style={sibling distance=40mm/#1}]
\node {Point ()}
  child {node {Point (Point2D ())}}
  child {node {Point (ColoredPoint ())}}
  child {node {...}};
\end{tikzpicture}

Every node in the hierarchy represents an unique object type, each child node has exactly one more nested record than its parent, and there are a finite number of object types. Under these conditions the hierarchy forms a finite subtype hierarchy where each child is in a subtype relationship with its parent. 

We can benefit from type unification to express the subtyping relationship to the type system:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{getX}\ConSym{::}\Conid{Point}\;\alpha\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By leaving the tail of \ensuremath{\Conid{Point}} polymorph \ensuremath{\Varid{getX}} can be applied to any object type that is \emph{at least} a \ensuremath{\Conid{Point}}.
The \ensuremath{\Conid{Point}\;\alpha} type is an abstract encoding matching a set of concrete encodings. The phantom type encoding allows abstract encodings to occur in the co-variant (producing) position \cite{Fluet:2006:PTS:1180085.1180088}, but because we always have values associated it is not safe to do so. Hence we limit abstract encodings to the contravariant (consuming) position. 

In the previous section we showed how method lookups are performed, but left their type unspecified. In our encoding a method always expects an abstract encoding as its first argument enabling reuse across all subtypes.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Optional type}{}\<[E]%
\\
\>[B]{}\Varid{getY}\ConSym{::}\Conid{Point}\;(\Conid{Point2D}\;\Varid{a})\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\\
\>[B]{}\Varid{getY}\mathrel{=}\Varid{\char95 getY}\hsdot{\circ }{.}\Varid{\char95 pointTail}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To make our notion of interface, class, and object somewhat less vague we provide their definitions.

\vspace{10pt}
\begin{definition}
\label{def:interface}
An interface is a record $C$ with the following shape:

\ensuremath{\Keyword{data}\;\Conid{C}\;\Varid{t}\mathrel{=}\Conid{C}\;\{\mskip1.5mu \Varid{m},\Varid{\char95 cTail}\ConSym{::}\Varid{t}\mskip1.5mu\}}

where $C$ takes a type parameter $t$ representing the tail, and may be instantiated to either \ensuremath{()} or a interface. In the body $m$ expands to zero or more methods, and \ensuremath{\Varid{\char95 cTail}} is a special method where \ensuremath{\Varid{c}} is the uncapitalized version of \ensuremath{\Conid{C}}.
\end{definition}

\vspace{10pt}
\begin{definition}
\label{def:class}
A class is a function that provides the implementation of an interface.
\end{definition}

\vspace{10pt}
\begin{definition}
\label{def:object}
An object is an instantiation (value) of an interface obtained through a class.
\end{definition}

Thus far we have explained the basic object encoding underlying our library together with its rational. Although we will later discover that we need to slightly modify it in order to facilitate casting the basic idea will remain the same.

\subsection{Constructor arguments}

\begin{quote}
"The class point can also be abstracted over the initial value of \ensuremath{\Varid{varX}}. The parameter \ensuremath{\Varid{x\char95 init}} is, of course, visible in the whole body of the definition, including methods. For instance, the method \ensuremath{\Varid{getOffset}} in the class below returns the position of the object relative
to its initial position.", \emph{section 3.1}
\end{quote} 
\vspace{10pt}
\begin{OCaml}
class para_point x_init =
  object
    val mutable varX = x_init
    method getX      = varX
    method getOffset = varX - x_init
    method moveX d   = varX <- varX + d
end;;
\end{OCaml}

The previous incarnation of \ensuremath{\Varid{point}} allocated an initial value for \emph{varX} inside its body. There is nothing restriction us from moving the initial value out of the body and turning it into an argument. Here follows a more general version of \ensuremath{\Varid{point}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{para\char95 point}\;\Varid{tail}\;\Varid{x\char95 init}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{record}{}\<[11]%
\>[11]{}\leftarrow \Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{varX}{}\<[11]%
\>[11]{}\leftarrow \Varid{newIORef}\;\Varid{x\char95 init}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{ParaPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Varid{getX}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{moveX}{}\<[22]%
\>[22]{}\mathrel{=}\lambda \Varid{d}\to \Varid{modifyIORef}\;\Varid{varX}\;((\VarSym{+})\;\Varid{d}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{getOffset}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}\rightarrowtail \lambda \Varid{x}\to \Varid{return}\;(\Varid{x}\VarSym{-}\Varid{x\char95 init}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{\char95 paraPointTail}{}\<[22]%
\>[22]{}\mathrel{=}\Varid{record}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Construction-time computations}

\begin{quote}
"Expressions can be evaluated and bound before defining the object body of the class. This is useful to enforce invariants. For instance, points can be automatically adjusted to the nearest point on a grid, as follows:", \emph{section 3.1}
\end{quote}
\vspace{10pt}
\begin{OCaml}
class adjusted_point x_init =
   let origin = (x_init / 10) * 10 in
   object 
     val mutable varX   = origin
     method getX        = x
     method getOffset   = x - origin
     method moveX     d = x <- x + d
   end;;
\end{OCaml}

Similar to OCaml we may perform computations prior (in the non-strict sense) to object construction by using a let binding.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}c<{\hspost}@{}}%
\column{13E}{@{}l@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{adjusted\char95 point}\;\Varid{tail}\;\Varid{x\char95 init}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{origin}\mathrel{=}(\Varid{x\char95 init}\mathbin{/}\Numeral{10})\VarSym{*}\Numeral{10}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Keyword{do}{}\<[10]%
\>[10]{}\VarSym{...}{}\<[E]%
\\
\>[10]{}\Varid{varX}\leftarrow \Varid{newIORef}\;\Varid{x\char95 init}{}\<[E]%
\\
\>[10]{}\Varid{return}\;\Conid{ParaPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\VarSym{...}{}\<[13E]%
\\
\>[10]{}\hsindent{2}{}\<[12]%
\>[12]{},\Varid{getOffset}{}\<[24]%
\>[24]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}\rightarrowtail \lambda \Varid{x}\to \Varid{return}\;(\Varid{x}\VarSym{-}\Varid{origin}){}\<[E]%
\\
\>[10]{}\hsindent{2}{}\<[12]%
\>[12]{}\VarSym{...}{}\<[E]%
\\
\>[10]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Semi-explicit parameterized classes}
\label{subsec:semi-explicit-poly}

The \ensuremath{\Varid{para\char95 point}} function has its argument type fixed to \ensuremath{\TConId{Int}}. This may proof unnecessarily restrictive. We can lift the restriction by introducing an additional type parameter to \ensuremath{\Conid{ParaPoint}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{ParaPoint}\;\Varid{a}\;\Varid{t}\mathrel{=}\Conid{ParaPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{getX}{}\<[20]%
\>[20]{}\ConSym{::}\TConId{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{moveX}{}\<[20]%
\>[20]{}\ConSym{::}\Varid{a}\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{getOffset}{}\<[20]%
\>[20]{}\ConSym{::}\TConId{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 paraPointTail}{}\<[20]%
\>[20]{}\ConSym{::}\Varid{t}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type inferencer will automatically infer a more general type for \ensuremath{\Varid{para\char95 point}} without any modifications to \ensuremath{\Varid{para\char95 point}}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{para\char95 point}\ConSym{::}\TClassId{Num}\;\Varid{a}\Rightarrow \Varid{a}\to \TConId{IO}\;(\Conid{ParaPoint}\;\Varid{a}\;\Varid{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Parameterized points are now bounded polymorph and can be constructed using \emph{any} type of number. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myPolyOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}{}\<[8]%
\>[8]{}\leftarrow \Varid{para\char95 point}\;\Varid{emptyRecord}\;(\Numeral{1}\ConSym{::}\TConId{Int}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p'}{}\<[8]%
\>[8]{}\leftarrow \Varid{para\char95 point}\;\Varid{emptyRecord}\;(\Numeral{1}\ConSym{::}\TConId{Double}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{2}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p'}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{2.5}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{getX}\rightarrowtail \Varid{print}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p'}\VarSym{\#}\Varid{getX}\rightarrowtail \Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If we were to apply methods of \ensuremath{\Varid{p}} with the wrong type

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Ill-typed}{}\<[E]%
\\
\>[B]{}\Varid{myPolyOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{2.5}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

we get a type error because the type checker expected the argument of \ensuremath{\Varid{moveX}} to have type \ensuremath{\TConId{Int}} but it got a \ensuremath{\TConId{Double}}. The generalization of classes to multiple type parameters is further explored in section \ref{subsec:paraclasses}. 

\subsection{Nested object generators}

\begin{quote}
"The evaluation of the body of a class only takes place at object creation time. Therefore,
in the following example, the instance variable \ensuremath{\Varid{varX}} is initialized to different values for
two different objects.", \emph{section 3.1}
\end{quote}

\begin{OCaml}
let x0 = ref 0;;
class incrementing_point :
  object
    val mutable varX = incr x0; !x0
    method getX      = varX
    method moveX d   = varX <- varX + d
end;;
\end{OCaml}

The variable \ensuremath{\VarId{x_0}} mimics what would be referred to in OO terminology as a \emph{class variable}. The scope of a class variable is not limited to object instances, but as its name suggests ranges over all instances of a particular class. We could model \ensuremath{\VarId{x_0}} as a global variable like in the fragment above. However, we can do much better by using what \oohaskell calls nested object generators.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{makeIncrementingPointClass}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\VarId{x_0}{}\<[10]%
\>[10]{}\leftarrow \Varid{newIORef}\;\Numeral{0}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\mathbin{\$}\lambda \Varid{tail}\to \Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Varid{record}\leftarrow \Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Varid{modifyIORef}\;\VarId{x_0}\;(\VarSym{+}\Numeral{1}){}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Varid{varX}\leftarrow \Varid{readIORef}\;\VarId{x_0}\rightarrowtail \Varid{newIORef}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Varid{return}\;\Conid{Point}\;\{\mskip1.5mu {}\<[E]%
\\
\>[5]{}\hsindent{3}{}\<[8]%
\>[8]{}\Varid{getX}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},\Varid{moveX}{}\<[19]%
\>[19]{}\mathrel{=}\lambda \Varid{d}\to \Varid{modifyIORef}\;\Varid{varX}\;(\VarSym{+}\Varid{d}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},\Varid{\char95 pointTail}\mathrel{=}\Varid{record}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{makeIncrementingPointClass}} consists of two levels: the outer level describes the \emph{class template}, the inner the point class. This is possible because there is nothing preventing us from returning classes instead of object instances. Classes are like objects just values unlike the case in many OO languages where they are special constructs.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myNestedOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{localClass}\leftarrow \Varid{makeIncrementingPointClass}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{localClass}\;\Varid{emptyRecord}\rightarrowtail (\VarSym{\#}\Varid{getX})\rightarrowtail \Varid{print}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{localClass}\;\Varid{emptyRecord}\rightarrowtail (\VarSym{\#}\Varid{getX})\rightarrowtail \Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If we run \ensuremath{\Varid{makeIncrementingPointClass}} it returns a closure over \ensuremath{\VarId{x_0}}. Hence, each time \ensuremath{\Varid{localClass}} is used to create a new instance of \ensuremath{\Conid{Point}} the construction-time computation increments the class variable \ensuremath{\VarId{x_0}}.

\begin{tabbing}\tt
~ghci\char62{}~myNestedOOP\\
\tt ~1\\
\tt ~2
\end{tabbing}

\subsection{Self-referential objects}
\label{subsec:self-ref}

\begin{quote}
"A method or an initializer can send messages to self (that is, the current object). For
that, self must be explicitly bound, here to the variable \ensuremath{\Varid{s}} (\ensuremath{\Varid{s}} could be any identifier, even
though we will often choose the name self.) ... Dynamically, the variable \ensuremath{\Varid{s}} is bound at
the invocation of a method. In particular, when the class printable\_point is inherited,
the variable s will be correctly bound to the object of the subclass.", \emph{section 3.3}
\end{quote}

\begin{OCaml}
class printable_point x_init =
  object (s)
    val mutable varX = x_init
    method getX      = varX
    method moveX d   = varX <- varX + d
    method print     = print_int (s # getX)
end;;
\end{OCaml}

Thus far we have avoided objects wherein methods refer to each other. The ability to refer to other methods inside the object is an essential feature of OO language and is enabled by a special identifier typically called \emph{this} or \emph{self}. The lack of such a special keyword in our encoding leaves us with the question on how we can provide a class with a reference to itself before it is even constructed? An imperative approach to solving this problem would be to use a mutable reference and leave it undefined to just after the object is constructed when it should be fixed with a proper reference to the object. All under the assumption that the self-reference is not touched during object construction as it would lead to undefined behavior. 

We could explicitly write down this process, but fortunately it has already been captured by the \ensuremath{\Varid{fixIO}} combinator \cite{Erkok01semanticsof}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fixIO}\ConSym{::}(\Varid{a}\to \TConId{IO}\;\Varid{a})\to \TConId{IO}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It takes a function that takes as its first argument expects a value of the type that it itself produces. We will use \ensuremath{\Varid{fixIO}} to provide objects with a self-reference. Because object instantiation now consists of two separate actions -- closing record extension, and passing a self-reference -- we capture the act of creating a new object instance inside a combinator:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{new}\;\Varid{o}\mathrel{=}\Varid{fixIO}\mathbin{\$}\Varid{o}\;\Varid{emptyRecord}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We implement the \ensuremath{\Varid{printable\char95 point}} class and have it take a self-reference:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{printable\char95 point}\;\Varid{x\char95 init}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to \Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{varX}{}\<[11]%
\>[11]{}\leftarrow \Varid{newIORef}\;\Varid{x\char95 init}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{PrintablePoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Varid{getX}{}\<[27]%
\>[27]{}\mathrel{=}\Varid{readIORef}\;\Varid{varX}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{moveX}{}\<[27]%
\>[27]{}\mathrel{=}\lambda \Varid{d}\to \Varid{modifyIORef}\;\Varid{varX}\;((\VarSym{+})\;\Varid{d}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{print}{}\<[27]%
\>[27]{}\mathrel{=}(\Varid{self}\VarSym{\#}\Varid{getX})\rightarrowtail \Varid{putStr}\hsdot{\circ }{.}\Varid{show}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{\char95 printablePointTail}{}\<[27]%
\>[27]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that we essentially rely on laziness for this construction to work, \ensuremath{\Varid{self}} should only be accessed in safe positions (inside methods) as premature evaluation would cause the program to crash. We can test the self-reference by invoking \ensuremath{\Varid{print}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mySelfishOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\leftarrow \Keyword{new}\mathbin{\$}\Varid{printable\char95 point}\;\Numeral{3}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{2}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In OO languages it is common practice to call initializer methods on an object inside the constructor. This can be mimicked by wrapping a class and carry out some initialization logic before returning the actual instance:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{printable\char95 point\char95 constructor}\;\Varid{x\char95 init}\;\Varid{tail}\;\Varid{self}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{p}\leftarrow \Varid{printable\char95 point}\;\Varid{x\char95 init}\;\Varid{tail}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{2}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{p}\VarSym{\#}\Varid{print}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Varid{p}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Single inheritance with override}

\begin{quote}
"We illustrate inheritance by defining a class of colored points that inherits from the
class of points. This class has all instance variables and all methods of class point, plus
a new instance variable color, and a new method getColor.", \emph{section 3.7}
\end{quote}
\vspace{10pt}
\begin{OCaml}
class colored_point x (color : string) =
  object
  inherit point x
  val color = color
  method getColor = color
end;;
\end{OCaml}

Inheritance is a technique for sharing behavior between objects. It accomplishes sharing by incrementally extending classes -- better known as subclassing. Often inheritance is confused with the orthogonal question of \emph{substitutability}. Creating a new subclass is not necessarily the same thing as introducing a new subtype \cite{Cook:1989:IS:96709.96721}. Although disparate issues our encoding does not permit the separation of the two, i.e. inheritance necessarily implies subtyping.

The correct implementation of inheritance in combination with self-reference is known to be tricky \cite{Cook89adenotational}. It is crucial that \ensuremath{\Varid{self}} is \emph{late-bound}, i.e. when a class is extended \ensuremath{\Varid{self}} is bound at the latest possible moment such that a subclass may intercept method invocations on \ensuremath{\Varid{self}} in the superclass by overriding its behavior in the subclass. Late-binding is also referred to as \emph{open recursion} conveying the intuition that the actual type of \ensuremath{\Varid{self}} is left \emph{open} until the \emph{recursion} is closed.

The \ensuremath{\Varid{colored\char95 point}} class takes an initial values for \ensuremath{\Varid{x}}, \ensuremath{\Varid{color}}, and an extension of the record.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{colored\char95 point}\;\Varid{x}\;\Varid{color}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{printable\char95 point}\;\Varid{x}\;\Varid{colored\char95 point'}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{colored\char95 point'}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{ColoredPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getColor}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{return}\;\Varid{color}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 coloredPointTail}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Compared to our previous attempt at extending records in section \ref{subsec:tp-records} the object now has access to itself through \ensuremath{\Varid{self}}. Note that the self-reference should not be accessed in unsafe positions, i.e. positions where it is evaluated before the actual object is constructed and the self-reference is fixed. The combination of record extension  \ref{subsec:tp-records} and self-reference \ref{subsec:self-ref} allows us to model a basic form of inheritance:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myColoredOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\leftarrow \Keyword{new}\mathbin{\$}\Varid{colored\char95 point}\;\Numeral{3}\;\Char{\char34 red\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{x}\leftarrow \Varid{p}\VarSym{\#}\Varid{getX}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{c}\leftarrow \Varid{p}\VarSym{\#}\Varid{getColor}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{print}\;(\Varid{x},\Varid{c}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~\char62{}~myColoredOOP\\
\tt ~\char40{}3\char44{}~\char34{}red\char34{}\char41{}
\end{tabbing}

The above code shows that subclassing works, but we have yet to consider overriding methods. To show what is wrong with the approach to overriding methods shown in \oohaskell (section 2.4, p. 22) we adapt \ensuremath{\Varid{colored\char95 point}} by overriding the \ensuremath{\Varid{print}} method.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{colored\char95 point}\;\Varid{x}\;\Varid{color}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to \Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{super}\leftarrow \Varid{printable\char95 point}\;\Varid{x}\;\Varid{colored\char95 point'}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\;\Varid{super}\;\{\mskip1.5mu {}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{print}\mathrel{=}\Keyword{do}\;{}\<[19]%
\>[19]{}\Varid{putStr}\;\Char{\char34 so~far~-~\char34};{}\<[40]%
\>[40]{}\Varid{super}\VarSym{\#}\Varid{print}{}\<[E]%
\\
\>[19]{}\Varid{putStr}\;\Char{\char34 color~-~\char34};{}\<[40]%
\>[40]{}\Varid{putStr}\;(\Varid{show}\;\Varid{color}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{colored\char95 point'}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{ColoredPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getColor}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{return}\;\Varid{color}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 coloredPointTail}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Overriding \ensuremath{\Varid{print}} is done by updating the record that results from constructing a \ensuremath{\Conid{ColoredPoint}}. There are, however, a couple of questionable aspects about this approach. First, referring to the whole record as \ensuremath{\Varid{super}} is not appropriate as \ensuremath{\Varid{super}} should only refer to the parent object. Second, as a side-effect of letting \ensuremath{\Varid{super}} refer to the whole object we cannot refer to \ensuremath{\Varid{super}} in \ensuremath{\Varid{colored\char95 point'}}. Unsatisfied with this approach to overriding methods provided by \oohaskell we continue to explore what it takes to properly model inheritance.

\subsubsection{Deriving the inherit combinator}

One of the key observations in implementing inheritance is that \ensuremath{\Varid{super}} refers to the fully constructed parent object. It exists as such in the scope of the subclass, allowing methods to refer to the \emph{unmodified} parent object, after which it can be opened up to be extended with additional methods, possibly overriding methods of the \ensuremath{\Varid{super}} object. 

For \ensuremath{\Varid{colored\char95 point}} this means that we first instantiate its parent \ensuremath{\Varid{printable\char95 point}} with the \ensuremath{\Varid{emptyRecord}} which results in a binding to \ensuremath{\Varid{super}} that part-takes in the construction of \ensuremath{\Varid{colored\char95 point'}}. Then the \ensuremath{\Varid{print}} method is overridden and the \ensuremath{\Varid{emptyRecord}} is replaced with the \ensuremath{\Conid{ColoredPoint}} extension containing all additional methods and data. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}c<{\hspost}@{}}%
\column{39E}{@{}l@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{colored\char95 point}\;\Varid{x}\;\Varid{color}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to \Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{super}{}\<[13]%
\>[13]{}\leftarrow \Varid{printable\char95 point}\;\Varid{x}\;\Varid{emptyRecord}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{wrapper}{}\<[13]%
\>[13]{}\leftarrow \Varid{colored\char95 point'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\;\Varid{super}\;\{\mskip1.5mu {}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{print}\mathrel{=}\Keyword{do}\;{}\<[19]%
\>[19]{}\Varid{putStr}\;\Char{\char34 so~far~-~\char34}{}\<[39]%
\>[39]{};{}\<[39E]%
\>[42]{}\Varid{super}\VarSym{\#}\Varid{print}{}\<[E]%
\\
\>[19]{}\Varid{putStr}\;\Char{\char34 color~-~\char34}{}\<[39]%
\>[39]{};{}\<[39E]%
\>[42]{}\Varid{putStr}\;\Varid{color}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{},\Varid{\char95 printablePointTail}\mathrel{=}\Varid{wrapper}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{colored\char95 point'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{ColoredPoint}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getColor}{}\<[30]%
\>[30]{}\mathrel{=}{}\<[E]%
\\
\>[11]{}\hsindent{2}{}\<[13]%
\>[13]{}\Keyword{do}\;{}\<[17]%
\>[17]{}\Varid{x}\leftarrow \Varid{super}\VarSym{\#}\Varid{getX}{}\<[E]%
\\
\>[17]{}\Varid{putStrLn}\;(\Char{\char34 Retrieving~color~at:~\char34}\plus \Varid{show}\;\Varid{x}){}\<[E]%
\\
\>[17]{}\Varid{return}\;\Varid{color}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 coloredPointTail}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Because we use normal records the process of overriding and extending becomes somewhat entangled. 

Cook et al. \cite{Cook89adenotational} show how inheritance can be modeled using a combinator $\rhd$ defined in the lambda calculus. They proof its correctness with respect to the operational semantics of a commonly used OO method-lookup algorithm. 
\[
\rhd : (Wrapper \times Generator) \rightarrow Generator
\]
\[
W \rhd G = \lambda self. (W(self) (G(self))) \oplus G(self)
\]

The combinator takes a wrapper, generator, and builds a new generator by distributing the self-reference to both the generator and wrapper. It passes a generator applied to self as super to the wrapper, and combines the two using $\oplus$ forming a new generator. That the two instances of the generator applied to self are shared is left implicit, but is made clear by the visualization in figure \ref{fig:inheritancewrapper}.

\begin{figure}[h]
\center
\includegraphics[scale=.3]{resources/inheritance.png}
\caption{A visualization of the inheritance combinator ($\rhd$) taken from \cite{Cook89adenotational}.}
\label{fig:inheritancewrapper}
\end{figure}

It turns out that \ensuremath{\Varid{colored\char95 point}} is a concrete instantiation of Cook's $\rhd$ combinator obfuscated by technicalities caused by the use of records and IO monad. To make this correspondence clear we reify the combinator as the \ensuremath{\Keyword{extends}} Haskell function, but first we define a couple of type synonyms that will make the type signature easier to digest:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{60}{@{}>{\hspre}l<{\hspost}@{}}%
\column{66}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Class}\;{}\<[19]%
\>[19]{}\Varid{tail}\;{}\<[25]%
\>[25]{}\Varid{self}\;{}\<[31]%
\>[31]{}\Varid{o}{}\<[40]%
\>[40]{}\mathrel{=}\Varid{tail}\to \Varid{self}\to \Varid{o}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{EmptyClass}{}\<[40]%
\>[40]{}\mathrel{=}\TConId{IO}\;{}\<[48]%
\>[48]{}(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{OpenClass}\;{}\<[19]%
\>[19]{}\Varid{tail}\;{}\<[25]%
\>[25]{}\Varid{self}\;{}\<[31]%
\>[31]{}\Varid{o}{}\<[40]%
\>[40]{}\mathrel{=}\Conid{Class}\;(\TConId{IO}\;\Varid{tail})\;{}\<[60]%
\>[60]{}\Varid{self}\;{}\<[66]%
\>[66]{}(\TConId{IO}\;\Varid{o}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{SuperClass}\;{}\<[19]%
\>[19]{}\Varid{self}\;{}\<[25]%
\>[25]{}\Varid{sup}{}\<[40]%
\>[40]{}\mathrel{=}\Conid{Class}\;\Conid{EmptyClass}\;{}\<[60]%
\>[60]{}\Varid{self}\;{}\<[66]%
\>[66]{}(\TConId{IO}\;\Varid{sup}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{SubClass}\;{}\<[19]%
\>[19]{}\Varid{tail}\;{}\<[25]%
\>[25]{}\Varid{sup}\;{}\<[31]%
\>[31]{}\Varid{self}\;{}\<[37]%
\>[37]{}\Varid{o}{}\<[40]%
\>[40]{}\mathrel{=}\Varid{tail}\to \Varid{super}\to \Varid{self}\to \TConId{IO}\;\Varid{sub}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Keyword{extends}} combinator takes a few more parameters than $\rhd$. Since we cannot define a generic operation for record concatenation (as \oohaskell does) we parameterize over it using $\oplus$. Furthermore, for syntactic purposes we have not combined \ensuremath{\Varid{override}} and $\oplus$ into a single operation.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}c<{\hspost}@{}}%
\column{6E}{@{}l@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{extends}\ConSym{::}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}\Conid{SubClass}\;{}\<[22]%
\>[22]{}\Varid{tail}\;{}\<[28]%
\>[28]{}\Varid{sup}\;{}\<[34]%
\>[34]{}\Varid{self}\;\Varid{sub}{}\<[46]%
\>[46]{}\Comment{  -{}-\enskip  w}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[6E]%
\>[10]{}\Conid{SuperClass}\;{}\<[22]%
\>[22]{}\Varid{self}\;{}\<[28]%
\>[28]{}\Varid{sup}{}\<[46]%
\>[46]{}\Comment{  -{}-\enskip  g}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[6E]%
\>[10]{}(\Varid{sup}{}\<[17]%
\>[17]{}\to \Varid{self}{}\<[32]%
\>[32]{}\to \TConId{IO}\;\Varid{sup'}){}\<[46]%
\>[46]{}\Comment{  -{}-\enskip  override}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[6E]%
\>[10]{}(\Varid{sup'}{}\<[17]%
\>[17]{}\to \Varid{sub}{}\<[32]%
\>[32]{}\to \Varid{o}){}\<[46]%
\>[46]{}\Comment{  -{}-\enskip  combine subclass and superclass}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[6E]%
\>[10]{}\Conid{OpenClass}\;{}\<[22]%
\>[22]{}\Varid{tail}\;{}\<[28]%
\>[28]{}\Varid{self}\;{}\<[34]%
\>[34]{}\Varid{o}{}\<[E]%
\\
\>[B]{}\Keyword{extends}\;\Varid{w}\;\Varid{g}\;\Varid{override}\;\oplus\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to \Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{super}{}\<[12]%
\>[12]{}\leftarrow \Varid{g}\;\Varid{emptyRecord}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{wrapper}{}\<[12]%
\>[12]{}\leftarrow \Varid{w}\;\Varid{tail}\;\Varid{super}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{super'}{}\<[12]%
\>[12]{}\leftarrow \Varid{override}\;\Varid{super}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\mathbin{\$}\Varid{super'}\mathbin{`\oplus`}\Varid{wrapper}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can now express \ensuremath{\Varid{colored\char95 point}} in terms of \ensuremath{\Keyword{extends}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}c<{\hspost}@{}}%
\column{39E}{@{}l@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{colored\char95 point}\;\Varid{x}\;\Varid{color}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{wrapper}\mathbin{`\Keyword{extends}`}\Varid{printable\char95 point}\;\Varid{x})\;\Varid{override}\;(\lambda \Varid{o}\;\Varid{v}\to \Varid{o}\;\{\mskip1.5mu \Varid{\char95 printablePointTail}\mathrel{=}\Varid{v}\mskip1.5mu\}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{override}\;\Varid{super}\;\Varid{self}\mathrel{=}\Varid{return}\;\Varid{super}\;\{\mskip1.5mu {}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{print}\mathrel{=}\Keyword{do}\;{}\<[19]%
\>[19]{}\Varid{putStr}\;\Char{\char34 so~far~-~\char34}{}\<[39]%
\>[39]{};{}\<[39E]%
\>[42]{}\Varid{super}\VarSym{\#}\Varid{print}{}\<[E]%
\\
\>[19]{}\Varid{putStr}\;\Char{\char34 color~-~\char34}{}\<[39]%
\>[39]{};{}\<[39E]%
\>[42]{}\Varid{putStr}\;\Varid{color}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{wrapper}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{ColoredPointClass}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getColor}\mathrel{=}\Keyword{do}\;{}\<[27]%
\>[27]{}\Varid{x}\leftarrow \Varid{super}\VarSym{\#}\Varid{getX}{}\<[E]%
\\
\>[27]{}\Varid{putStrLn}\;(\Char{\char34 Retrieving~color~at:~\char34}\plus \Varid{show}\;\Varid{x}){}\<[E]%
\\
\>[27]{}\Varid{return}\;\Varid{color}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 coloredPointTail}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

and demonstrate it through a simple example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myOverridingOOP}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\leftarrow \Keyword{new}\mathbin{\$}\Varid{colored\char95 point}\;\Numeral{3}\;\Char{\char34 red\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{getColor}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~\char62{}myOverridingOOP\\
\tt ~Retrieving~color~at~position\char58{}~3\\
\tt ~so~far~\char45{}~3~color~\char45{}~\char34{}red\char34{}
\end{tabbing}

Sometimes you might want to override existing methods without adding new ones. This form of anonymous overriding is also possible:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{colored\char95 point'}\;\Varid{x\char95 init}\;\Varid{color}\;\Varid{tail}\;\Varid{self}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{super}\leftarrow \Varid{colored\char95 point}\;\Varid{x\char95 init}\;\Varid{color}\;\Varid{tail}\;\Varid{self}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\mathbin{\$}\Varid{super}\;\{\mskip1.5mu {}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{print}\mathrel{=}\Varid{putStr}\;\Char{\char34 I'm~a~colored~point\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Class-polymorphic functionality}

Because classes are just values we can parameterize computations over classes.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}c<{\hspost}@{}}%
\column{10E}{@{}l@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Optional type}{}\<[E]%
\\
\>[B]{}\Varid{myFirstClassOOP}\ConSym{::}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\TClassId{Num}\;\Varid{a}{}\<[10]%
\>[10]{}\Rightarrow {}\<[10E]%
\>[14]{}(\Varid{a}\to \TConId{IO}\;(\Conid{PrintablePoint}\;\Varid{b}\to ()){}\<[E]%
\\
\>[14]{}\hsindent{3}{}\<[17]%
\>[17]{}\to \Conid{PrintablePoint}\;\Varid{b}{}\<[E]%
\\
\>[14]{}\hsindent{3}{}\<[17]%
\>[17]{}\to \TConId{IO}\;(\Conid{PrintablePoint}\;\Varid{b})){}\<[E]%
\\
\>[10]{}\to {}\<[10E]%
\>[14]{}\TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{myFirstClassOOP}\;\Varid{point\char95 class}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\leftarrow \Keyword{new}\mathbin{\$}\Varid{point\char95 class}\;\Numeral{7}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{moveX}\mathbin{\$}\Numeral{35}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{p}\VarSym{\#}\Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Any subclass of \ensuremath{\Conid{PrintablePoint}} may be passed into \ensuremath{\Varid{myFirstClassOOP}}.

\begin{tabbing}\tt
~ghci\char62{}myFirstClassOOP~printable\char95{}point\\
\tt ~42\\
\tt ~\\
\tt ~ghci\char62{}myFirstClassOOP~\char40{}flip~colored\char95{}point\char39{}~\char34{}red\char34{}\char41{}\\
\tt ~so~far~\char45{}~42~color~\char45{}~red
\end{tabbing}

\subsection{Orphan methods}

Orphan methods are methods which can be shared between classes without relying on inheritance -- a kind of horizontal reuse. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{print\char95 getX}\;\Varid{self}\mathrel{=}(\Varid{self}\VarSym{\#}\Varid{getX})\rightarrowtail \Varid{\ModId{Prelude}.print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{print\char95 getX}} function can be applied to any subclass of \ensuremath{\Conid{PrintablePoint}}. In \oohaskell its type would be much more granular and hence work for any class that supports the \ensuremath{\Varid{getX}} method. We can get some of the structural behavior of \oohaskell by introducing a type class per method and overload the method on its object type. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{HasGetX}\;\Varid{o}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{callGetX}\ConSym{::}\Varid{o}\to \TConId{IO}\;\TConId{Int}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{HasGetX}\;(\Conid{PrintablePoint}\;\Varid{t})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{callGetX}\mathrel{=}\Varid{getX}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{print\char95 getX}\;\Varid{self}\mathrel{=}(\Varid{self}\VarSym{\#}\Varid{callGetX})\rightarrowtail \Varid{\ModId{Prelude}.print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

On occasions this might be useful, but it requires significant boilerplate and quickly runs into ambiguity problems for methods with polymorphic arguments.

\section{A type-perspective}
\label{sec:ty-per}

\subsection{Explicit casting}
\label{subsec:casting}

Up to this point we have avoided the issue of ascribing a value a different type based on its relationship in the subtyping hierarchy. Type ascription in the presence of subtyping is commonly known as casting. Given a value of type \ensuremath{\Conid{X}}, ascribing it a supertype is referred to as an upcast, whereas ascribing it a subtype is referred to as a downcast. The former allows \ensuremath{\Conid{X}} to be \emph{viewed} as its supertype and can therefore be regarded as a form of abstraction or \emph{elimination}. The latter can be viewed as a form of \emph{introduction} and is arguably more involved since it needs to recover from potentially hidden information. 

We will focus on single inheritance where each subtype has a single supertype:

\begin{tikzpicture}
  \tikzstyle{all nodes}=[inner sep=4pt,font=\scriptsize,scale=2]
  \node            (t) at (1,2)  { ... };
  \node            (td) at (4,2) { supertype };
  \node            (x) at (1,1)  { X };
  \node            (xs1) at (0,0) { ... };
  \node            (xs2) at (1,0) { ... };
  \node            (xs3) at (2,0) { ... };
  \node            (xsd) at (4,0) { subtype };
  \draw[->,thick] (x) edge (t);
  \draw[<-,dashed,thick] (xs1) edge (x);
  \draw[<-,dashed,thick] (xs2) edge (x);
  \draw[<-,dashed,thick] (xs3) edge (x);
\end{tikzpicture}

To illustrate why we need casting we show a typical OO scenario where two objects of different types, related by subtyping, are placed inside a list containing only elements of their supertype. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{let}\;{}\<[6]%
\>[6]{}\Varid{rect}{}\<[14]%
\>[14]{}\mathrel{=}\VarSym{...}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;()){}\<[E]%
\\
\>[6]{}\Varid{circle}{}\<[14]%
\>[14]{}\mathrel{=}\VarSym{...}\ConSym{::}\Conid{IShape}\;(\Conid{ICircle}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Suppose that we insert both shapes into a list:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}[\mskip1.5mu \Varid{rect},\Varid{circle}\mskip1.5mu]\Comment{  -{}-\enskip  Type error}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The result is a type error, because the two type element types do not unify. What we actually want is that the type system infers the more general type \ensuremath{\Conid{IShape}\;\Varid{a}}, but this would imply that it has some notion of subtyping and allow universal quantification over monomorphic values at the covariant position, neither of which are the case.

There are two options to make it work either change the type of list elements, or change the type of the elements inserted into the list. The former leads to more idiomatic Haskell and has two basic options: use \ensuremath{\TConId{Either}}, or an existential envelope.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Either}{}\<[E]%
\\
\>[B]{}[\mskip1.5mu L\;\Varid{rect},R\;\Varid{circle}\mskip1.5mu]\ConSym{::}[\mskip1.5mu \TConId{Either}\;(\Conid{IShape}\;(\Conid{IRectangle}\;()))\;(\Conid{IShape}\;(\Conid{ICircle}\;()))\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using \ensuremath{\TConId{Either}} requires tagging \ensuremath{\Varid{rect}} and \ensuremath{\Varid{circ}} with respectively \ensuremath{L} and \ensuremath{R}. It is the simplest solution and leaves the original types intact. That the original types are kept intact is at the same time one of the problems. We can construct the list, but we cannot pass it to a function that expects a list of any shape. Also, when generalizing to $n$ distinct types operations like injection, projection, and mapping become more involved.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Existential envelope}{}\<[E]%
\\
\>[B]{}[\mskip1.5mu \Varid{rect},\Varid{cirlce}\mskip1.5mu]\ConSym{::}[\mskip1.5mu \exists \Varid{a}\hsexists \hsdot{\circ }{.}\Conid{IShape}\;\Varid{a}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using existentials we can take advantage of the tail-polymorphic structure and hide the tail of a record by existentially quantifying over it. Now we can simply insert any subtype of \ensuremath{\Conid{IShape}} inside a list without further ado. However, plain existentials cannot not recover from the existentially quantified information. In section \ref{subsec:selfret} we will see how in combination with explicit casting we can mitigate the loss of information. 

Neither approach is satisfactory. \oohaskell uses yet another approach to insert elements into the list where it circumvents unification problems by explicitely changing the type of list elements before they are inserted. Their type is modified by using a narrowing function that \emph{shops off} the tail.

The narrowing function for shapes is defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Specific narrowing function}{}\<[E]%
\\
\>[B]{}\Varid{up\char95 shape}{}\<[11]%
\>[11]{}\ConSym{::}\Conid{IShape}\;\Varid{a}\to \Conid{IShape}\;(){}\<[E]%
\\
\>[B]{}\Varid{up\char95 shape}\;\Varid{o}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}()\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It takes \emph{at least} a shape, opens up the object, and throws out the tail replacing it with the \ensuremath{\Varid{emptyRecord'}}. We can use \ensuremath{\Varid{up\char95 shape}} as a helper to insert \ensuremath{\Varid{rect}} and \ensuremath{\Varid{circle}} into a list of shapes. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}[\mskip1.5mu \Varid{up\char95 shape}\;\Varid{rect},\Varid{up\char95 shape}\;\Varid{circle}\mskip1.5mu]\ConSym{::}[\mskip1.5mu \Conid{IShape}\;()\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Even though it provides a working solution it appears to be even less useful compared to existentials. It accomplishes the same thing with more boilerplate for the necessarily type specific record manipulation, a run-time overhead for performing the actual record manipulation, and requires knowledge of the whereabouts of the narrowing functions. Furthermore, similar to existentials it does not admit downcasting because it simply throws out information that may later be required to perform a downcast. 

In the following sections we will improve upon the above techniques by implementing generic functions for up and downcasting. We use type classes for automatically generating the type conversion functions and dynamic typing for hiding the tail instead of deposing it. The use of dynamic types allows a downcast to reconstruct the original types.

\subsubsection{Generic upcast}
\label{subsub:upcast}

An upcast is a function that when given a source (subtype) and target (supertype) type provides unique directed-path through the subtyping hierarchy from source to target type composed of the smallest possible narrowing steps that allow it to move along the edges of the path. 

Although \ensuremath{\Varid{up\char95 shape}} conceptually corresponds to such a path its implementation does not. In order to implement a generic upcast function we need a more compositional approach that is explicit about the constituents of the path.

Suppose we want to upcast a \emph{Cube} to a \emph{Shape} obtaining a more explicit version than:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{from\char95 cube\char95 to\char95 shape}\mathrel{=}\Varid{up\char95 shape}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

requires that we follow the edges in figure \ref{fig:upcast-exp} from \emph{Cube} to \emph{Shape}. The labels on the edges are functions that allow us to transition from one vertex to the other.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{up\char95 rectangle}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;())\to \Conid{IShape}\;(){}\<[E]%
\\
\>[B]{}\Varid{up\char95 rectangle}\;\Varid{o}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}()\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{up\char95 circle}\ConSym{::}\Conid{IShape}\;(\Conid{ICircle}\;())\to \Conid{IShape}\;(){}\<[E]%
\\
\>[B]{}\Varid{up\char95 circle}\;\Varid{o}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}()\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{up\char95 cube}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;(\Conid{ICube}\;()))\to \Conid{IShape}\;(\Conid{IRectangle}\;()){}\<[E]%
\\
\>[B]{}\Varid{up\char95 cube}\;\Varid{o}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}\Varid{\char95 shapeTail}\;\Varid{o}\;\{\mskip1.5mu \Varid{\char95 rectangleTail}\mathrel{=}()\mskip1.5mu\}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The explicit version of \ensuremath{\Varid{from\char95 cube\char95 to\char95 shape}} mentioning all labels in the path is given by:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{from\char95 cube\char95 to\char95 shape}\mathrel{=}\Varid{up\char95 rectangle}\hsdot{\circ }{.}\Varid{up\char95 cube}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{figure}
\begin{tikzpicture}[level distance=15mm,level/.style={sibling distance=40mm/#1}, font={\small}]
\node {IShape ()}
  child {
    node[] {... (IRectangle ())} {
      child {
        node {
          ... (ICube ()))
        }
        edge from parent[<-,thick]
          node [right] {up\_cube}
      } 
    } 
    edge from parent[<-,thick] 
      node [midway,left] {up\_rectangle}
  }
  child {
    node {... (ICircle ())} {
      child {
        node [below] {$\vdots$}
      }
    }
    edge from parent[<-]
      node [right] {up\_circle}
  }
  child {node[below] {$\vdots$}};
  \draw[<-] (-7,0) -- (-7,-4) node[midway,below,sloped] {up\_shape};
\end{tikzpicture}
\caption{The shapes subtyping hierarchy where the edges are annotated with narrowing functions.}
\label{fig:upcast-exp}
\end{figure}

Where \ensuremath{\Varid{up\char95 shape}} allowed us to take a shortcut the explicit version does not. It requires $N$ record manipulations, where

$N = \dfrac{1}{2}(n_s - n_t)(n_t + n_s - 1)$

and $n_s$, $n_t$ are respectively the depth of the source and target type with $n \geq 1$. Thus instead of a single record manipulation with \ensuremath{\Varid{up\char95 shape}} it requires 3 record manipulations. Clearly, the explicit approach is less efficient but the effect is somewhat mitigated by the fact that $n$ is bounded by the subtyping depth which in practice is quite limited.

Manually writing functions like \ensuremath{\Varid{from\char95 cube\char95 to\char95 shape}} is tedious, not generic, and hence offers no benefits over just using \ensuremath{\Varid{up\char95 shape}}. The possibility to explicitly specify the path only turns into a benefit when we can craft a function that will automatically create the path for us provided with a source and target type. This is exactly what we aim for. A generic upcast function should therefore: given a source and target type automatically create the path between source and target by decomposing it into individual narrowing steps.

Because the behavior of an upcast depends on both the source and target type we model it using a multi-parameter type class\footnote{We use \ensuremath{\Conid{TypeOperators}} solely for stylistic purposes.}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\alpha \TClassId{$\ \prec\ $} \beta\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}\ConSym{::}\alpha\to \beta{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type class reads: if \ensuremath{\alpha} is a \emph{subtype} of \ensuremath{\beta}, there exists an \ensuremath{\Varid{upcast}} operation which can be used to cast a value of type \ensuremath{\alpha} into value of type \ensuremath{\beta}. 

In order for this proposition to hold we rely on the essential property that each subclass can be interpreted as a new subtype, and thus walking over the type structure implies walking over the subtyping hierarchy. 

\begin{figure}[h!]
    \begin{centering}
        $ [$\emph{reflexivity}$] $ \inference{}
        {
        A <: A
        }
        \\
        \vspace*{10pt}
        $ [$\emph{transitivity}$] $ \inference{
          A <: B &   B <: C
        }
        {
        A <: C
        }
    \caption{Typing rules for the subtyping relation.}
    \label{fig:subtyping-rules}
    \end{centering}
\end{figure}

The rules that decide whether two types are related by subtyping are shown in Figure \ref{fig:subtyping-rules}. It is well-known that these type rules do not directly translate into an algorithmic implementation because it is not clear when they should be applied. In other words, they are not \emph{syntax directed} (see Chapter 16 \cite{tpl}).

It turns out that if we limit the inhabitants of the \ensuremath{ \TClassId{$\ \prec\ $} } type class to first-order values with a tail-polymorphic structure we can obtain a syntax directed version of the typing rules. Instance declarations then correspond to the typing rules which through context reduction provide the compiler with evidence on whether two types are related by subtyping. 

We use the `shapes` example in a first attempt at translating the typing rules to instance declarations on a \emph{per type} basis, i.e. introducing new instance declaration for each new type. The reflexivity rule is trivially implemented by the identity function, because upcasting a value to itself has no effect.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}c<{\hspost}@{}}%
\column{41E}{@{}l@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{71}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Reflexivity}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Conid{IShape}\;(){}\<[41]%
\>[41]{} \TClassId{$\ \prec\ $} {}\<[41E]%
\>[46]{}\Conid{IShape}\;()\;{}\<[71]%
\>[71]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Conid{IShape}\;(\Conid{IRectangle}\;()){}\<[41]%
\>[41]{} \TClassId{$\ \prec\ $} {}\<[41E]%
\>[46]{}\Conid{IShape}\;(\Conid{IRectangle}\;())\;{}\<[71]%
\>[71]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Conid{IShape}\;(\Conid{ICircle}\;()){}\<[41]%
\>[41]{} \TClassId{$\ \prec\ $} {}\<[41E]%
\>[46]{}\Conid{IShape}\;(\Conid{ICircle}\;())\;{}\<[71]%
\>[71]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that we need to lift a Haskell 98 restriction which requires the shape of an instance head to be of the form \ensuremath{\Conid{C}\;(\Conid{T}\;\VarId{a_1}\VarSym{...}\VarId{a_n})}, where \ensuremath{\Conid{C}} is designates the class, \ensuremath{\Conid{T}} a data type constructor, and \ensuremath{\VarId{a_1},\VarSym{...},\VarId{a_n}} a set of distinct type variables. We lift it to arbitrary nested types by enabling the \ensuremath{\Conid{FlexibleInstances}} extension.

Next, we implement transitivity for \emph{Rectangle} and \emph{Circle}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{58}{@{}>{\hspre}c<{\hspost}@{}}%
\column{58E}{@{}l@{}}%
\column{63}{@{}>{\hspre}l<{\hspost}@{}}%
\column{72}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Transitivity}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;(\Conid{IShape}\;() \TClassId{$\ \prec\ $} \beta)\Rightarrow \Conid{IShape}\;(\Conid{IRectangle}\;()){}\<[58]%
\>[58]{} \TClassId{$\ \prec\ $} {}\<[58E]%
\>[63]{}\beta\;{}\<[72]%
\>[72]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{upcast}\hsdot{\circ }{.}\Varid{up\char95 rectangle}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\Conid{IShape}\;() \TClassId{$\ \prec\ $} \beta)\Rightarrow \Conid{IShape}\;(\Conid{ICircle}\;()){}\<[58]%
\>[58]{} \TClassId{$\ \prec\ $} {}\<[58E]%
\>[63]{}\beta\;{}\<[72]%
\>[72]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{upcast}\hsdot{\circ }{.}\Varid{up\char95 circle}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The transitivity instances embed a single narrowing step and delegate further work to other instance declarations. We can now perform a generic upcast without knowing about the specifics of narrowing functions. The solution also allows for easy extension to new object types by simply adding another instance for reflexivity and transitivity. 

To illustrate what happens at compile-time we let the system automatically derive \ensuremath{\Varid{from\char95 cube\char95 to\char95 shape}} for us:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{let}\;\Varid{cube}\mathrel{=}\VarSym{...}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;(\Conid{ICube}\;())){}\<[E]%
\\
\>[B]{}\Keyword{in}\;\Varid{upcast}\;\Varid{cube}\ConSym{::}\Conid{IShape}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The compiler builds up a proof tree for each application of \ensuremath{\Varid{upcast}} proving that the source and target type are related by subtyping thereby also ruling out silly casts (i.e. casts between two unrelated types). Here is the proof tree derived by the context reduction machinery for the above example:

\begin{prooftree}
  \AxiomC{}
  \LeftLabel{\scriptsize [refl-shape]}
  \UnaryInfC{\ensuremath{\Conid{IShape}\;() \TClassId{$\ \prec\ $} \Conid{IShape}\;()}}
  \AxiomC{$\cdots$}
  \LeftLabel{\scriptsize [trans-rect]}
  \BinaryInfC{\ensuremath{\Conid{IShape}\;(\Conid{IRectangle}\;()) \TClassId{$\ \prec\ $} \Conid{IShape}\;()}}
  \AxiomC{$\cdots$}
\LeftLabel{\scriptsize [trans-cube]}
\BinaryInfC{\ensuremath{\Varid{upcast}\;\Varid{cube}\ConSym{::}\Conid{IShape}\;()}}
\end{prooftree}

The value produced by the proof should look familiar. It corresponds to the \newline \ensuremath{\Varid{from\char95 cube\char95 to\char95 shape}} function except that at the end it includes the identify function as a residue of the recursion.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{id}\hsdot{\circ }{.}\Varid{up\char95 rectangle}\hsdot{\circ }{.}\Varid{up\char95 cube}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\equiv\;{}\<[8]%
\>[8]{}\Comment{\{-\enskip  left-identity \enskip-\}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{up\char95 rectangle}\hsdot{\circ }{.}\Varid{up\char95 cube}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\equiv\;{}\<[8]%
\>[8]{}\Comment{\{-\enskip  by definition \enskip-\}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{from\char95 cube\char95 to\char95 shape}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There are quite some subtleties involved in the transitivity case. First, we need two additional language extensions \ensuremath{\Conid{FlexibleContexts}} and \ensuremath{\Conid{OverlappingInstances}}. The former does the same for the context as \ensuremath{\Conid{FlexibleInstances}} does for the head. The latter is necessary because \ensuremath{\beta} makes the transitive and reflexive case overlap. Fortunately, this is a harmless case of overlapping instances as it does not lead to any difficulties in determining the most specific instance which can still be determined by solely looking at the instance head. Leaving \ensuremath{\beta} polymorph allows the recursive call to \ensuremath{\Varid{upcast}} to pick either another transitive instance or bottom out the recursion at the reflexive instance. This is necessarily the case because the choice on which instance to pick is determined by the instantiation of \ensuremath{\beta} at the call site.

\emph{Pushing it a bit further}

While the \emph{instance per new subclass/subtype} approach works its dependence on concrete types requires an unnecessary amount of instances for classes with essentially the same type \emph{structure} (see \emph{Circle} and \emph{Rectangle}). A much better approach would be to abstract over the concrete types. As a consequence the problem of providing instance declarations shifts from \emph{per new subclass} to \emph{per increase in the depth of the subtyping hierarchy}. Fortunately, this is not that much of a problem because the depth of a subtyping hierarchy is in practice often quite limited.

We refactor the previous instance declarations, replacing the concrete types with type variables, but leaving the structure intact. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  depth 1: reflexivity}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Varid{c}\;() \TClassId{$\ \prec\ $} \Varid{c}\;()\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For each subsequent increase in depth we add an instance for both reflexivity and transitivity.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  depth 2}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \prec\ $} \Varid{a}\;(\Varid{b}\;())\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\Varid{a}\;() \TClassId{$\ \prec\ $} \Varid{x})\Rightarrow \Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \prec\ $} \Varid{x}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{upcast}\hsdot{\circ }{.}(\VarSym{?}\ConSym{::}\Varid{a}\;(\Varid{b}\;())\to \Varid{a}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  depth 3}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Varid{a}\;(\Varid{b}\;(\Varid{c}\;())) \TClassId{$\ \prec\ $} \Varid{a}\;(\Varid{b}\;(\Varid{c}\;()))\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{id}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \prec\ $} \Varid{x})\Rightarrow \Varid{a}\;(\Varid{b}\;(\Varid{c}\;())) \TClassId{$\ \prec\ $} \Varid{x}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{upcast}\hsdot{\circ }{.}(\VarSym{?}\ConSym{::}\Varid{a}\;(\Varid{b}\;(\Varid{c}\;()))\to \Varid{a}\;(\Varid{b}\;())){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By abstracting over the concrete types we gained some expressive power, but lost some information. We no longer know which narrowing functions should be called at the position of the question mark. In order to capture the specific narrowing functions we introduce a new type class \ensuremath{\TClassId{Narrow}}. It allows us to defer the decision on what concrete narrowing function to use to the call site.

The \ensuremath{\TClassId{Narrow}} type class captures the set of specific narrowing functions.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\TClassId{Narrow}\;\alpha\;\beta\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{narrow}\ConSym{::}\alpha\to \beta{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We augment the transitivity instances with an additional \ensuremath{\TClassId{Narrow}} constraint, and replace the question marks with calls to the \ensuremath{\Varid{narrow}} function. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Depth 2: add a Narrow constraint}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;(\Varid{a}\;() \TClassId{$\ \prec\ $} \Varid{x},\TClassId{Narrow}\;(\Varid{a}\;(\Varid{b}\;()))\;(\Varid{a}\;()))\Rightarrow \Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \prec\ $} \Varid{x}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{upcast}\mathrel{=}\Varid{upcast}\hsdot{\circ }{.}(\Varid{narrow}\ConSym{::}\Varid{a}\;(\Varid{b}\;())\to \Varid{a}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  From rectangle to shape}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\TClassId{Narrow}\;(\Conid{IShape}\;(\Conid{IRectangle}\;()))\;(\Conid{IShape}\;())\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{narrow}\mathrel{=}\Varid{up\char95 rectangle}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is important that the type variables in the head of the transitivity instance match those annotating the \ensuremath{\Varid{narrow}} function. We use the \ensuremath{\Conid{ScopedTypeVariables}} extension to bring the type variables in the head into scope such that they may be reused in the body of \ensuremath{\Varid{upcast}}. Furthermore, by adding the \ensuremath{\TClassId{Narrow}} constraint the Paterson Conditions no longer hold, i.e. the context is no longer smaller than the instance head\footnote{For more details see: \url{http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/type-class-extensions.html\#instance-rules}}. To lift this restriction we must enable \ensuremath{\Conid{UndecidableInstances}} with which termination of context reduction process is no longer guaranteed. Fortunately, this causes no problems because we can tell by our instance definitions that there is no possibility to send the context reduction into an infinite loop. 

The subtype type class has some interesting behavior, different from what one might intuitively expect from subtyping:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{foo}\;\Varid{c}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;{}\<[8]%
\>[8]{}\Varid{c'}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{upcast}\;\Varid{c}\ConSym{::}\Conid{A}\;(\Conid{B}\;(\Conid{C}\;())){}\<[E]%
\\
\>[8]{}\Varid{b}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{upcast}\;\Varid{c}\ConSym{::}\Conid{A}\;(\Conid{B}\;()){}\<[E]%
\\
\>[8]{}\Varid{a}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{upcast}\;\Varid{c}\ConSym{::}\Conid{A}\;(){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

On basis of subtyping one might expect the type of \ensuremath{\Varid{foo}} to correspond to: 

\ensuremath{\Varid{foo}\ConSym{::}(\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;(\Conid{B}\;(\Conid{C}\;())))\Rightarrow \Varid{a}\to ()}

since both \ensuremath{\Varid{b}} and \ensuremath{\Varid{a}} are included in \ensuremath{\Conid{A}\;(\Conid{B}\;(\Conid{C}\;()))}. However, the actual type of \ensuremath{\Varid{foo}} corresponds to:

\ensuremath{\Varid{foo}\ConSym{::}(\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;(),\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;(\Conid{B}\;()),\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;(\Conid{B}\;(\Conid{C}\;())))\Rightarrow \Varid{a}\to ()}

Each call to \ensuremath{\Varid{upcast}} contributes a constraint to the context. However, the context reduction machinery is not aware of the subtyping rules and therefore cannot reduce the constraint set to \ensuremath{\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;(\Conid{B}\;(\Conid{C}\;()))}. This is not erroneous nor does it affect the behavior of \ensuremath{\Varid{foo}}, but for a clean type signature we must perform the context reduction in our head and provide \ensuremath{\Varid{foo}} with an explicit type signature.

\subsubsection{Generic downcast}
\label{subsec:down}

A downcast is the partial inverse of upcast. Its partial because it \emph{attempts} to restore type information whilst admitting the possibility of failure in case the expected type does not correspond to the actual type.

The problem with the current implementation of \ensuremath{\Varid{upcast}} is that the individual narrowing steps throw away the tail making it impossible to later restore it with a downcast. In order to facilitate downcasts the tail needs to be somehow maintained without having it surface in the type. A known technique for hiding types is existential quantification. However, using plain existentials we cannot recover from the hidden information. The \ensuremath{\Conid{Data}.\TConId{Dynamic}} library does allow hidden types to be restored by testing on type equality between the run-time type representations of the hidden value and its expected type. If the value's type matches the expected type it provides proof that the hidden value may safely be recovered from as the expected type.

Before implementing downcast we fix the tail representation by wrapping it inside a new data type \ensuremath{\Conid{Record}} such that an upcast can hide the tail.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  A wrapper for the tail}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Record}\;\alpha\mathrel{=}\TConId{Either}\;\alpha\;\TConId{Dynamic}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Conid{Record}} is represented using the binary sum type \ensuremath{\TConId{Either}\;\Varid{a}\;\Varid{b}}. With the tail wrapped inside a \ensuremath{\Conid{Record}\;\alpha} value we gain the possibility of hiding the tail. We make no distinction between the type of an empty record and that of a hidden tail.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Smart constructors}{}\<[E]%
\\
\>[B]{}\Varid{record}\mathrel{=}L{}\<[E]%
\\
\>[B]{}\Varid{unRecord}\;(L\;\Varid{a})\mathrel{=}\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hideRecord}\ConSym{::}\TClassId{Typeable}\;\alpha\Rightarrow \Conid{Record}\;\alpha\to \Conid{Record}\;(){}\<[E]%
\\
\>[B]{}\Varid{hideRecord}\;(L\;\Varid{a})\mathrel{=}R\;(\Varid{toDyn}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{emptyRecord}\ConSym{::}\TConId{IO}\;(\Conid{Record}\;()){}\<[E]%
\\
\>[B]{}\Varid{emptyRecord}\mathrel{=}\Varid{return}\;(\Varid{record}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{record}} and \ensuremath{\Varid{unRecord}} functions wrap and unwrap a record, \ensuremath{\Varid{hideRecord}} hides a record by injecting it into a \ensuremath{\TConId{Dynamic}}, and \ensuremath{\Varid{emptyRecord}} is adapted to the new record representation. Note that the representation requires every interface to be an instance of \ensuremath{\TClassId{Typeable}} such that it can be used by the \ensuremath{\Conid{Data}.\TConId{Dynamic}} library. 

We now wrap every tail inside a \ensuremath{\Conid{Record}} like this

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IShape}\;\alpha\mathrel{=}\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 shapeTail}\ConSym{::}\Conid{Record}\;\alpha{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

, and revise the narrowing functions to use \ensuremath{\Varid{hideRecord}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\TClassId{Narrow}\;(\Conid{IShape}\;(\Conid{IRectangle}\;()))\;(\Conid{IShape}\;())\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{narrow}\;\Varid{o}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}\Varid{hideRecord}\;(\Varid{\char95 shapeTail}\;\Varid{o})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The effect of the new representation is that for example an upcast from \emph{Cube} to \emph{Shape} still has the same type, but internally looks more like this:

IShape ({\color{gray}IRectangle (ICube ())})

where black is the visible and gray the invisible part of the type. By changing the representation we introduced the possibility of restoring the subtypes.

With the correct data structure in place we are ready to implement the downcast function. Since we do not know what types are possibly hidden -- it can be any subtypes -- a downcast is necessarily a partial function. The best we can do is \emph{try} to perform a downcast. A downcast is a function from a value of type \ensuremath{\beta} to a value of type \ensuremath{\TConId{Maybe}\;\alpha} which succeeds only if \ensuremath{\beta} is a supertype of \ensuremath{\alpha}, and \ensuremath{\beta} can be converted into a value of type \ensuremath{\alpha}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{downcast}\ConSym{::}\beta\to \TConId{Maybe}\;\alpha{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At first, it seems to make sense to place \ensuremath{\Varid{downcast}} inside the \ensuremath{ \TClassId{$\ \prec\ $} } type class given that \ensuremath{\Varid{downcast}} is the partial inverse of \ensuremath{\Varid{upcast}} and the instances are governed by the same subtyping rules.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\alpha \TClassId{$\ \prec\ $} \beta\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{upcast}{}\<[13]%
\>[13]{}\ConSym{::}\alpha\to \beta{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}{}\<[13]%
\>[13]{}\ConSym{::}\beta\to \TConId{Maybe}\;\alpha{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This works fine for the reflexivity instances, but unfortunately breaks for transitivity as the type class constraints necessary for \ensuremath{\Varid{downcast}} are not incompatible with those required for \ensuremath{\Varid{upcast}}. An \ensuremath{\Varid{upcast}} forgets information while \ensuremath{\Varid{downcast}} tries to gain information. Hence, we introduce a separate type class for the supertype relation and rely on the library designer to ensure consistency between the two.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  New type class for downcasting}{}\<[E]%
\\
\>[B]{}\Keyword{class}\;\alpha \TClassId{$\ \succ\ $} \beta\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}\ConSym{::}\alpha\to \TConId{Maybe}\;\beta{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For reflexivity a downcast always succeeds.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Depth 1}{}\<[E]%
\\
\>[B]{}\Keyword{instance}\;\Varid{a}\;() \TClassId{$\ \succ\ $} \Varid{a}\;()\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}\mathrel{=}\Conid{Just}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \succ\ $} \Varid{a}\;(\Varid{b}\;())\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}\mathrel{=}\Conid{Just}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The interesting case is transitivity.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}c<{\hspost}@{}}%
\column{22E}{@{}l@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;(\Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \succ\ $} \Varid{a}\;(\Varid{b}\;\Varid{c}))\Rightarrow \Varid{a}\;() \TClassId{$\ \succ\ $} \Varid{a}\;(\Varid{b}\;\Varid{c})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}\;\Varid{o}\mathrel{=}\Keyword{case}{}\<[22]%
\>[22]{}\VarSym{?}{}\<[22E]%
\>[25]{}\ConSym{::}\TConId{Maybe}\;(\Varid{a}\;(\Varid{b}\;()))\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{14}{}\<[17]%
\>[17]{}\Conid{Just}\;\Varid{r}{}\<[26]%
\>[26]{}\to \Varid{downcast}\;\Varid{r}{}\<[E]%
\\
\>[3]{}\hsindent{14}{}\<[17]%
\>[17]{}\Conid{Nothing}{}\<[26]%
\>[26]{}\to \Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The instance declaration should be read as follows: given a value of type \ensuremath{\Varid{a}\;()} we may downcast it to a subtype \ensuremath{\Varid{a}\;(\Varid{b}\;\Varid{c})} provided that we can downcast it to \ensuremath{\Varid{a}\;(\Varid{b}\;())}, if the downcast is successful we delegate the task of resolving \ensuremath{\Varid{c}} to another instance, otherwise we fail by returning \ensuremath{\Conid{Nothing}}.

Similar to \ensuremath{\Varid{upcast}} we have lost information by abstracting over the actual types. We capture the dual of \ensuremath{\TClassId{Narrow}} through a new type class:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\TClassId{Widen}\;\beta\;\alpha\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{widen}\ConSym{::}\beta\to \alpha{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

and replace the question mark with a call to \ensuremath{\Varid{widen}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;(\Varid{a}\;(\Varid{b}\;()) \TClassId{$\ \succ\ $} \Varid{a}\;(\Varid{b}\;\Varid{c}),\TClassId{Widen}\;(\Varid{a}\;())\;(\Varid{a}\;(\Varid{b}\;())))\Rightarrow \Varid{a}\;() \TClassId{$\ \succ\ $} \Varid{a}\;(\Varid{b}\;\Varid{c})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{downcast}\;\Varid{o}\mathrel{=}\Keyword{case}\;\Varid{widen}\;\Varid{o}\ConSym{::}\TConId{Maybe}\;(\Varid{a}\;(\Varid{b}\;()))\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{14}{}\<[17]%
\>[17]{}\Conid{Just}\;\Varid{r}{}\<[26]%
\>[26]{}\to \Varid{downcast}\;\Varid{r}{}\<[E]%
\\
\>[3]{}\hsindent{14}{}\<[17]%
\>[17]{}\Conid{Nothing}{}\<[26]%
\>[26]{}\to \Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By pattern matching on a known part of the type structure and an unknown part \ensuremath{\Varid{c}} a downcast can incrementally recover from the hidden types. The implementation of \ensuremath{\Varid{widen}} only works correctly if different parts of the library maintain the following invariants:
\begin{enumerate}
  \item An \ensuremath{\Varid{upcast}} always hides the tail of a record by using \ensuremath{\Varid{hideRecord}}.
  \item All interfaces should derive from \ensuremath{\TClassId{Typeable}}.
  \item Fresh object instantiations always have \ensuremath{\Varid{emptyRecord'}} as tail.
  \item A downcast can only encounter a \ensuremath{R} data constructor.
\end{enumerate}

Invariant (1) is not enforced by the type system. Without precautions it is possible for \ensuremath{\Varid{upcast}} to choose \ensuremath{\Varid{emptyRecord'}} which would destroy the invariant. Fortunately, as library designer we may export \ensuremath{\Conid{Record}} as an abstract data type and confine \ensuremath{\Varid{emptyRecord}} to internal use.

Invariant (2) is taken care of by the macros (see section \ref{sec:boilerplate}). However, if a interface does not derive from \ensuremath{\TClassId{Typeable}} and (1) holds, using casting operations on that class will fail at compile-time. 

Invariant (3) is covered by the \ensuremath{\Keyword{new}} combinator.

Invariant (4) follows from (1) and (3). A downcast cannot encounter \ensuremath{L} because widening only starts at a concrete object type. Furthermore, it cannot encounter the empty record because any downcast always bottoms out at a reflexivity instance which itself does not inspect the representation.

All instances of \ensuremath{\TClassId{Widen}} are defined in terms of \ensuremath{\Varid{genericWiden}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\TClassId{Widen}\;(\Conid{IShape}\;())\;(\Conid{IShape}\;(\Conid{IRectangle}\;()))\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{widen}\;\Varid{o}\mathrel{=}\Varid{genericWiden}\;\Varid{o}\;\Varid{\char95 shapeTail}\;(\lambda \Varid{o}\;\Varid{v}\to \Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}\Varid{v}\mskip1.5mu\}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{genericWiden}} function is passed the object it should perform widening on and a getter/setter for the object's tail. It discriminates on the object's tail and attempts to recover its tail.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{genericWiden}\ConSym{::}\forall \Varid{o}\hsforall \;\Varid{a}\;\Varid{b}\;\Varid{c}\hsdot{\circ }{.}\TClassId{Typeable}\;\Varid{b}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{o}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\to {}\<[7]%
\>[7]{}(\Varid{o}\to \Conid{Record}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\to {}\<[7]%
\>[7]{}(\Varid{o}\to \Conid{Record}\;\Varid{b}\to \Varid{c}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\to {}\<[7]%
\>[7]{}\TConId{Maybe}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{genericWiden}\;\Varid{o}\;\Varid{getTail}\;\Varid{setTail}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{case}\;\Varid{getTail}\;\Varid{o}\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}R\;\Varid{d}{}\<[14]%
\>[14]{}\to \Varid{maybe}\;\Conid{Nothing}\;(\Conid{Just}\hsdot{\circ }{.}\Varid{setTail}\;\Varid{o}\hsdot{\circ }{.}\Varid{record})\;(\Varid{fromDynamic}\;\Varid{d}\ConSym{::}\TConId{Maybe}\;\Varid{b}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}L\;{}\<[11]%
\>[11]{}\anonymous {}\<[14]%
\>[14]{}\to \Varid{error}\;\Char{\char34 invariant~(4)\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsubsection{A change in semantics}
\label{subsubsec:changeinsemantics}

In section \ref{subsec:tp-records} we informally described the semantics of tail-polymorphic records. The meaning of the tail-polymorphic type structure now slightly changes because we modified the object representation such that the tail of a record may be hidden using a dynamic type. Whereas an object of type \ensuremath{\Conid{A}\;()} used to mean \emph{exactly} \ensuremath{\Conid{A}\;()} it can now mean \emph{at least} \ensuremath{\Conid{A}\;()} even though its type has not changed. Given that now both \ensuremath{\Conid{A}\;()} and \ensuremath{\Conid{A}\;\Varid{a}} can be interpreted as \emph{at least} \ensuremath{\Conid{A}\;()} we wonder: can we substitute one for the other? We cover this question of substitutability for the contra- and covariant position.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{A}\;()\to \VarSym{...}{}\<[E]%
\\
\>[B]{}\Comment{  -{}-\enskip  subst}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{A}\;\Varid{a}{}\<[8]%
\>[8]{}\to \VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We may substitute \ensuremath{\Conid{A}\;()} with \ensuremath{\Conid{A}\;\Varid{a}} in the contravariant position by changing the type signature. All calls to the function
can remain unchanged. However, from a implementation perspective this substitution may prove problematic since we cannot use casting on polymorphic objects. Also, the substitution transitively inhibits other functions from using casts. A better alternative would be to substitude \ensuremath{\Conid{A}\;()} with a type variable constrained by the subtype type class:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{A}\;()\to \VarSym{...}{}\<[E]%
\\
\>[B]{}\Comment{  -{}-\enskip  subst}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{a} \TClassId{$\ \prec\ $} \Conid{A}\;()\Rightarrow \Varid{a}\to \VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now the function can get any monomorphic subtype of \ensuremath{\Conid{A}\;()} as argument, i.e. excluding \ensuremath{\Conid{A}\;\Varid{a}} or any polymorphic subtype (e.g. \ensuremath{\Conid{A}\;(\Conid{B}\;\Varid{a})}). Furthermore, before the argument can be used it must first be casted to \ensuremath{\Conid{A}\;()}.

We may substitute \ensuremath{\Conid{A}\;\Varid{a}} for \ensuremath{\Conid{A}\;()} in the contravariant position by again simply changing the type signature:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{A}\;\Varid{a}\to \VarSym{...}{}\<[E]%
\\
\>[B]{}\Comment{  -{}-\enskip  subst}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{A}\;()\to \VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This change will require all call sites to upcast the function argument to \ensuremath{\Conid{A}\;()} unless the argument is already of type \ensuremath{\Conid{A}\;()}. The function implementation will remain unaffected by the change.

We now consider substitutability in the covariant position. Substituting \ensuremath{\Conid{A}\;()} with \ensuremath{\Conid{A}\;\Varid{a}} in the covariant position is not possible because this would require universal quantification over a value with a monomorphic type. However, what we can do is abstract over its tail using existential quantification:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\VarSym{...}\to \Conid{A}\;(){}\<[E]%
\\
\>[B]{}\Comment{  -{}-\enskip  subst }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}\to \exists \Varid{a}\hsexists \hsdot{\circ }{.}\Conid{A}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The resulting existential type can then be freely applied to functions expecting an universally quantified value of type \ensuremath{\Conid{A}\;\Varid{a}}. Thus the existential gives us the same behavior we would otherwise get from returning a value of type \ensuremath{\Conid{A}\;\Varid{a}}.

If a function has \ensuremath{\Conid{A}\;\Varid{a}} in the covariant position it can only have gotten it as an argument. It can never by itself produce a value of type \ensuremath{\Conid{A}\;\Varid{a}}. If a function has \ensuremath{\Conid{A}\;\Varid{a}} in the covariant position we can substitute it with \ensuremath{\Conid{A}\;()} provided that we modify the calling and return context to cast the argument and return value to the appropriate type.

We conclude that moving between \ensuremath{\Conid{A}\;\Varid{a}} and \ensuremath{\Conid{A}\;()} is a delicate business. It does not always go without affecting the implementation, and in particular substituting \ensuremath{\Conid{A}\;()} with \ensuremath{\Conid{A}\;\Varid{a}} may break functions that depend on casting. Using polymorphic objects transitively inhibits other functions from using casts, and when used as argument to a method requires rank-2 polymorphism. The only benefit they bring is that no type conversions are necessary. Hence from a user's perspective it makes sense to stick with monomorphic objects at the cost of some more explicit type conversions.

\subsubsection{Combinators}

Using the subtype type class we can define two asymmetric combinators \ensuremath{\Varid{consUb}} and \ensuremath{\Varid{nilUb}} that allow the construction of a homogeneous list out of object values related by subtyping. Upon inserting a value it is first cast to the supertype that is provided at the call site and then "consed" on to the list. The supertype should be the common upper bound of all elements in the list. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{consUb}\ConSym{::}\forall \Varid{a}\hsforall \;\Varid{b}\hsdot{\circ }{.}(\Varid{a} \TClassId{$\ \prec\ $} \Varid{b},\TClassId{Typeable}\;\Varid{a})\Rightarrow \Varid{a}\to [\mskip1.5mu \Varid{b}\mskip1.5mu]\to [\mskip1.5mu \Varid{b}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{consUb}\;\Varid{o}\;\Varid{xs}\mathrel{=}(\Varid{upcast}\;\Varid{o}\ConSym{::}\Varid{b})\mathbin{:}\Varid{xs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{nilUp}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We have used the above combinators in section \ref{subsec:shapeshaskell} to insert different kind of shapes into a homogeneous list of shapes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{let}\;{}\<[6]%
\>[6]{}\Varid{scribble}{}\<[16]%
\>[16]{}\ConSym{::}[\mskip1.5mu \Conid{IShape}\;()\mskip1.5mu]{}\<[E]%
\\
\>[6]{}\Varid{scribble}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{consUb}\;\VarId{s_1}\;(\Varid{consUb}\;\VarId{s_2}\;\Varid{nilUb}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The dual, for the \emph{lower bound}, is implemented similarly:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{consLb}\ConSym{::}\forall \Varid{a}\hsforall \;\Varid{b}\hsdot{\circ }{.}(\Varid{b} \TClassId{$\ \succ\ $} \Varid{a},\TClassId{Typeable}\;\Varid{b})\Rightarrow \Varid{b}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{consLb}\;\Varid{o}\;\Varid{xs}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{case}\;\Varid{downcast}\;\Varid{o}\ConSym{::}\TConId{Maybe}\;\Varid{a}\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Just}\;\Varid{x}{}\<[14]%
\>[14]{}\to \Varid{x}\mathbin{:}\Varid{xs}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Nothing}{}\<[14]%
\>[14]{}\to \Varid{xs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{nilLb}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The definition of \ensuremath{\Varid{consUb}}/\ensuremath{\Varid{nilUb}} and \ensuremath{\Varid{consLb}}/\ensuremath{\Varid{nilLb}} only work for lists. We generalize their definition by overloading them on the container type such that they may be used for any container type that allows incremental construction.\footnote{\ensuremath{\varnothing }: mempty, \ensuremath{\oplus }: mappend}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\TClassId{Applicative}\;\Varid{f}\Rightarrow \Conid{CastCons}\;\Varid{f}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{consUb}\ConSym{::}\forall \Varid{a}\hsforall \;\Varid{b}\hsdot{\circ }{.}(\Varid{a} \TClassId{$\ \prec\ $} \Varid{b},\TClassId{Typeable}\;\Varid{b},\TClassId{Monoid}\;(\Varid{f}\;\Varid{b}))\Rightarrow \Varid{a}\to \Varid{f}\;\Varid{b}\to \Varid{f}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{consUb}\;\Varid{o}\;\Varid{xs}\mathrel{=}\Varid{pure}\;(\Varid{upcast}\;\Varid{o}\ConSym{::}\Varid{b})\oplus \Varid{xs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{consLb}\ConSym{::}\forall \Varid{b}\hsforall \;\Varid{a}\hsdot{\circ }{.}(\Varid{b} \TClassId{$\ \succ\ $} \Varid{a},\TClassId{Typeable}\;\Varid{b},\TClassId{Monoid}\;(\Varid{f}\;\Varid{a}))\Rightarrow \Varid{b}\to \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{consLb}\;\Varid{o}\;\Varid{xs}\mathrel{=}\Varid{maybe}\;\Varid{xs}\;(\Varid{xs}\oplus \hsdot{\circ }{.}\Varid{pure})\;(\Varid{downcast}\;\Varid{o}\ConSym{::}\TConId{Maybe}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{nilUb},\Varid{nilLb}{}\<[17]%
\>[17]{}\ConSym{::}\TClassId{Monoid}\;(\Varid{f}\;\Varid{a})\Rightarrow \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{nilUb}\mathrel{=}\varnothing {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{nilLb}\mathrel{=}\varnothing {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Similarly, we can lift casting operations to work on container types:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\TClassId{Functor}\;\Varid{f}\Rightarrow \Conid{Castable}\;\Varid{f}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{fup}\ConSym{::}\Varid{a} \TClassId{$\ \prec\ $} \Varid{b}\Rightarrow \Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{fup}\mathrel{=}\Varid{fmap}\;\Varid{upcast}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{fdown}\ConSym{::}\forall \Varid{a}\hsforall \;\Varid{b}\hsdot{\circ }{.}(\TClassId{Foldable}\;\Varid{f},\TClassId{Applicative}\;\Varid{f},\TClassId{Monoid}\;(\Varid{f}\;\Varid{a}),\Varid{b} \TClassId{$\ \succ\ $} \Varid{a})\Rightarrow \Varid{f}\;\Varid{b}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{fdown}\mathrel{=}\Varid{foldr}\;(\oplus \hsdot{\circ }{.}\Varid{maybe}\;\varnothing \;\Varid{pure}\hsdot{\circ }{.}(\Varid{downcast}\ConSym{::}\Varid{b}\to \TConId{Maybe}\;\Varid{a}))\;\varnothing {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Not all types that allow mapping also allow deconstruction, hence the \ensuremath{\TClassId{Applicative}} constraint is pushed down as a function constraint. We use \ensuremath{\Varid{fdown}} to create a list of rectangles out of a list of shapes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{let}\;{}\<[6]%
\>[6]{}\Varid{scribble'}\ConSym{::}[\mskip1.5mu \Conid{IShape}\;(\Conid{IRectangle}\;())\mskip1.5mu]{}\<[E]%
\\
\>[6]{}\Varid{scribble'}\mathrel{=}\Varid{fdown}\;\Varid{scribble}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can also define the familiar \ensuremath{\Varid{instanceof}} operations in terms of \ensuremath{\Varid{downcast}}. It test if a value is of a particular type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{instanceof}\ConSym{::}\forall \Varid{a}\hsforall \;\Varid{b}\hsdot{\circ }{.}(\Varid{b} \TClassId{$\ \succ\ $} \Varid{a})\Rightarrow \Varid{b}\to \Varid{a}\to \TConId{Bool}{}\<[E]%
\\
\>[B]{}\Varid{instanceof}\;\Varid{b}\;\anonymous \mathrel{=}\Varid{isJust}\;(\Varid{downcast}\;\Varid{b}\ConSym{::}\TConId{Maybe}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using \ensuremath{\Varid{instanceof}} we can define a function \ensuremath{\Varid{selectiveDraw}} that accepts any Shape, but only draws rectangles. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{selectiveDraw}\ConSym{::}\Conid{IShape}\;()\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{selectiveDraw}\;\Varid{shape}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{when}\;{}\<[9]%
\>[9]{}(\Varid{shape}\mathbin{`\Varid{instanceof}`}(\bot \ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;())))\;{}\<[E]%
\\
\>[9]{}(\Varid{shape}\VarSym{\#}\Varid{draw}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that \ensuremath{\Varid{instanceof}} only type checks if it is used for testing if an object actually is some subtype of its current type. There is no need for testing if it is an instance of some supertype because this is intrinsically known.

\subsection{Self-returning methods}
\label{subsec:selfret}

A self-returning method is a method whose return type is the type of self or some other type based on self. It is known that encapsulation by \emph{procedural data abstraction} requires recursive types for the precise typing of self-returning methods in the presence of inheritance (section 3.1 \cite{Cook:1989:IS:96709.96721}). On the left in figure \ref{fig:javaself} the problem is made explicit in Java (which lacks recursive types). To let the program type check some otherwise superfluous casts must be inserted. On the right there is a hack which uses Java Generics \cite{naftalin2006java} and a special \emph{getThis} function to reify the lost type information \footnote{\url{http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html\#FAQ205}}.

\begin{figure}[h]
\center
\begin{tabular}{ p{5cm} | p{5cm} }
  \begin{tabbing}\tt
~class~A~\char123{}\\
\tt ~~~public~A~foo\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~this\char59{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}\\
\tt ~\\
\tt ~class~B~extends~A~\char123{}\\
\tt ~~~public~B~bar\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~this\char59{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}\\
\tt ~\\
\tt ~B~b~\char61{}~new~B\char40{}\char41{}\char59{}\\
\tt ~\char47{}\char47{}~type~check~error\\
\tt ~b\char46{}bar\char40{}\char41{}\char46{}foo\char40{}\char41{}\char46{}bar\char40{}\char41{}\char59{}\\
\tt ~\char47{}\char47{}~fine\\
\tt ~\char40{}\char40{}B\char41{}~b\char46{}bar\char40{}\char41{}\char46{}foo\char40{}\char41{}\char41{}\char46{}bar\char40{}\char41{}\char59{}
\end{tabbing}
  & 
  \begin{tabbing}\tt
~abstract~class~A\char60{}T~extends~A\char60{}T\char62{}\char62{}~\char123{}\\
\tt ~~~public~T~foo\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~\char40{}T\char41{}~getThis\char40{}\char41{}\char59{}\\
\tt ~~~\char125{}\\
\tt ~~~public~abstract~T~getThis\char40{}\char41{}\char59{}\\
\tt ~\char125{}\\
\tt ~\\
\tt ~class~B~extends~A\char60{}B\char62{}~\char123{}\\
\tt ~~~public~B~bar\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~this\char59{}\\
\tt ~~~\char125{}\\
\tt ~~~public~B~getThis\char40{}\char41{}~\char123{}\\
\tt ~~~~~return~this\char59{}\\
\tt ~~~\char125{}\\
\tt ~\char125{}\\
\tt ~\\
\tt ~B~b~\char61{}~new~B\char40{}\char41{}\char59{}\\
\tt ~\char47{}\char47{}~fine\\
\tt ~b\char46{}bar\char40{}\char41{}\char46{}foo\char40{}\char41{}\char46{}bar\char40{}\char41{}\char59{}
\end{tabbing}
\end{tabular}
\caption{On the left: an example in Java where we use self-returning methods in combination with inheritance. On the right: a trick to resolve the need for casting.}
\label{fig:javaself}
\end{figure}

In a first attempt to implement a self-returning method we reuse the shapes example and augment \ensuremath{\Conid{IShape}} with a method \ensuremath{\Varid{meShape}} that returns itself.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}c<{\hspost}@{}}%
\column{4E}{@{}l@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IShape}\;\alpha\mathrel{=}\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\VarSym{...}{}\<[4E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{meShape}{}\<[4E]%
\>[16]{}\ConSym{::}\TConId{IO}\;(\Conid{IShape}\;\alpha){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 shapeTail}{}\<[16]%
\>[16]{}\ConSym{::}\Conid{Record}\;\alpha{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the return type of \ensuremath{\Varid{meShape}} we simply refer to itself. Unfortunately, because \ensuremath{\alpha} is now used at two positions in interface the \ensuremath{\Varid{\char95 shapeTail}} function becomes less general compared to what it would have been had we only used \ensuremath{\alpha} in a single position.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Without meShape}{}\<[E]%
\\
\>[B]{}\Varid{\char95 shapeTail}\ConSym{::}\Conid{IShape}\;\alpha\to \Conid{Record}\;\beta\to \Conid{IShape}\;\beta{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  With meShape}{}\<[E]%
\\
\>[B]{}\Varid{\char95 shapeTail}\ConSym{::}\Conid{IShape}\;\alpha\to \Conid{Record}\;\alpha\to \Conid{IShape}\;\alpha{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As a consequence we can no longer change the type of the tail in isolation making record extension highly impractical and impossible to fit into our framework for casting. Alternatively we could try to abstract over the return type by parameterizing over it, similar to what is done on the right in figure \ref{fig:javaself}. However, this will also not work because the type parameter now has to unify with itself which is prohibited by the occurs check. Because Haskell does have iso-recursive types \oohaskell uses newtype wrappers to solve this problem. Unfortunately, wrapping self inside a newtype will not work for our encoding as it again requires using the tail type parameter at multiple positions preventing record extension. 

Confronted with the impossibilities of the encoding we resort to a less sophisticated version of self-returning methods and take for granted that some casts are required. We start by making the return type of \ensuremath{\Varid{meShape}} concrete:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IShape}\;\alpha\mathrel{=}\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{meShape}{}\<[17]%
\>[17]{}\ConSym{::}\TConId{IO}\;(\Conid{IShape}\;()){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{shape}\;\Varid{newx}\;\Varid{newy}\;\Varid{concreteDraw}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{meShape}\mathrel{=}\Varid{return}\;\Varid{self}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The program type checks, but there is a subtle problem. The type inferencer has instantiated \ensuremath{\Varid{self}} to \ensuremath{\Conid{IShape}\;()} which again inhibits further extension. We should somehow convince the type inferencer that it may temporarily assume \ensuremath{\Varid{self}} to be of type \ensuremath{\Conid{IShape}\;()} without this knowledge overspecializing the inferred function type. There are two approaches that may help us achieve our goal: upcasting or existential quantification.  

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Upcast}{}\<[E]%
\\
\>[B]{}\Varid{meShape}\mathrel{=}\Varid{return}\;(\Varid{upcast}\;\Varid{self}\ConSym{::}\Conid{IShape}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

By using \ensuremath{\Varid{upcast}} we make our knowledge that \ensuremath{\Varid{self}} is of at least \ensuremath{\Conid{IShape}\;()} explicit changing the inferred type to:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Inferred type}{}\<[E]%
\\
\>[B]{}\Varid{shape}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\ConSym{::}\Conid{IShape}\;\VarId{a_1} \TClassId{$\ \prec\ $} \Conid{IShape}\;()\Rightarrow {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\TConId{Int}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\to \TConId{Int}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\to (\Conid{IShape}\;\VarId{a_1}\to \TConId{IO}\;()){}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\to \TConId{IO}\;(\Conid{IShape}\;\VarId{a_1}\to \Conid{Record}\;\Varid{a}){}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\to \Conid{IShape}\;\VarId{a_1}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\to \TConId{IO}\;(\Conid{IShape}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Self is now overloaded by what at first sight may seem like a problematic constraint. However, because objects are always instantiated by using \ensuremath{\Keyword{new}} we know that \ensuremath{\VarId{a_1}} will eventually be instantiated to a concrete type such that substituting it in \ensuremath{\Conid{IShape}\;\VarId{a_1} \TClassId{$\ \prec\ $} \Conid{IShape}\;()} will satisfy the constraint.

As an example we show how we can call \ensuremath{\Varid{meShape}} on a \emph{Rectangle}. Calling \ensuremath{\Varid{meShape}} on a \emph{Rectangle} returns a \emph{Shape} which we downcast back to a \emph{Rectangle} and use to invoke \ensuremath{\Varid{getWidth}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  ((Rectangle) s1.meShape()).getWidth()}{}\<[E]%
\\
\>[B]{}\Varid{mySelfReturn}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarId{s_1}{}\<[10]%
\>[10]{}\leftarrow \Keyword{new}\mathbin{\$}\Varid{rectangle}\;\Numeral{10}\;\Numeral{20}\;\Numeral{5}\;\Numeral{6}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{shape}{}\<[10]%
\>[10]{}\leftarrow \VarId{s_1}\VarSym{\#}\Varid{meShape}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Conid{Just}\;\Varid{rect}\mathrel{=}\Varid{downcast}\;\Varid{shape}\ConSym{::}\TConId{Maybe}\;(\Conid{IShape}\;(\Conid{IRectangle}\;())){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{w}\leftarrow \Varid{rect}\VarSym{\#}\Varid{getWidth}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{putStrLn}\mathbin{\$}\Varid{show}\;\Varid{w}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A different approach would be to existentially quantify over the tail of the record.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Existential quantification}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{IShape}\;\alpha\mathrel{=}\Conid{IShape}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{meShape}\ConSym{::}\exists \alpha\hsexists \hsdot{\circ }{.}\TConId{IO}\;(\Conid{IShape}\;\alpha){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This makes it easy to return \ensuremath{\Varid{self}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{meShape}\mathrel{=}\Varid{return}\;\Varid{self}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

But because the tail is existentially quantified over it does not allow casting. We solve this by placing a subtype constraint on the quantified variable.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{meShape}\ConSym{::}\exists \alpha\hsexists \hsdot{\circ }{.}(\Conid{IShape}\;\alpha \TClassId{$\ \prec\ $} \Conid{IShape}\;())\Rightarrow \TConId{IO}\;(\Conid{IShape}\;\alpha){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Herewith the concrete type can be reified through an upcast.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mySelfReturn}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{shape'}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{upcast}\;\Varid{shape}\ConSym{::}\Conid{IShape}\;(){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Conid{Just}\;\Varid{rect}{}\<[18]%
\>[18]{}\mathrel{=}\Varid{downcast}\;\Varid{shape'}\ConSym{::}\TConId{Maybe}\;(\Conid{IShape}\;(\Conid{IRectangle}\;())){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We gained ease of expression at the return site, but at the same time made the task of the caller more verbose. Also, the use of anonymous existentials is unique to UHC and requires newtype wrappers in GHC which makes it a far less attractive option. For these reasons we prefer to use concrete object types, even though the combination of top-level class definitions, overloading, and parameter hiding can trigger the monomorphism restriction\footnote{\url{http://www.haskell.org/onlinereport/decls.html\#sect4.5.5}}. 

\subsection{Parameterized classes}
\label{subsec:paraclasses}

In section \ref{subsec:semi-explicit-poly} we showed how we could create polymorphic classes by adding type parameters to the interface definition. Parameterization over method types allows for much greater flexibility because the same interface can be reused for instantiations with different concrete types. This is especially useful for container-like classes where operations on the container are independent of the actual contents. In this section we will further explore parameterized classes in combination with inheritance and casting. But before we do we first generalize our previous definition of an \emph{interface}.

\vspace{10pt}
\begin{definition}
An interface is a record $C$ with the following shape:

\ensuremath{\Keyword{data}\;\Conid{C}\;\VarId{a_1},\VarSym{...},\VarId{a_n},\Varid{t}\mathrel{=}\Conid{C}\;\{\mskip1.5mu \Varid{m},\Varid{\char95 cTail}\ConSym{::}\Conid{Record}\;\Varid{t}\mskip1.5mu\}}

where $C$ takes $n \geq 1$ type parameters, $t$ represents the tail, and may be instantiated to either \ensuremath{()} or an interface. In the body there is $m$ which expands to zero or more methods that may use any of $a_1,...,a_n$, and a special method \ensuremath{\Varid{\char95 cTail}} where \ensuremath{\Varid{c}} is the uncapitalized version of \ensuremath{\Conid{C}}.
\end{definition}

Many statically typed OO languages have the ability to parameterize classes. We show that our library can easily deal with parameterized classes that are invariant in their type parameters. As a reference we have implemented a class \emph{Pair} in Java using generics, reminiscent of the Haskell tuple, and let another class \emph{Triple} extend from \emph{Pair} (see figure \ref{fig:javagenerics}). Both \emph{Pair} and \emph{Triple} are parameterized over their contained types.

\begin{figure}
\center
\begin{tabular}{ p{5cm} | p{5cm} }
  \begin{tabbing}\tt
~class~Pair\char60{}A\char44{}B\char62{}~\char123{}\\
\tt ~~~~private~final~A~a\char59{}\\
\tt ~~~~private~final~B~b\char59{}\\
\tt ~~~~\\
\tt ~~~~public~Pair\char40{}A~a\char44{}~B~b\char41{}~\char123{}\\
\tt ~~~~~~~this\char46{}a~\char61{}~a\char59{}\\
\tt ~~~~~~~this\char46{}b~\char61{}~b\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\\
\tt ~~~~public~A~getFirst\char40{}\char41{}~\char123{}\\
\tt ~~~~~~~return~a\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\\
\tt ~~~~public~B~getSecond\char40{}\char41{}~\char123{}\\
\tt ~~~~~~~return~b\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}
  & 
  \begin{tabbing}\tt
~class~Triple\char60{}A\char44{}B\char44{}C\char62{}~extends~Pair\char60{}A\char44{}B\char62{}~\char123{}\\
\tt ~~~~private~final~C~c\char59{}\\
\tt ~~~~\\
\tt ~~~~public~Triple\char40{}A~a\char44{}~B~b\char44{}~C~c\char41{}~\char123{}\\
\tt ~~~~~~~super\char40{}a\char44{}b\char41{}\char59{}\\
\tt ~~~~~~~this\char46{}c~\char61{}~c\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\\
\tt ~~~~public~C~getThird\char40{}\char41{}~\char123{}\\
\tt ~~~~~~~return~c\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\\
\tt ~~~~public~Triple\char60{}B\char44{}A\char44{}C\char62{}~swap\char40{}\char41{}~\char123{}\\
\tt ~~~~~~~return~\\
\tt ~~~~~~~~~new~Triple\char60{}B\char44{}A\char44{}C\char62{}\char40{}\\
\tt ~~~~~~~~~~~getSecond\char40{}\char41{}\char44{}getFirst\char40{}\char41{}\char44{}c\\
\tt ~~~~~~~~~\char41{}\char59{}\\
\tt ~~~~\char125{}\\
\tt ~\char125{}
\end{tabbing}
\end{tabular}
\caption{Two generic container types reminiscent of the Haskell tuple.}
\label{fig:javagenerics}
\end{figure}

We perform a stepwise transcription of the Java code to Haskell. First, the \emph{Pair} interface.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{IPair}\;\Varid{a}\;\Varid{b}\;\Varid{t}\mathrel{=}\Conid{IPair}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 getFirst}{}\<[18]%
\>[18]{}\ConSym{::}\TConId{IO}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 getSecond}{}\<[18]%
\>[18]{}\ConSym{::}\TConId{IO}\;\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{},\Varid{\char95 pairTail}{}\<[18]%
\>[18]{}\ConSym{::}\Conid{Record}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In Java all classes are subclasses from \emph{Object}. Staying true to the example we also extend from \emph{Object} which we take to be a simple placeholder.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pair}\;\Varid{a}\;\Varid{b}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{pair'}\mathbin{`\Keyword{extends}`}\Varid{object})\;\Varid{noOverride}\;\Varid{set\char95 Object\char95 Tail}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{pair'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{IPair}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getFirst}{}\<[23]%
\>[23]{}\mathrel{=}\Varid{return}\;\Varid{a}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 getSecond}{}\<[23]%
\>[23]{}\mathrel{=}\Varid{return}\;\Varid{b}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 pairTail}{}\<[23]%
\>[23]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For casting to work we provide the necessary instances for \ensuremath{\TClassId{Narrow}} and \ensuremath{\TClassId{Widen}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Pair\char95 }\;{}\<[13]%
\>[13]{}\Varid{a}\;\Varid{b}\;\Varid{t}{}\<[20]%
\>[20]{}\mathrel{=}\Conid{Object\char95 }\;(\Conid{IPair}\;\Varid{a}\;\Varid{b}\;\Varid{t}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Pair}\;{}\<[13]%
\>[13]{}\Varid{a}\;\Varid{b}{}\<[20]%
\>[20]{}\mathrel{=}\Conid{Pair\char95 }\;\Varid{a}\;\Varid{b}\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\TClassId{Typeable}\;\Varid{a},\TClassId{Typeable}\;\Varid{b})\Rightarrow \TClassId{Narrow}\;(\Conid{Pair}\;\Varid{a}\;\Varid{b})\;\Conid{Object}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{narrow}\mathrel{=}\Varid{modify\char95 Object\char95 Tail}\;\Varid{hideRecord}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\TClassId{Typeable}\;\Varid{a},\TClassId{Typeable}\;\Varid{b})\Rightarrow \TClassId{Widen}\;\Conid{Object}\;(\Conid{Pair}\;\Varid{a}\;\Varid{b})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{widen}\;\Varid{o}\mathrel{=}\Varid{genericWiden}\;\Varid{o}\;\Varid{get\char95 Object\char95 Tail}\;\Varid{set\char95 Object\char95 Tail}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Notice that we take fruitful use of the fact that the tail is always the last type parameter. If this were not the case we would have been be forced to write down all instances of the sub- and super type classes, for all interface shapes, which would lead to a combinatorial explosion in the number of instances.

We proceed by transcribing the \ensuremath{\Conid{Triple}} class. Interestingly, the \ensuremath{\Conid{Triple\char95 }} type synonym and the Java class declaration look very much alike. In Java the type variables are introduced implicitly by usage whereas in Haskell they need to be explicitly declared before they can be used. In both cases the programmer is responsible for the correctly distributing the type variables.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Triple}\;{}\<[15]%
\>[15]{}\Varid{a}\;{}\<[18]%
\>[18]{}\Varid{b}\;{}\<[21]%
\>[21]{}\Varid{c}{}\<[27]%
\>[27]{}\mathrel{=}\Conid{Triple\char95 }\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Triple\char95 }\;{}\<[15]%
\>[15]{}\Varid{a}\;{}\<[18]%
\>[18]{}\Varid{b}\;{}\<[21]%
\>[21]{}\Varid{c}\;{}\<[24]%
\>[24]{}\Varid{t}{}\<[27]%
\>[27]{}\mathrel{=}\Conid{Pair\char95 }\;\Varid{a}\;\Varid{b}\;(\Conid{ITriple}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{t}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{ITriple}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{t}\mathrel{=}\Conid{ITriple}\;\{\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{\char95 getThird}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 swap}{}\<[19]%
\>[19]{}\ConSym{::}\TConId{IO}\;(\Conid{Triple}\;\Varid{b}\;\Varid{a}\;\Varid{c}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{},\Varid{\char95 tripleTail}{}\<[19]%
\>[19]{}\ConSym{::}\Conid{Record}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The implementation follows naturally from the interface definition. Unfortunately, the type inferencer does not infer the correct type for \ensuremath{\Varid{triple}}. It infers that both \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}} should be of the same type because they are used interchangeably at different points in the program (see \ensuremath{\Varid{\char95 swap}} and \ensuremath{\Varid{pair}}). We have to explicitely mark them as distinct by providing a type signature. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{triple}\ConSym{::}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[10]%
\>[10]{}\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to {}\<[10]%
\>[10]{}\Varid{c}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to \Conid{OpenClass}\;(\Conid{Record}\;\Varid{tail})\;\Varid{self}\;(\Conid{Pair\char95 }\;\Varid{a}\;\Varid{b}\;(\Conid{ITriplet}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{tail})){}\<[E]%
\\
\>[B]{}\Varid{triple}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{triple'}\mathbin{`\Keyword{extends}`}\Varid{pair}\;\Varid{a}\;\Varid{b})\;\Varid{noOverride}\;\Varid{set\char95 Pair\char95 Tail}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{triple'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\Varid{return}\;\Conid{ITriple}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{4}{}\<[11]%
\>[11]{}\Varid{\char95 getThird}{}\<[24]%
\>[24]{}\mathrel{=}\Varid{return}\;\Varid{c}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 swap}{}\<[24]%
\>[24]{}\mathrel{=}\Keyword{new}\mathbin{\$}\Varid{triple}\;\Varid{b}\;\Varid{a}\;\Varid{c}{}\<[E]%
\\
\>[7]{}\hsindent{3}{}\<[10]%
\>[10]{},\Varid{\char95 tripleTail}{}\<[24]%
\>[24]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{swapTriple}\mathrel{=}\Varid{\char95 swap}\hsdot{\circ }{.}\Varid{unRecord}\hsdot{\circ }{.}\Varid{get\char95 Pair\char95 Tail}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We also require two additional instances for \ensuremath{\TClassId{Narrow}} and \ensuremath{\TClassId{Widen}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;(\TClassId{Typeable}\;\Varid{a},\TClassId{Typeable}\;\Varid{b},\TClassId{Typeable}\;\Varid{c})\Rightarrow \TClassId{Narrow}\;(\Conid{Triple}\;\Varid{a}\;\Varid{b}\;\Varid{c})\;(\Conid{Pair}\;\Varid{a}\;\Varid{b})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{narrow}\mathrel{=}\Varid{modify\char95 Pair\char95 Tail}\;\Varid{hideRecord}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;(\TClassId{Typeable}\;\Varid{a},\TClassId{Typeable}\;\Varid{b},\TClassId{Typeable}\;\Varid{c})\Rightarrow \TClassId{Widen}\;(\Conid{Pair}\;\Varid{a}\;\Varid{b})\;(\Conid{Triple}\;\Varid{a}\;\Varid{b}\;\Varid{c})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{widen}\;\Varid{o}\mathrel{=}\Varid{genericWiden}\;\Varid{o}\;\Varid{get\char95 Pair\char95 Tail}\;\Varid{set\char95 Pair\char95 Tail}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We put the two classes to use by constructing a \emph{Pair} and \emph{Triple}, insert them into a list of pairs, and map over the list projecting out the first component and printing its value.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{myOOTriplet}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{p}\leftarrow \Keyword{new}\mathbin{\$}\Varid{pair}\;{}\<[22]%
\>[22]{}(\Numeral{0}\ConSym{::}\TConId{Int})\;{}\<[34]%
\>[34]{}(\Numeral{3.0}\ConSym{::}\TConId{Double}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{t}\leftarrow \Keyword{new}\mathbin{\$}\Varid{triple}\;{}\<[22]%
\>[22]{}(\Numeral{0}\ConSym{::}\TConId{Int})\;{}\<[34]%
\>[34]{}(\Numeral{4.0}\ConSym{::}\TConId{Double})\;{}\<[51]%
\>[51]{}\Char{\char34 Hi\char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;{}\<[8]%
\>[8]{}\Varid{pairs}{}\<[15]%
\>[15]{}\ConSym{::}[\mskip1.5mu \Conid{Pair}\;\TConId{Int}\;\TConId{Double}\mskip1.5mu]{}\<[E]%
\\
\>[8]{}\Varid{pairs}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{consUb}\;\Varid{t}\;(\Varid{consUb}\;\Varid{p}\;\Varid{nilUb}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{sequence\char95 }\mathbin{\$}\Varid{map}\;(\lambda \Varid{p}\to \Varid{p}\VarSym{\#}\Varid{getFirst}\rightarrowtail \Varid{print})\;\Varid{pairs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{t'}\leftarrow \Varid{t}\VarSym{\#}\Varid{swapTriple}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{t'}\VarSym{\#}\Varid{getFirst}\rightarrowtail \Varid{print}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{tabbing}\tt
~ghci\char62{}myOOTriplet\\
\tt ~0\\
\tt ~0\\
\tt ~4\char46{}0
\end{tabbing}

With parameterized classes the question of substitutability can be extended to incorporate a class' type parameters. For instance, \ensuremath{\Conid{Pair}\;\Conid{Point}\;\Conid{Point}} where \ensuremath{\Conid{Point}} is a subclass of \ensuremath{\Conid{Object}} is intuitively a subtype of \ensuremath{\Conid{Pair}\;\Conid{Object}\;\Conid{Object}}, i.e. it is safe to substitute a value of type \ensuremath{\Conid{Pair}\;\Conid{Object}\;\Conid{Object}} with a value of type \ensuremath{\Conid{Pair}\;\Conid{Point}\;\Conid{Point}} because both \ensuremath{\Varid{getFirst}} and \ensuremath{\Varid{getSecond}} are expected to return a \ensuremath{\Conid{Point}} which can safely be interpreted as an \ensuremath{\Conid{Object}}. This intuition is formalized by \emph{depth subtyping}. Unfortunately, our library is limited to a coarse form of \emph{width subtyping}. With \emph{depth subtyping} casting no longer solely dependents on the top-level type structure, but also needs access to the innards in order to change the type of method arguments and return types. This is exactly what \oohaskell's \ensuremath{\Varid{deep'narrow}} function does (see section 5.9 \cite{OOHaskell}), leaning heavily on advanced type-level programming to make such generic record traversals possible. This is where our simple OO approach begins to crack in accordance with the predictions of \oohaskell's authors. Hence, we are forced to stick with a less powerful option where the type parameters are left invariant. As a consequence it is impossible e.g. to insert a \ensuremath{\Conid{Pair}\;\Conid{Point}\;\Conid{Point}} into a list with elements of type \ensuremath{\Conid{Pair}\;\Conid{Object}\;\Conid{Object}}.

Although we cannot use casts at the type parameter position, the typing of \ensuremath{\VarSym{\#}} is compatible with both width and depth subtyping similar to \oohaskell where they covered this fact extensively in section 5.9 and 5.10 \cite{OOHaskell}. We have transcribed their examples without any trouble\footnote{See: \url{https://github.com/rubendg/lightoo}}.

% We start with defining a \emph{Vector} class that serves as a container for two \emph{Points}.

% \begin{code}
% data VectorClass p t = VectorClass {
%     _vectorGetP1  :: IO p
%    ,_vectorGetP2  :: IO p
%    ,_vectorPrint  :: IO ()
%    ,_vectorTail   :: Record t
% }

% vector p1 p2 =
%    (vector' `extends` object) noOverride set_Object_Tail
%    where
%    vector' tail super = do
%       p1r <- newIORef p1
%       p2r <- newIORef p2 
%       return $ \self -> VectorClass {
%           _vectorGetP1  = readIORef p1r
%          ,_vectorGetP2  = readIORef p2r
%          ,_vectorPrint  = do  self # vectorGetP1 >>= ( # pointPrint)
%                               self # vectorGetP2 >>= ( # pointPrint)
%          ,_vectorTail   = tail self
%       }
% \end{code}

% The \emph{Vector} works for any \emph{Point}. 

% \begin{code}
% testVector = do
%   p1   <- new $ printable_point 0
%   p2   <- new $ printable_point 5
%   cp1  <- new $ colored_point 10 "red"
%   cp2  <- new $ colored_point 25 "red"
%   v    <- new $ vector p1 p2
%   cv   <- new $ vector cp1 cp2
% \end{code}

% We define a separate function for calculating the norm of a vector. 

% \begin{code}
% -- Optional type
% norm :: ObjectClass (VectorClass (ObjectClass (PrintablePointClass a1)) a) -> IO Int
% norm v = do
%    p1 <- v # vectorGetP1  ; p2 <- v # vectorGetP2
%    x1 <- p1 # getX ; x2 <- p2 # getX
%    return $ abs (x1 - x2)
% \end{code}

% The vector |cv| of \emph{ColoredPoints} is a subtype of the vector |v| of \emph{PrintablePoints} by virtue of depth subtyping, i.e. |cv| has all the fields |v| has with the methods not not necessarily of the same type but related by subtyping. The subtyping rule for methods is given by $S-ARROW$ \cite{tpl}.

% $ [$\emph{S-ARROW}$] $ \inference{
%   A'_1, ..., A'_n <: A_1, ..., A_n & R <: R'
% }
% {
% A_1, ..., A_n -> IO\ R <: A'_1, ..., A'_n -> IO\ R'
% }

% In order for all occurrences of |#| in |norm| to be well-typed the co-variance (right-hand premise) of the result type of both |vectorGetP1| and |vectorGetP2| is exercised. Hence, |norm| can be applied to vectors of \emph{PrintablePoints} or any of its subtypes exemplified here:

% \begin{code}
%   -- con't
%   putStrLn "Length of v"
%   norm v >>= P.print
%   putStrLn "Length of colored cv"
%   norm cv >>= P.print
% \end{code}

% We extend \emph{Vector} to \emph{Vector1} with a method |vector1Move0| which allows us to move the origin of the vector. 

% \begin{code}
% data Vector1Class a t = Vector1Class {
%      _vector1Move0  :: a -> IO ()
%    , _vector1Tail   :: Record t
% }

% vector1 p1 p2 = 
%   (vector1' `extends` vector p1 p2) noOverride set_Vector_Tail
%   where
%   vector1' tail super =
%     return $ \self -> Vector1Class {
%        _vector1Move0 = \pa -> do
%           p1 <- self # vectorGetP1
%           x <- pa # getX
%           p1 # moveX $ x
%        ,_vector1Tail = tail self
%     }
% \end{code}

% Similar to |v| and |cv| we construct the vectors |v1| and |cv1| respectively a \emph{Vector1} with \emph{PrintablePoints} and \emph{ColoredPoints}. If we intend |v1| to be substitutable with |cv1| its methods must follow $S-ARROW$, in particular the contra-variance rule (left-hand premise) which says that argument of |vector1Move0| should be a |PrintablePoint| or any of its supertypes. We define a function that moves a vector's origin to zero. 

% \begin{code}
% move_origin_to_0 varg = do
%   zero <- new $ printable_point 0
%   varg # vector1Move0 $ zero
% \end{code}

% \begin{code}
% data Vector2Class p t = Vector2Class {
%   -- other vector methods
%   ,_vector2Set0 :: p -> IO ()
%   ,_vector2Tail :: Record t
% }

% vector2 p1 p2 =
%   (vector2' `extends` object) noOverride set_Object_Tail
%   where
%   vector2' tail super = do
%     p1r <- newIORef p1
%     p2r <- newIORef p2 
%     return $ \self -> Vector2Class {
%       ...
%       ,_vector2Set0 = writeIORef p1r 
%       ,_vector2Tail = tail self
%     }

% testVector = do
%   v2  <- new $ vector2 p1 p2
%   cv2 <- new $ vector2 cp1 cp2
% \end{code}

% \begin{code}
% align_origins va vb = do
%   pa <- va # vector2GetP1
%   vb # vector2Set0 $ pa
% \end{code}

% \begin{code}
% set_origin_to_0 varg = do
%   zero <- new $ printable_point 0
%   varg # vector2Set0 $ zero
% \end{code}

\section{Scraping the boilerplate}
\label{sec:boilerplate}

Given our decision to no use extensible records and with Haskell not being tailored towards OO programming it is only logical that there are quite a few steps involved to start implementing a new class:
\begin{enumerate} 
  \item Create a new record for representing the class' interface.
  \item Make it an instance of some \ensuremath{\TClassId{Typeable}} type class.
  \item If the class is a subclass
  \begin{enumerate}
    \item Make each function available as a method by explicitly unrolling the object representation.
    \item Make it an instance of both \ensuremath{\TClassId{Narrow}} and \ensuremath{\TClassId{Widen}}.
  \end{enumerate}
\end{enumerate}

The first and second step are easily done manually. The third step is the most painful part where both the declaration of methods and the implementation of \ensuremath{\TClassId{Narrow}} and \ensuremath{\TClassId{Widen}} require nested record reads and writes which is known to be thorny issue\footnote{For an ongoing discussion see: \url{http://hackage.haskell.org/trac/ghc/wiki/ExtensibleRecords}. There are also quire some approaches that uses lenses for dealing with records \url{http://brandon.si/code/haskell-state-of-the-lens/}}.  

The goal is the scrape as much boilerplate as possible. We see three possible plans of attack to achieve this goal:
\begin{enumerate} 
  \item Create a DSL for OO programming which translates back to regular Haskell. 
  \item Use Template Haskell.
  \item Use the C pre-processor (CPP).
\end{enumerate}

A DSL will lead to the most elegant solution with minimal input required by the programmer. Furthermore, and admittedly more important it can hide all the idiosyncrasies of the encoding. Creating such a DSL does require more research and we leave it as future work. Template Haskell would be an ideal trade-off, unfortunately we cannot use it as it is GHC specific. Consequently we are left with CPP which allows us to derive some of the boilerplate but not all it. For instance, it cannot generate class methods from an interface definition. What it can do is generate the boilerplate instances and tail manipulation functions with some help from the type class system. 

We define two macros for deriving step (2) and (3 b) one for top-level classes \text{\tt DefineClass} and the other for subclasses \text{\tt DefineSubClass}. See \ref{appendix:macros} for a description of their implementation.

\section{Discussion}
\label{sec:discussion}

\subsection{Usability}

When designing a new language one has maximal flexibility with respect to the syntax and semantics. Because we choose to embed our DSL in Haskell we inherit the limitations of the host language. The fact that implementation details reach the surface directly follows from this decision, even though the combinators and CPP macros help with hiding some of them. In particular our reliance on non-extensible records is a great source of trouble and a major factor in the abstraction leaks. Also, the peculiar combination of subtype constraints with tail-polymorphism does not result in an uniform treatment of subtyping. Uniformity is a key aspect in good language design, it contributes to the predictability of a language -- an important factor in the usability of any language. Grasping the subtle details of the library is not for the faint of heart and significantly diminishes its usability.

Besides the limitations of our OO encoding there are also some aspects of Haskell that will trouble any embedding of OO-like code in Haskell. For example, the lack of mutually recursive modules makes properly organizing OO code difficult. When applying the one interface per file scheme it often turns out that method types necessitate that modules importing each other. The lack of recursive modules in Haskell then requires all interface definitions to reside inside a single file, something which is not only cumbersome from a organizational point of view, but also breaks encapsulation at the module level.

Despite these issues we are confident that we have improved the usability of the \emph{"Mutable objects, with tail polymorphism"} approach \cite{OOHaskell}, by providing a set of useful combinators bundled inside a ready to use library. 

\subsection{Efficiency}

Contrary to \oohaskell which uses \emph{polymorphic, extensible records of closures} for their object representation we use a much simpler model: \emph{records of closures}. This decision has various implications for the efficiency of our encoding. 

Similar to \oohaskell our object representation makes no distinction between an object's data and its methods. For efficiency reasons many OO languages do make such a distinction in order to share methods across all instances of a class. However, separating the two destroys the simplicity of the approach. Because we have not attempted to implement the optimization it remains unclear if it is even possible with our encoding.

In \oohaskell method-lookup is linear in the amount of methods. Our encoding has a more efficient method-lookup which is linear in the subclass depth. Unfortunately, we do not have constant-time record extension, but due to the nested record structure record extension that is linear in the subclass depth. 

In an OO language one would typically expect that casting operationally corresponds to the identity function. \oohaskell shows in section 5.7 \cite{OOHaskell} that they support nominal subtypes by explicit nomination of the types on top of their structural record types. Using the nominal subtyping scheme they are able to implement an upcast which operationally corresponds to the identity function. They also suggest that \emph{some forms} of downcasts can be implemented, but do not provide any further details. Our implementation of casting does, unfortunately, not correspond to the identity function, but requires repeated narrowing of which the complexity is given in section \ref{subsub:upcast}. Without the use of extensible records and type-level programming there appears to be no way around this. 

\subsection{Future work}

We have focused on exploring and extending the \emph{Mutable objects, with tail polymorphism} approach. It would be interesting to see whether some of the insights gained by our exploration can be transferred to the other more primitive encodings presented in \oohaskell. Furthermore, in our exploration we have limited ourselves to Haskell with a minimal amount of language extensions, lifting this restriction may yet lead to another OO encoding. Another interesting direction to look into is to see whether there exists a proper translation of Featherweight Java \cite{Igarashi:2001:FJM:503502.503505}, a core calculus embedding the essence of Java, to our encoding.
\chapter{wxAsteroids in the web browser}
\label{chap:wxasteroids}

In this chapter we will put the results from the previous two chapters to use by implementing a subset of wxHaskell that runs inside the web browser. The wxHaskell paper \cite{wxhaskell} explained its design and capabilities by implementing a clone of the classic asteroids game \emph{wxAsteroids} \cite{wxasteroids}. It is a great showcase of the different key aspects of \emph{wxHaskell}: widgets, graphics rendering, and user input. Furthermore, it provides a good example of how typical \emph{wxHaskell} programs are constructed. Instead of porting the fully featured wxAsteroids we have ported a less feature heavy version due to time constraints. Figure \ref{fig:wxaster} shows the original \emph{wxAsteroids} on the left, running on the desktop, next to our port running on the desktop (middle), and in the web browser (right). It shows how LightOO together with the \js FFI can be used to implement the wxWidgets OO design in Haskell in terms of the technologies available in the browser. 

In this chapter we will explain the gist of \emph{wxAsteroids}, the design issues, followed by a more detailed explanation of the implementation.

\begin{figure}[h]
\center
\includegraphics[scale=.3]{resources/WxAsteroids.png}
\includegraphics[scale=.3]{resources/ubuntu_wxasteroids.png}
\includegraphics[scale=.3]{resources/browser_wxasteroids.png}
\caption{The original wxAsteroids on the desktop (left), modified wxAsteroids on the desktop (middle), and in the web browser (right).}
\label{fig:wxaster}
\end{figure}

\section{wxAsteroids}

In the \emph{asteroids} game the player is tasked with carefully maneuvering its spaceship through an asteroid field making sure it does not get hit. The spaceship can move left and right using the arrow keys. There is an inifite supply of asteroids that move vertically downwards. Whenever a rock hits the spaceship, the rock turns into an explosion. In accordance with the original wxAsteroids hitting a rock does not destroy the spaceship. First, we define some constants:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{height}{}\<[11]%
\>[11]{}\mathrel{=}\Numeral{600}{}\<[E]%
\\
\>[B]{}\Varid{width}{}\<[11]%
\>[11]{}\mathrel{=}\Numeral{300}{}\<[E]%
\\
\>[B]{}\Varid{diameter}{}\<[11]%
\>[11]{}\mathrel{=}\Numeral{24}{}\<[E]%
\\
\>[B]{}\Varid{chance}{}\<[11]%
\>[11]{}\mathrel{=}\Numeral{0.1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{height}} and \ensuremath{\Varid{width}} values determine the dimensions of the game field. The \ensuremath{\Varid{diameter}} represents the diameter of a rock, and the \ensuremath{\Varid{chance}} determines the chance a new rock appears in a given time frame. The \ensuremath{\Varid{asteroids}} function constructs the user interface, and is run by the \ensuremath{\Varid{start}} function: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{60}{@{}>{\hspre}l<{\hspost}@{}}%
\column{67}{@{}>{\hspre}l<{\hspost}@{}}%
\column{77}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{asteroids}\ConSym{::}\TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{asteroids}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{vrocks}{}\<[13]%
\>[13]{}\leftarrow \Varid{varCreate}\;\Varid{randomRocks}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{vship}{}\<[13]%
\>[13]{}\leftarrow \Varid{varCreate}\mathbin{\$}\Varid{div}\;\Varid{width}\;\Numeral{2}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{w}{}\<[13]%
\>[13]{}\leftarrow \Varid{window}\;\Conid{Nothing}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{t}{}\<[13]%
\>[13]{}\leftarrow \Varid{timer}\;\Varid{w}\;{}\<[25]%
\>[25]{}[\mskip1.5mu \Varid{interval}{}\<[39]%
\>[39]{}\ConSym{:=}\Numeral{50}{}\<[E]%
\\
\>[25]{},\Varid{on}\;\Varid{command}{}\<[39]%
\>[39]{}\ConSym{:=}\Varid{advance}\;\Varid{w}\;\Varid{vrocks}{}\<[E]%
\\
\>[25]{}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{set}\;\Varid{w}\;{}\<[12]%
\>[12]{}[\mskip1.5mu {}\<[12E]%
\>[15]{}\Varid{area}{}\<[28]%
\>[28]{}\ConSym{:=}\Varid{rect}\;(\Varid{pt}\;\Numeral{0}\;\Numeral{0})\;(\Varid{sz}\;\Varid{width}\;\Varid{height}){}\<[E]%
\\
\>[15]{}\Varid{on}\;\Varid{paint}{}\<[28]%
\>[28]{}\ConSym{:=}\Varid{draw}\;\Varid{vrocks}\;\Varid{vship}{}\<[E]%
\\
\>[12]{},{}\<[12E]%
\>[15]{}\Varid{on}\;\Varid{leftKey}{}\<[28]%
\>[28]{}\ConSym{:=}\Varid{varUpdate}\;\Varid{vship}\;{}\<[48]%
\>[48]{}(\lambda \Varid{x}\to \Varid{max}\;{}\<[60]%
\>[60]{}\Numeral{0}\;{}\<[67]%
\>[67]{}(\Varid{x}\VarSym{-}\Numeral{5})){}\<[77]%
\>[77]{}\sequ \Varid{return}\;(){}\<[E]%
\\
\>[12]{},{}\<[12E]%
\>[15]{}\Varid{on}\;\Varid{rightKey}{}\<[28]%
\>[28]{}\ConSym{:=}\Varid{varUpdate}\;\Varid{vship}\;{}\<[48]%
\>[48]{}(\lambda \Varid{x}\to \Varid{min}\;{}\<[60]%
\>[60]{}\Varid{width}\;{}\<[67]%
\>[67]{}(\Varid{x}\VarSym{+}\Numeral{5})){}\<[77]%
\>[77]{}\sequ \Varid{return}\;(){}\<[E]%
\\
\>[12]{}\mskip1.5mu]{}\<[12E]%
\\[\blanklineskip]%
\>[B]{}\Varid{main}\mathrel{=}\Varid{start}\;\Varid{asteroids}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

First two \emph{mutable} variables are created: \ensuremath{\Varid{vrocks}} holds an infinite list containing the positions
of all the future rock positions, \ensuremath{\Varid{vship}} contains the current position of the spaceship. 

Next, we create a top-level window that serves as a placeholder for the game. The first parameter denotes a potential parent window, the second a list of properties. Subsequently we attach a timer to the window firing every 50 milliseconds. On each tick, it calls \ensuremath{\Varid{advance}}, moving all rocks to their next position and updating the screen.

Finally, we set a few attributes on the window \ensuremath{\Varid{w}}. We assign it an \ensuremath{\Varid{area}} with the given constant dimensions. The other attributes are prefixed with \ensuremath{\Varid{on}} designating event handlers. The \ensuremath{\Varid{paint}} event handler is invoked when a repaint request is made, and draws the current game state to the screen through \ensuremath{\Varid{draw}} (later defined). Pressing the left or right arrow key changes the \emph{x} position of the spaceship.

The \ensuremath{\Varid{vrocks}} variable contains an infinite list of all future rock positions. This infinite list is generated by the \ensuremath{\Varid{randomRocks}} function which depends on random number generation. Because at the time of writing there was no back-end support for random number generation through the standard \ensuremath{\Conid{\Conid{System}.Random}} library we used a more \emph{ad hoc} solution:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 Math.random()\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{randomNumber}\ConSym{::}\TConId{IO}\;\TConId{Double}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{rand}\;\anonymous \mathrel{=}\Varid{unsafePerformIO}\;\Varid{randomNumber}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{randoms}\ConSym{::}[\mskip1.5mu \TConId{Double}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{randoms}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{inf}\mathrel{=}\bot \mathbin{:}\Varid{inf}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Varid{map}\;\Varid{rand}\;\Varid{inf}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{randoms}} function provides a infinite list of random numbers in the range [0,1). It works by mapping a random number generator \ensuremath{\Varid{rand}} over an infinite list. Note that this only works because \ensuremath{\Varid{rand}} is not subject to let floating. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{randomRocks}\mathrel{=}\Varid{flatten}\;[\mskip1.5mu \mskip1.5mu]\;(\Varid{map}\;\Varid{fresh}\;\Varid{randoms}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{fresh}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{r}\VarSym{>}\Varid{chance}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}{}\<[16]%
\>[16]{}\mathrel{=}[\mskip1.5mu \Varid{track}\;(\Varid{floor}\;(\Varid{fromIntegral}\;\Varid{width}\VarSym{*}\Varid{r}\mathbin{/}\Varid{chance}))\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{track}\;\Varid{x}\mathrel{=}[\mskip1.5mu \Varid{point}\;\Varid{x}\;(\Varid{y}\VarSym{-}\Varid{diameter})\mid \Varid{y}\leftarrow [\mskip1.5mu \Numeral{0},\Numeral{6}\VarSym{...}\Varid{height}\VarSym{+}\Numeral{2}\VarSym{*}\Varid{diameter}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{flatten}\;\Varid{rocks}\;(\Varid{t}\mathbin{:}\Varid{ts})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;{}\<[8]%
\>[8]{}\Varid{now}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{map}\;\Varid{head}\;\Varid{rocks}{}\<[E]%
\\
\>[8]{}\Varid{later}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{filter}\;(\neg \hsdot{\circ }{.}\Varid{null})\;(\Varid{map}\;\Varid{tail}\;\Varid{rocks}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Varid{now}\mathbin{:}\Varid{flatten}\;(\Varid{t}\plus \Varid{later})\;\Varid{ts}{}\<[E]%
\\
\>[B]{}\Varid{flatten}\;\Varid{rocks}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\Varid{error}\;\Char{\char34 Empty~rocks~list~not~expected~in~function~flatten\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{fresh}} function is mapped over \ensuremath{\Varid{randoms}}. It compares each number against the \ensuremath{\Varid{chance}} constant,
and if a rock should appear it generates a finite list of future rock positions that move the rock from the top
to the bottom of the screen, otherwise it returns the empty list. Finally, the \ensuremath{\Varid{flatten}} function flattens this list into a list of time frames, where each element contains the position of every rock in that particular time frame.

The \ensuremath{\Varid{advance}} function is called on every timer tick:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{advance}\;\Varid{vrocks}\;\Varid{w}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Varid{r}\mathbin{:}\Varid{rs})\leftarrow \Varid{varGet}\;\Varid{vrocks}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{varSet}\;\Varid{vrocks}\;\Varid{rs}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{repaint}\;\Varid{w}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It moves \ensuremath{\Varid{vrocks}} to the next time frame (its tail), and request a repaint of the window (\ensuremath{\Varid{w}}). 
A repaint causes the \ensuremath{\Varid{paint}} event handler to be triggered which in turn calls \ensuremath{\Varid{draw}} with two parameters: the \emph{graphics context} (\ensuremath{\Varid{gc}}) and view area (\ensuremath{\Varid{view}}). The graphics context paints on the window area on the screen, but is in principal independent of its back-end. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{draw}\;\Varid{vrocks}\;\Varid{vship}\;\Varid{gc}\;\Varid{view}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{rocks}{}\<[10]%
\>[10]{}\leftarrow \Varid{varGet}\;\Varid{vrocks}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{x}{}\<[10]%
\>[10]{}\leftarrow \Varid{varGet}\;\Varid{vship}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{shipLocation}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{point}\;{}\<[28]%
\>[28]{}\Varid{x}\;(\Varid{height}\VarSym{-}\Numeral{2}\VarSym{*}\Varid{diameter}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{positions}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{head}\;{}\<[28]%
\>[28]{}\Varid{rocks}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{collisions}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{map}\;{}\<[28]%
\>[28]{}(\Varid{collide}\;\Varid{shipLocation})\;\Varid{positions}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{drawShip}\;\Varid{gc}\;\Varid{shipLocation}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{mapM}\;(\Varid{drawRock}\;\Varid{gc})\;(\Varid{zip}\;\Varid{positions}\;\Varid{collisions}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{draw}} function reads the current rock and spaceship positions, and positions the spaceship at the current x, and fixed y-position. Then it checks if there are any \emph{collisions} between the spaceship and any of the rocks. Finally, we draw the spaceship and all the rocks onto the screen. The \ensuremath{\Varid{collide}} function simply checks whether a rock has entered the spaceship's comfort zone given their \emph{positions}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{collide}\;\Varid{pos0}\;\Varid{pos1}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{distance}\mathrel{=}\Varid{vecLength}\;(\Varid{vecBetween}\;\Varid{pos0}\;\Varid{pos1}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Varid{distance}\leq \Varid{fromIntegral}\;\Varid{diameter}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Both entities are drawn using the \ensuremath{\Varid{drawBitmap}} function. It takes a graphics context, bitmap, position, transparency mode (not implemented), and a list of properties as arguments. Dependent on whether a collision occured the picture of a rock changes to either a normal rock or a exploded one.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{drawShip}\;\Varid{gc}\;\Varid{pos}\mathrel{=}\Varid{drawBitmap}\;\Varid{gc}\;\Varid{ship}\;\Varid{pos}\;\Conid{True}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{drawRock}\;\Varid{gc}\;(\Varid{pos},\Varid{collides})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{rockPicture}\mathrel{=}\Keyword{if}\;\Varid{collides}\;\Keyword{then}\;\Varid{burning}\;\Keyword{else}\;\Varid{rock}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Varid{drawBitmap}\;\Varid{gc}\;\Varid{rockPicture}\;\Varid{pos}\;\Conid{True}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Finally, we specify the resources that we used.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rock}{}\<[10]%
\>[10]{}\mathrel{=}\Varid{bitmap}\;\Char{\char34 rock.ico\char34}{}\<[E]%
\\
\>[B]{}\Varid{burning}{}\<[10]%
\>[10]{}\mathrel{=}\Varid{bitmap}\;\Char{\char34 burning.ico\char34}{}\<[E]%
\\
\>[B]{}\Varid{ship}{}\<[10]%
\>[10]{}\mathrel{=}\Varid{bitmap}\;\Char{\char34 ship.ico\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The summary we just gave does not differ much from the one given in \cite{wxhaskell}. We have simplified the porting effort by omitting features such as the menu, sound effects, and status field. Furthermore, we render the game on top of a \ensuremath{\Varid{window}} instead of a \ensuremath{\Varid{frame}} (which features all the standard decorations such as a title, maximize, minimize, and closing buttons). Besides the ommittances the source has remained largely the same. 

\section{Design}

\subsection{Approach}

We took wxHaskell version 0.12.1.4 from hackage and performed a depth first search on the features that
needed to be supported in order for wxAsteroids to work. All unused features were commented out and all irrelevant parts that dealt with the implementation details of the C++ back-end were removed. Furthermore, all relevant functions exposed through wxcore were undone from their implementation and replaced by \ensuremath{\Varid{error}\;\Char{\char34 to~be~implemented\char34}}. This allowed us to type check the whole codebase without yet having the implementation at hand. At all times we kept our codebase compatible with \emph{ghci} by using CPP macros to conditionally import modules. With hindsight this turned out to be well worth the effort. Due to its superior error reporting capabilities we could more easily pinpoint programming errors. It also served as a useful reference for improving UHC by occassionally catching errors in its implementation. 

Fortunately, none of the implementation details of \emph{wxcore} leak to \emph{wx}. This allowed us to leave the \emph{wx} sources largely untouched. We used the elaborate wxWidgets documentation and source code as a reference for implementing wxcore. 

\subsection{Objects}

In order to maintain some type safety when communicating with C++, wxcore assigns phantom types to objects, with as top-level type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Object}\;\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[16E]%
\>[19]{}\Conid{Object}{}\<[28]%
\>[28]{}\mathbin{!}(\Conid{Ptr}\;\Varid{a}){}\<[E]%
\\
\>[16]{}\mid {}\<[16E]%
\>[19]{}\Conid{Managed}{}\<[28]%
\>[28]{}\mathbin{!}(\Conid{ForeignPtr}\;(\Conid{TManagedPtr}\;\Varid{a})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

All objects are either a normal or managed pointer to an object that lives in the C++ world. For example, the type of a window (\ensuremath{\Conid{Window}\;\Varid{a}}) is a type synonym that expands to \ensuremath{\Conid{Object}\;(\Conid{WxObject}\;(\Conid{CEvtHandler}\;(\Conid{CWindow}\;\Varid{a})))}. The type structure used here is identical to the type structure we used to program OO in Haskell. This turns out the be very useful because it allows the implemention of wxcore functions without (in most cases) altering their interface which makes it very close to a drop-in replacement for the original wxcore implementation.

The \ensuremath{\Conid{Object}} data type is replaced with a record \ensuremath{\Conid{IObject}} with a corresponding implementation: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{object}\mathrel{=}\Keyword{clazz}\mathbin{\$}\lambda \Varid{tail}\;\Varid{self}\to \Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{flag}\leftarrow \Varid{newIORef}\;\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\;\Conid{IObject}\;\{\mskip1.5mu {}\<[E]%
\\
\>[4]{}\hsindent{4}{}\<[8]%
\>[8]{}\Varid{setFlag}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{writeIORef}\;\Varid{flag}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{},\Varid{getFlag}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{readIORef}\;\Varid{flag}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{},\Varid{\char95 objectTail}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In \emph{Graphics.UI.WXCore.Types} there are quite some methods defined for objects with the assumption that they are implemented as pointers to C++ objects. Some of these methods are replaced whereas others do not make sense anymore. For example, \ensuremath{\Varid{objectCast}} is replaced by \ensuremath{\Varid{upcast}} and \ensuremath{\Varid{downcast}}, \ensuremath{\Varid{objectIsNull}} makes no sense anymore as we always have evidence that an object exists there is no need to check whether it is null, \ensuremath{\Varid{objectDelete}} is also irrelevant we can simply rely on garbage collection.

What has also changes is object identity. Before, object identity boiled down to pointer equality. The idiomatic Haskell approach to test values for equivalence is by structural equivalence. However, objects are black boxes that hide their data. What makes two objects identical becomes subject to interpretation of the programmer. Hence, we implement an equality test similar to pointer equality \cite{tpl}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sameObject}\;\Varid{a}\;\Varid{b}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{a}\VarSym{\#}\Varid{setFlag}\mathbin{\$}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{b}\VarSym{\#}\Varid{setFlag}\mathbin{\$}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{a}\VarSym{\#}\Varid{getFlag}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Every object has a \ensuremath{\Varid{flag}} associated with it. The \ensuremath{\Varid{sameObject}} function tests if changing it in \ensuremath{\Varid{a}} also changes it in \ensuremath{\Varid{b}} essentially testing pointer equality.

\subsection{Organization}

We have set-up wxcore such that every class definition resides in its own module in similar to header files in C++. Implementations of a particular class import the interface definition and re-export it together with a class for constructing instances. Interface definitions typically need other interface definitions to define their type. This is no problem unless both definitions depend on each others types. Unfortunately, this is a quite common scenario in OO languages. Since Haskell does not support cyclic imports there is no other option than placing the interface definitions in the same module breaking the organization scheme. 

\subsection{Mapping to the web browser}

The wxcore abstractions at some point need to interface to the target platform. The web browser already offers a great deal of functionality that make it easy create GUIs. We choose the easy route by  piggybacking on much of the high-level technology is already present. We let a wxWidget window correspond to a HTML div element. Asteroids draws on a graphics context associated with a window. As back-end for the graphics context we use a HTML5 canvas element, because drawing on divs is not possible without CSS3 hacks. The graphics context is created on demand and covers the whole window. We could just as well have used SVG as a back-end, but it was easier to use the canvas due to its small API.

Event listeners are registered on the div representing the window. When an event is triggered by the target platform its event object properties are read and mapped to a subclass of the \emph{Event} object. This object is then dispatched internally inside the wxWidgets event system which invokes to the appropriate event listeners. Decoupling the native event mechanism from the wxWidgets event mechanism provides the opportunity to trigger custom events not originating from the target platform. 

Finally, initialization of the application is done through the \ensuremath{\Varid{start}} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{start}\;\Varid{io}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{w}{}\<[7]%
\>[7]{}\leftarrow \Varid{htmlWindow}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Wrap a haskell function as if it were a regular JavaScript function}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{cb}{}\<[7]%
\>[7]{}\leftarrow \Varid{wrapFunc}\;\Varid{io}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Comment{  -{}-\enskip  Set the onload event on the window object}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{set}\;\Char{\char34 onload\char34}\;\Varid{cb}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The moment the web page is loaded the application starts. 

\section{Implementation details}

\subsection{Subtyping}

WxHaskell makes extensive use of a phantom type structure for modelling a type safe interface to foreign objects. In chapter 5, section \ref{subsubsec:changeinsemantics} we explained that functions consuming abstract objects (i.e. objects with their tail left polymorph) are inhibited from using casts on those objects. Because there are many places where wxHaskell uses polymorphic objects - for attribute classes, as function arguments, inside properties - it make sense to explore whether this can persist if we provide a Haskell implementation, and if changes are required how this affects the interaction of the different parts of wxHaskell.

We start by looking at the \emph{Graphics.UI.WX.Classes} module, part of the \emph{wx} library. It defines a host of type classes for capturing common attributes of widgets. For example, there is a type class that ranges over widgets that can be positioned and sized:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{Dimensions}\;\Varid{w}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{area}{}\<[3E]%
\>[13]{}\ConSym{::}\Conid{Attr}\;\Varid{w}\;\Conid{Rect}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[3E]%
\ColumnHook
\end{hscode}\resethooks

Typically, these attribute classes are instantiated by wxHaskell with polymorphic objects:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\Conid{Dimensions}\;(\Conid{Window}\;\Varid{a})\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\VarSym{...}{}\<[3E]%
\ColumnHook
\end{hscode}\resethooks

Fortunately, this part of wxHaskell is not affected by our implementation because it turns out that in all encountered cases the concerning widget is used solely as the first argument for invoking its own methods. Nevertheless it would have been possible to use these type classes if we were forced to instantiate them with concrete objects, there would simply be more explicit casting compensating for the loss in expressiveness in the types.

However, we have encountered cases wherein we were forced to change the type of a function. For instance, in the case of event processing wxHaskell invokes the \ensuremath{\Varid{evtHandlerProcessEvent}} method passing it any subtype of the \emph{Event} class.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{evtHandlerProcessEvent}\ConSym{::}\Conid{EvtHandler}\;\Varid{a}\to \Conid{Event}\;\Varid{b}\to {}\<[55]%
\>[55]{}\TConId{IO}\;\TConId{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Because an \emph{Event} object ends up as an argument to a callback function, which typically needs to know the event type (e.g. a mouse or keyboard event), there will be some casting involved. Hence we are forced to change the function type making it accept only concrete \emph{Event} objects. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{evtHandlerProcessEvent}\ConSym{::}\Conid{EvtHandler}\;\Varid{a}\to \Conid{Event}\to \TConId{IO}\;\TConId{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Another thing we encountered that sometimes proves useful is to be able to change the type of property (\ensuremath{\Conid{Prop}\;\Varid{w}}), e.g. from a \ensuremath{\Conid{Prop}\;\Conid{Frame}} to a \ensuremath{\Conid{Prop}\;\Conid{Window}}. The \emph{wx} library already defines casting functions for \ensuremath{\Conid{Attr}\;\Varid{w}\;\Varid{a}} and \ensuremath{\Conid{Prop}\;\Varid{w}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{castProp}\ConSym{::}(\Varid{v}\to \Varid{w})\to \Conid{Prop}\;\Varid{w}\to \Conid{Prop}\;\Varid{v}{}\<[E]%
\\
\>[B]{}\Varid{castProp}\;\Varid{coerce}\;\Varid{prop}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{case}\;\Varid{prop}\;\Keyword{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{attr}\ConSym{:=}\Varid{x}){}\<[19]%
\>[19]{}\to (\Varid{castAttr}\;\Varid{coerce}\;\Varid{attr})\ConSym{:=}\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{attr}\ConSym{:\char126 }\Varid{f}){}\<[19]%
\>[19]{}\to (\Varid{castAttr}\;\Varid{coerce}\;\Varid{attr})\ConSym{:\char126 }\Varid{f}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{attr}\ConSym{::=}\Varid{f}){}\<[19]%
\>[19]{}\to (\Varid{castAttr}\;\Varid{coerce}\;\Varid{attr})\ConSym{::=}(\lambda \Varid{v}\to \Varid{f}\;(\Varid{coerce}\;\Varid{v})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{attr}\ConSym{::\char126 }\Varid{f}){}\<[19]%
\>[19]{}\to (\Varid{castAttr}\;\Varid{coerce}\;\Varid{attr})\ConSym{::\char126 }(\lambda \Varid{v}\;\Varid{x}\to \Varid{f}\;(\Varid{coerce}\;\Varid{v})\;\Varid{x}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{castAttr}\ConSym{::}(\Varid{v}\to \Varid{w})\to \Conid{Attr}\;\Varid{w}\;\Varid{a}\to \Conid{Attr}\;\Varid{v}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{castAttr}\;\Varid{coerce}\;(\Conid{Attr}\;\Varid{name}\;\Varid{getter}\;\Varid{setter}\;\Varid{upd})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Attr}\;{}\<[9]%
\>[9]{}\Varid{name}\;{}\<[15]%
\>[15]{}(\lambda \Varid{v}\to \Varid{getter}\;(\Varid{coerce}\;\Varid{v}))\;(\lambda \Varid{v}\;\Varid{x}\to (\Varid{setter}\;(\Varid{coerce}\;\Varid{v})\;\Varid{x}))\;{}\<[E]%
\\
\>[15]{}(\lambda \Varid{v}\;\Varid{f}\to \Varid{upd}\;(\Varid{coerce}\;\Varid{v})\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Both functions take a coercion function and consistently apply it to the argument (contravariant) positions. The \ensuremath{\Conid{Prop}\;\Varid{w}} type is actually a contravariant functor with \ensuremath{\Varid{castProp}} as mapping function, because its type parameter \ensuremath{\Varid{w}} is only used in contravariant positions.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{Contravariant}\;\Varid{f}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{contramap}\ConSym{::}(\Varid{a}\to \Varid{b})\to \Varid{f}\;\Varid{b}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{Contravariant}\;\Conid{Prop}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{contramap}\mathrel{=}\Varid{castProp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We specialize \ensuremath{\Varid{contramap}} for upcasting the properties:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{upcastProp}\ConSym{::}\forall \Varid{v}\hsforall \;\Varid{w}\hsdot{\circ }{.}\Varid{w} \TClassId{$\ \succ\ $} \Varid{v}\Rightarrow \Conid{Prop}\;\Varid{v}\to \Conid{Prop}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\Varid{upcastProp}\;\Varid{p}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{contramap}\;(\Varid{handleErr}\hsdot{\circ }{.}(\Varid{downcast}\ConSym{::}\Varid{w}\to \TConId{Maybe}\;\Varid{v}))\;\Varid{p}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{handleErr}\mathrel{=}\Varid{maybe}\;(\Varid{error}\mathbin{\$}\Char{\char34 Non-existent~property:~\char34}\plus \Varid{propName}\;\Varid{p})\;\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

That the \ensuremath{\Varid{upcastProp}} function is implemented in terms of \ensuremath{\Varid{downcast}} may seem somewhat counterintuitive. Upcasting a property does not change the getter and setter stored in the attribute, but wraps them inside a new function  accepting the upcasted type which is subsequently coerced back (downcasted) to the old type and applied to the wrapped function. Similarly, we define its dual:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{downcastProp}\ConSym{::}\forall \Varid{v}\hsforall \;\Varid{w}\hsdot{\circ }{.}\Varid{w} \TClassId{$\ \prec\ $} \Varid{v}\Rightarrow \Conid{Prop}\;\Varid{v}\to \Conid{Prop}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\Varid{downcastProp}\;\Varid{p}\mathrel{=}\Varid{contramap}\;(\Varid{upcast}\ConSym{::}\Varid{w}\to \Varid{v})\;\Varid{p}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 
\subsection{Interfacing with the DOM}

For platform dependent features the implementation needs to communicate with \js. In chapter \ref{chap:jsffi} we developed some techniques which we are now going to use for interfacing with \js, in particular the DOM. The DOM is the primary interface to browser functionality. Its interfaces are specified in IDL (Interface Definition Language), here follows an excerpt of the \emph{HTMLElement} IDL definition\footnote{\url{http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html\#htmlelement}}:

\begin{tabbing}\tt
~interface~HTMLElement~\char58{}~Element~\char123{}\\
\tt ~~~attribute~DOMString~title\char59{}\\
\tt ~~~\char46{}\char46{}\char46{}\\
\tt ~~~readonly~attribute~boolean~isContentEditable\char59{}\\
\tt ~~~\char46{}\char46{}\char46{}\\
\tt ~~~\char91{}TreatNonCallableAsNull\char93{}~attribute~Function\char63{}~onkeydown\char59{}\\
\tt ~~~\char46{}\char46{}\char46{}\\
\tt ~\char125{}
\end{tabbing}

The top-level declaration provides a name for the interface, optionally followed by a colon and the interface it extends from. The body contains all attributes annotated with their contained type, additional constraints on the interpretation of the contained data (\emph{TreatNonCallableAsNull}), and its usage (\emph{readonly}).

To model the interface types we simply extend \ensuremath{\Conid{JSObject}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{CHTMLElement}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{HTMLElement\char95 }\;\Varid{a}\mathrel{=}\Conid{Element}\;(\Conid{CHTMLElement}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{HTMLElement}\mathrel{=}\Conid{HTMLElement\char95 }\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CElement}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Element\char95 }\;\Varid{a}\mathrel{=}\Conid{Node\char95 }\;(\Conid{CElement}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Element}\mathrel{=}\Conid{Element\char95 }\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{CNode}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Node\char95 }\;\Varid{a}\mathrel{=}\Conid{JSObject}\;(\Conid{CNode}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Node}\mathrel{=}\Conid{Node\char95 }\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The structure is exactly the same as the one used by wxHaskell to model C++ object types in Haskell. It is even a better fit for \js, because its single prototype chain does not naturally allow the modeling of multiple inheritance, of which it is known that it cannot be practically modeled with this type structure \cite{Fluet:2006:PTS:1180085.1180088}.

For wxAsteroids it is important to know when the user holds down either the left or right key. We import the \emph{onkeydown} event using the \ensuremath{\Varid{eventJSRef}} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{onkeydown}{}\<[12]%
\>[12]{}\mathrel{=}\Varid{eventJSRef}\;\Char{\char34 onkeydown\char34}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It captures the onkeydown property as a read-write \ensuremath{\Conid{JSRef}}, interprets the \emph{TreatNonCallableAsNull} constraint as a \ensuremath{\TConId{Maybe}}, and can be used to import any of the event handlers that are part of an \emph{HTMLElement}. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eventJSRef}\ConSym{::}\TConId{String}\to \Conid{HTMLElement\char95 }\;\Varid{a}\to \Conid{JSRef}\;\Conid{ReadWrite}\;(\TConId{Maybe}\;(\Conid{Event}\to \TConId{IO}\;())){}\<[E]%
\\
\>[B]{}\Varid{eventJSRef}\;\Varid{id}\;\Varid{e}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{let}\;\Varid{get}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}\Varid{f}\leftarrow \Varid{getProperty}\;\Varid{id}\;\Varid{e}{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}\Keyword{if}\;\Varid{isNull}\;\Varid{f}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Keyword{then}\;\Varid{return}\;\Conid{Nothing}{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}\Keyword{else}\;\Varid{unwrapFunc1}\;(\Varid{unsafeCoerce}\;\Varid{f}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{set}\;\Conid{Nothing}{}\<[21]%
\>[21]{}\mathrel{=}\Varid{setProperty\char95 }\;\Varid{id}\;\Varid{\char95 null}\;\Varid{e}{}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Varid{set}\;(\Conid{Just}\;\Varid{f}){}\<[21]%
\>[21]{}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{f}\leftarrow \Varid{wrapFunc1}\;\Varid{f}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{setProperty\char95 }\;\Varid{id}\;\Varid{f}\;\Varid{e}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{in}\;\Varid{newJSRef}\;\Varid{get}\;\Varid{set}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Internally it creates a new \ensuremath{\Conid{JSRef}} with a getter and setter that respectively read and write the property. Because there is no automatic back and forth conversion from Haskell functions to \js functions we use \ensuremath{\Varid{wrapFunc1}} and \ensuremath{\Varid{unwrapFunc1}} for respectively wrapping and unwrapping 1-argument functions. These functions are part of a larger family of wrapping and unwrapping functions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 wrapper\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{wrapFunc}\ConSym{::}\TConId{IO}\;()\to \TConId{IO}\;(\Conid{JSFunction}\;(\TConId{IO}\;())){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 wrapper\char34}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{wrapFunc1}\ConSym{::}(\Varid{a}\to \TConId{IO}\;())\to \TConId{IO}\;(\Conid{JSFunction}\;(\Varid{a}\to \TConId{IO}\;())){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 dynamic\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{unwrapFunc}\ConSym{::}\Conid{JSFunction}\;(\TConId{IO}\;())\to \TConId{IO}\;(\TConId{IO}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{foreign}\;\Keyword{import}\;\Keyword{js}\;\Char{\char34 dynamic\char34}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{unwrapFunc1}\ConSym{::}\Conid{JSFunction}\;(\Varid{a}\to \TConId{IO}\;())\to \TConId{IO}\;(\Varid{a}\to \TConId{IO}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Unfortunately, the wrapping and unwrapping is not tracked by the RTS. Repeated getting and setting will grow a series of wrapping and unwrapping functions around the original function causing performance problems. Also, the use of Haskell strings for accessing \js properties is a root of performance problems as well. Strings need to be packed before the are in \js format requiring order $n$ time where $n$ is the length of the string. A better solution would be to use overloaded strings\footnote{\url{http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/type-class-extensions.html\#overloaded-strings}} with compiler support for representing Haskell strings directly as \js strings. Besides the technical details \ensuremath{\Varid{eventJSRef}} is a definite improvement upon the \emph{laisser faire} attitude of \js where a \ensuremath{\Conid{TreatNonCallableAsNull}} constraint depends run-time type checking, the event handler function can be any type of function making it very easy to let programming errors go by unnoticed.



\subsection{Implementing wxTimer}

We discuss the implementation of the \emph{wxTimer} object, a small and relatively self-contained example that touches many of the aspects discussed thus far. We start at \emph{wxAsteroids} moving stepwise from \emph{wx} to the \emph{wxcore} implementation.

First, in \emph{wxAsteroids}, we create a timer and attach it to a \emph{Window}. We set the timer such that it calls \ensuremath{\Varid{advance}} every 50 milliseconds.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}%
\column{BE}{@{}l@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}c<{\hspost}@{}}%
\column{16E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\VarSym{...}{}\<[BE]%
\\[\blanklineskip]%
\>[B]{}\Varid{t}{}\<[BE]%
\>[4]{}\leftarrow \Varid{timer}\;\Varid{w}\;{}\<[16]%
\>[16]{}[\mskip1.5mu {}\<[16E]%
\>[19]{}\Varid{interval}{}\<[31]%
\>[31]{}\ConSym{:=}\Numeral{50}{}\<[E]%
\\
\>[16]{},{}\<[16E]%
\>[19]{}\Varid{on}\;\Varid{command}{}\<[31]%
\>[31]{}\ConSym{:=}\Varid{advance}\;\Varid{vrocks}\;\Varid{w}{}\<[E]%
\\
\>[16]{}\mskip1.5mu]{}\<[16E]%
\\[\blanklineskip]%
\>[B]{}\VarSym{...}{}\<[BE]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{timer}} function is defined in \ensuremath{\Conid{\Conid{Graphics}.\Conid{UI}.\Conid{WX}.Timer}}, part of the \emph{wx} package:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Timer}{}\<[13]%
\>[13]{}\mathrel{=}\Conid{TimerEx}\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{timer}\ConSym{::}\Conid{Window}\;\Varid{a}\to [\mskip1.5mu \Conid{Prop}\;\Conid{Timer}\mskip1.5mu]\to \TConId{IO}\;\Conid{Timer}{}\<[E]%
\\
\>[B]{}\Varid{timer}\;\Varid{parent}\;\Varid{props}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Keyword{do}\;\Varid{t}\leftarrow \Varid{windowTimerCreate}\;\Varid{parent}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{timerStart}\;\Varid{t}\;\Numeral{1000}\;\Conid{False}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{set}\;\Varid{t}\;\Varid{props}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{return}\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It creates a new timer using \ensuremath{\Varid{windowTimerCreate}}, sets the default resolution to 1 second, and sets some properties on the object. The \ensuremath{\Varid{interval}} attribute is specific to a timer object, and hence has its widget type fixed to a concrete timer.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{interval}\ConSym{::}\Conid{Attr}\;\Conid{Timer}\;\TConId{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{command}} attribute is overloaded on the widget type as it can be reused by other widgets for setting zero-argument event handlers.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{Commanding}\;\Varid{w}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{command}\ConSym{::}\Conid{Event}\;\Varid{w}\;(\TConId{IO}\;()){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{instance}\;\Conid{Commanding}\;\Conid{Timer}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{command}\mathrel{=}\Varid{newEvent}\;\Char{\char34 command\char34}\;\Varid{timerGetOnCommand}\;\Varid{timerOnCommand}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Before we move on the the \emph{wxcore} implementation, we only need to make a minor adjustment to the type signature of \ensuremath{\Varid{timer}} to account for name mismatch:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{timer}\ConSym{::}\Conid{Window\char95 }\;\Varid{a}\to [\mskip1.5mu \Conid{Prop}\;\Conid{Timer}\mskip1.5mu]\to \TConId{IO}\;\Conid{Timer}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In \emph{wxcore} we find the definitions for \ensuremath{\Varid{timerGetOnCommand}}, \ensuremath{\Varid{timerOnCommand}}, etc. 
These functions are implemented with the C++ back-end in mind. For example, the \ensuremath{\Varid{timerGetOnCommand}} and \ensuremath{\Varid{timerOnCommand}} functions rely on some C++ wrapper code that allows storing and retrieval of Haskell closures. It ensures that Haskell functions can be safely passed into the C++ world without Haskell garbage collecting them.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{timerOnCommand}\ConSym{::}\Conid{TimerEx}\;\Varid{a}\to \TConId{IO}\;()\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{timerOnCommand}\;\Varid{timer}\;\Varid{io}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Keyword{do}\;\Varid{closure}\leftarrow \Varid{createClosure}\;\Varid{io}\;(\lambda \Varid{ownerDeleted}\to \Varid{return}\;())\;(\lambda \Varid{ev}\to \Varid{io}){}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{timerExConnect}\;\Varid{timer}\;\Varid{closure}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{timerGetOnCommand}\ConSym{::}\Conid{TimerEx}\;\Varid{a}\to \TConId{IO}\;(\TConId{IO}\;()){}\<[E]%
\\
\>[B]{}\Varid{timerGetOnCommand}\;\Varid{timer}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Keyword{do}\;\Varid{closure}\leftarrow \Varid{timerExGetClosure}\;\Varid{timer}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{unsafeClosureGetState}\;\Varid{closure}\;(\Varid{return}\;()){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Obviously, these implementations make no sense in our situation. We leave the function types in tact, but reimplement their functionality in terms of calls to a timer object. Before we present their new implementation we first provide a sample of the C++ implementation of the timer object:

\begin{tabbing}\tt
~class~wxTimerBase~\char58{}~public~wxEvtHandler\\
\tt ~\char123{}\\
\tt ~~~public\char58{}\\
\tt ~~~~~wxTimerBase\char40{}wxEvtHandler~\char42{}owner\char44{}~int~timerid~\char61{}~wxID\char95{}ANY\char41{}~\char123{}~\\
\tt ~~~~~~~Init\char40{}\char41{}\char59{}~\\
\tt ~~~~~~~SetOwner\char40{}owner\char44{}~timerid\char41{}\char59{}~\\
\tt ~~~~~\char125{}\\
\tt ~\\
\tt ~~~~~void~SetOwner\char40{}wxEvtHandler~\char42{}owner\char44{}~int~timerid~\char61{}~wxID\char95{}ANY\char41{}~\char123{}\\
\tt ~~~~~~~~~m\char95{}owner~\char61{}~owner\char59{}\\
\tt ~~~~~~~~~m\char95{}idTimer~\char61{}~timerid~\char61{}\char61{}~wxID\char95{}ANY~\char63{}~wxWindow\char58{}\char58{}NewControlId\char40{}\char41{}~\char58{}~timerid\char59{}\\
\tt ~~~~~\char125{}\\
\tt ~~~~~\\
\tt ~~~~~int~GetInterval\char40{}\char41{}~const~\char123{}~return~m\char95{}milli\char59{}~\char125{}\\
\tt ~~~~~bool~IsOneShot\char40{}\char41{}~const~\char123{}~return~m\char95{}oneShot\char59{}~\char125{}\\
\tt ~~~~~\char46{}\char46{}\char46{}
\end{tabbing}

A timer inherits from \emph{wxEvtHandler}, and is constructed by passing it an owner and optionally an identifier. Normally identifiers are used by wxWidgets to identify windows, but because we could not infer the use case of ids on a timer we left it out of our implementation.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}c<{\hspost}@{}}%
\column{7E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{timer}\;\Varid{owner}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{timer'}\mathbin{`\Keyword{extends}`}\Varid{evthandler})\;\Varid{noOverride}\;\Varid{set\char95 EvtHandler\char95 Tail}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{timer'}\;\Varid{tail}\;\Varid{super}\;\Varid{self}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[4]{}\hsindent{3}{}\<[7]%
\>[7]{}\VarSym{...}{}\<[7E]%
\ColumnHook
\end{hscode}\resethooks

The constructor now corresponds to the \ensuremath{\Varid{timer}} function (different from the \ensuremath{\Varid{timer}} defined inside \emph{wx}), and extends from \ensuremath{\Varid{evthandler}}, which we will not present for the sake of brievity. Inside the constructor some variables are brought into scope covering both the \emph{Init} and \emph{SetOwner} function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}c<{\hspost}@{}}%
\column{9E}{@{}l@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[7]{}\Varid{interval}{}\<[18]%
\>[18]{}\leftarrow \Varid{newIORef}\;\Numeral{0}{}\<[E]%
\\
\>[7]{}\Varid{owner}{}\<[18]%
\>[18]{}\leftarrow \Varid{newIORef}\;\Varid{owner}{}\<[E]%
\\
\>[7]{}\Varid{jsTimerId}{}\<[18]%
\>[18]{}\leftarrow \Varid{newIORef}\;(\VarSym{-}\Numeral{1}){}\<[E]%
\\
\>[7]{}\Varid{isone}{}\<[18]%
\>[18]{}\leftarrow \Varid{newIORef}\;\Conid{False}{}\<[E]%
\\
\>[7]{}\Varid{isRunning}{}\<[18]%
\>[18]{}\leftarrow \Varid{newIORef}\;\Conid{False}{}\<[E]%
\\
\>[7]{}\Varid{return}\;\Conid{ITimer}\;\{\mskip1.5mu {}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\VarSym{...}{}\<[9E]%
\ColumnHook
\end{hscode}\resethooks

Most variables have corresponding methods for getting their values. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{},\Varid{\char95 timerGetInterval}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{readIORef}\;\Varid{interval}{}\<[E]%
\\
\>[9]{},\Varid{\char95 timerGetOwner}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{readIORef}\;\Varid{owner}{}\<[E]%
\\
\>[9]{},\Varid{\char95 timerIsOneShot}{}\<[29]%
\>[29]{}\mathrel{=}\Varid{readIORef}\;\Varid{isone}{}\<[E]%
\\
\>[9]{}\VarSym{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{timerStart}} method implements the functionality for starting a timer with a particular frequency (\ensuremath{\Varid{milli}}), and provides the possibility of firing the timer only once (\ensuremath{\Varid{oneshot}}).

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[10]{},\Varid{\char95 timerStart}{}\<[30]%
\>[30]{}\mathrel{=}\lambda \Varid{milli}\;\Varid{oneshot}\to \Keyword{do}{}\<[E]%
\\[\blanklineskip]%
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Keyword{let}\;\Varid{this}\mathrel{=}\Varid{upcast}\;\Varid{self}\ConSym{::}\Conid{Timer}{}\<[E]%
\\[\blanklineskip]%
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{timingEvent}{}\<[26]%
\>[26]{}\leftarrow \Keyword{new}\mathbin{\$}\Varid{timerEvent}\;\Varid{this}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{handler}{}\<[26]%
\>[26]{}\leftarrow \Varid{readIORef}\;\Varid{owner}{}\<[E]%
\\[\blanklineskip]%
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Keyword{let}\;\Varid{cb}\mathrel{=}\Keyword{do}\;\{\mskip1.5mu {}\<[E]%
\\
\>[13]{}\hsindent{3}{}\<[16]%
\>[16]{};\Varid{handler}\VarSym{\#}\Varid{evtHandlerProcessEvent}\mathbin{\$}(\Varid{upcast}\;\Varid{timingEvent}){}\<[E]%
\\
\>[13]{}\hsindent{3}{}\<[16]%
\>[16]{};\Varid{when}\;\Varid{oneshot}\;(\Varid{self}\VarSym{\#}\Varid{timerStop}){}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{w}{}\<[22]%
\>[22]{}\leftarrow \Varid{htmlWindow}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{timerId}{}\<[22]%
\>[22]{}\leftarrow \Varid{setInterval}\;\Varid{w}\;\Varid{cb}\;\Varid{milli}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{writeIORef}\;\Varid{jsTimerId}\;\Varid{timerId}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{return}\;\Conid{True}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The implementation makes fruitful use of the native \ensuremath{\Varid{setInterval}} function for installing a timed callback on the global window object. Inside the callback the \ensuremath{\Varid{evtHandlerProcessEvent}} is invoked on the owning object passing it an instance of a \emph{TimerEvent}. If the timer is a one shot than it stops the timer from preventing any future invocations of the callback. The \ensuremath{\Varid{setInterval}} method returns an identifier which we store inside the \ensuremath{\Varid{jsTimerId}} variable such that we may later use it to stop the timer:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}c<{\hspost}@{}}%
\column{7E}{@{}l@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[10]{},\Varid{\char95 timerStop}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{timerId}\leftarrow \Varid{readIORef}\;\Varid{jsTimerId}{}\<[E]%
\\
\>[10]{}\hsindent{3}{}\<[13]%
\>[13]{}\Varid{clearInterval}\;\Varid{timerId}{}\<[E]%
\\[\blanklineskip]%
\>[10]{},\Varid{\char95 timerTail}\mathrel{=}\Varid{tail}{}\<[E]%
\\
\>[7]{}\mskip1.5mu\}{}\<[7E]%
\ColumnHook
\end{hscode}\resethooks

With the timer implementation we can now implement the \ensuremath{\Varid{timerOnCommand}} and \ensuremath{\Varid{timerGetOnCommand}} functions, which are no methods of the timer class, but helper functions created by wxHaskell.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{timerOnCommand}\ConSym{::}\Conid{Timer\char95 }\;\Varid{a}\to \TConId{IO}\;()\to \TConId{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{timerOnCommand}\;\Varid{t}\;\Varid{f}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{owner}\leftarrow \Varid{t}\VarSym{\#}\Varid{timerGetOwner}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{owner}\VarSym{\#}\Varid{evtHandlerBind})\;\Varid{wxEVT\char95 TIMER}\;(\Varid{const}\;\Varid{f})\;\Varid{idAny}\;\Varid{idAny}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{timerGetOnCommand}\ConSym{::}\Conid{Timer\char95 }\;\Varid{a}\to \TConId{IO}\;(\TConId{IO}\;()){}\<[E]%
\\
\>[B]{}\Varid{timerGetOnCommand}\;\Varid{t}\mathrel{=}\Keyword{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{owner}\leftarrow \Varid{t}\VarSym{\#}\Varid{timerGetOwner}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{cb}\leftarrow \Keyword{do}\;\{\mskip1.5mu \Varid{cd}\leftarrow (\Varid{owner}\VarSym{\#}\Varid{evtHandlerGetHandler})\;\Varid{wxEVT\char95 TIMER}\;\Varid{idAny}\;\Varid{idAny}{}\<[E]%
\\
\>[4]{}\hsindent{9}{}\<[13]%
\>[13]{};\Varid{return}\mathbin{\$}\Varid{maybe}\;(\Varid{const}\mathbin{\$}\Varid{return}\;())\;\Varid{id}\;\Varid{cd}{}\<[E]%
\\
\>[4]{}\hsindent{9}{}\<[13]%
\>[13]{}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\mathbin{\$}\Varid{cb}\;(\Varid{error}\;\Char{\char34 touched~event~object\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{timerOnCommand}} function simply binds a callback to the owner of the timer, whereas \ensuremath{\Varid{timerGetOnCommand}} 
tries to retrieve an already bound callback. The \ensuremath{\Varid{evtHandlerGetHandler}} method had to be invented as its not part of the wxWidgets \emph{EvtHandler} class, which can be justified by the fact that wxHaskell also uses wrapper code to implement this functionality. 

Finally, the \ensuremath{\Varid{windowTimerCreate}} function simply instantiates a new timer. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{windowTimerCreate}\ConSym{::}\Conid{Window}\to \TConId{IO}\;\Conid{Timer}{}\<[E]%
\\
\>[B]{}\Varid{windowTimerCreate}\;\Varid{w}\mathrel{=}\Keyword{new}\mathbin{\$}\Varid{timer}\;(\Varid{upcast}\;\Varid{w}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We should note that we have changed the type signature such that it takes a concrete window instead of a polymorphic one. We could have left it polymorph, because the owner object is never required as a concrete object inside the timer implementation, but doing this would have required that we made use of parameterized classes in effect complicating the types; we choose not to.  

The wx timer now works inside the web browser, completely transparent to the end-user.

\section{Conclusion}

We have successfully ported a feature-light version of wxAsteroids to the web browser. Albeit the modest scope of the port we foresee no intrinsic difficulties in implementing the lacking features. We have discussed the design decisions involved and provided some details on the actual implementation. However, there is still much work to be done making decisions on how to best map wxWidgets features onto the web platform. Also, programming in LightOO feels a bit hacky due to the lack of an uniform treatment of subtyping which has forced us to make slight modifications to the wxcore interface. Furthermore, the lack of recursive modules breaks code organization and we expect that a full implementation of wxWidgets will soon run into performance problems related to the \js back-end.  
\chapter{Conclusion, Contributions \& Future Work}
\label{chap:conclusion}

Research question: \emph{how can we make wxHaskell run in the web browser?}

To answer the research question we have explored the different paths that could potentially lead to a proof of concept implementation of wxHaskell for the web. Of these paths we picked the least obvious and most challenging one, developed the necessary tools, and applied them to successfully port a feature-light version of \emph{wxAsteroids} which is \emph{near to} interchangeable with the desktop version\footnote{\url{https://github.com/rubendg/wxasteroids}}. To the best of our knowledge we are also the first to actually implement a real-world OO design in Haskell.

Besides the implementation of a subset of wxHaskell we contribute two independently useful libraries: an extended \js programming prelude\footnote{\url{https://github.com/UU-ComputerScience/uhc-js}}, and a light-weight approach for OO programming in Haskell inspired by OOHaskell which only requires Haskell 98 plus some lifting of type class restrictions\footnote{\url{https://github.com/rubendg/lightoo}}. Almost all code snippets in this thesis can be found at \footnote{\url{https://github.com/rubendg/thesis-snippets}}. 

From the discussions and conclusions of chapter 4, 5, and 6 it should be clear that in order for the wxWidgets implementation in Haskell to be of any real use there is still lots of work to be done. Also, some inherent limitations of the Haskell language such as the lack of first-class language support for extensible records and mutually recursive modules makes OO programming in Haskell feel a bit like a hack. It would be interesting to see if there exists a translation from feather-weight Java to our OO library as it would open up the possibility of creating a small language extension to hide the crufty details, and may even be able to work around the lack of an uniform treatment of subtyping in our encoding by inserting explicit casts at the required places. For all practical purposes, if the \js FFI keeps on improving, design option B remains the most practical approach to implement a fully fledged port of wxHaskell for the web. 

\chapter*{Acknowledgements}
\thispagestyle{empty}

At the end of my bachelor's study at the Applied Computer Science University Utrecht I had doubts about whether to pursue a master degree or not. Due to the discussions with my American colleges at the time, and my working experience among former university graduates who had greatly impressed me with their technical skills, I decided it was worth a try. 

Getting through the courses has been a bumpy ride to say the least. I had to overcome quite a few gaps in my background knowledge. At some point I nearly lost confidence, but thanks to the wonderful Andres L\"{o}h I regained trust in that everything would work out fine. I experienced Andres as an enthusiastic, knowledgeable, and excellent teacher with a great knack for understanding what you do not understand, but are not yet able to express. Writing the thesis, doing research, has been a great learning experience. Especially, being more practically minded, it took some time to get comfortable with the mindset necessary for literally spending weeks on something without having a clue whatsoever if it will result in anything to show for.

First of all I would like to thank my supervisors Atze Dijkstra and Doaitse Swierstra for helping me with this project, and Atze for going out of line by improving UHC even when time would not allow it. Without UHC this project would not have been possible! I want to thank Sean Leather for proofreading my thesis and providing useful suggestions and criticism. Many thanks also to Jurrien Stutterheim and Alessandro Vermeulen for the discussions on the \js back-end and their continuous effort to stay involved. Of course my thesis could not have been finished without a healthy dose of saccharine at the Pie-Thursdays, many thanks roomies Paul van der Walt, Ruud Koot, and Sjoerd Timmer. I sure did not intend to leave a mark on your theses the day you ate my rum-drenched tipsy cake! Finally, I would like to thank my family and friends for supporting me and listening to my endless ramblings about Haskell and otherwise unrelated topics.

\clearpage

\vspace*{\fill}
{\center\emph{"Haskell is the worldâ€™s finest imperative programming language"}, Simon P. Jones}

\appendix
\chapter{Appendix}

\section{XLib Hello World}
\label{app:xlib_helloworld}
\verbatiminput{resources/xlib_helloworld.cc}

\section{LightOO Macros}
\label{appendix:macros}

We define CPP macros for deriving the boilerplate for top-level classes and subclasses. To ease their definition we create a helper type class that allows us to capture the set of tail manipulation functions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{class}\;\Conid{ModTail}\;\Varid{c}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{getTail}\ConSym{::}\Varid{c}\;\Varid{t}\to \Conid{Record}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{setTail}\ConSym{::}\Varid{c}\;\Varid{t}\to \Conid{Record}\;\Varid{t'}\to \Varid{c}\;\Varid{t'}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{modifyTail}\ConSym{::}(\Conid{Record}\;\Varid{t}\to \Conid{Record}\;\Varid{t'})\to \Varid{c}\;\Varid{t}\to \Varid{c}\;\Varid{t'}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{modifyTail}\mathrel{=}\Varid{mkMod}\;\Varid{setTail}\;\Varid{getTail}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{mkMod}\;\Varid{set}\;\Varid{get}\;\Varid{f}\;\Varid{o}\mathrel{=}\Varid{set}\;\Varid{o}\;(\Varid{f}\;(\Varid{get}\;\Varid{o})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For example, the instance for \emph{Shape} looks like this:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{instance}\;\Conid{ModTail}\;\Conid{IShape}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{getTail}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{\char95 shapeTail}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{setTail}\;\Varid{o}\;\Varid{v}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{o}\;\{\mskip1.5mu \Varid{\char95 shapeTail}\mathrel{=}\Varid{v}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Conid{ModTail}} type class does not yet provide us with access to the tail of a subclass, but we can use it to derive a family of functions for nested tail manipulation by expressing their tail manipulation functions in terms of their parent's.

Here is an example of a family of functions derived for \ensuremath{\Conid{IShape}\;()} and \ensuremath{\Conid{IShape}\;(\Conid{IRectangle}\;())}: 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Comment{  -{}-\enskip  Shape}{}\<[E]%
\\
\>[B]{}\Varid{get\char95 Shape\char95 Tail}\ConSym{::}\Conid{IShape}\;\Varid{a}\to \Conid{Record}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{get\char95 Shape\char95 Tail}\mathrel{=}\Varid{getTail}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{set\char95 Shape\char95 Tail}\ConSym{::}\Conid{IShape}\;\Varid{a}\to \Conid{Record}\;\Varid{b}\to \Conid{Shape\char95 }\;\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{set\char95 Shape\char95 Tail}\;\Varid{o}\;\Varid{v}\mathrel{=}\Varid{setTail}\;\Varid{o}\;\Varid{v}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{modify\char95 Shape\char95 Tail}\mathrel{=}\Varid{mkMod}\;\Varid{set\char95 Shape\char95 Tail}\;\Varid{get\char95 Shape\char95 Tail}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Comment{  -{}-\enskip  Rectangle}{}\<[E]%
\\
\>[B]{}\Varid{get\char95 Rectangle\char95 Tail}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;\Varid{a})\to \Conid{Record}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{get\char95 Rectangle\char95 Tail}\mathrel{=}\Varid{getTail}\hsdot{\circ }{.}\Varid{unRecord}\hsdot{\circ }{.}\Varid{get\char95 Shape\char95 Tail}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{set\char95 Rectangle\char95 Tail}\ConSym{::}\Conid{IShape}\;(\Conid{IRectangle}\;\Varid{a})\to \Conid{Record}\;\Varid{b}\to \Conid{IShape}\;(\Conid{IRectangle}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{set\char95 Rectangle\char95 Tail}\;\Varid{o}\;\Varid{v}\mathrel{=}\Varid{modify\char95 Shape\char95 Tail}\;(\lambda \Varid{o}\to \Varid{record}\mathbin{\$}\Varid{setTail}\;(\Varid{unRecord}\;\Varid{o})\;\Varid{v})\;\Varid{o}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{modify\char95 Rectangle\char95 Tail}\mathrel{=}\Varid{mkMod}\;\Varid{set\char95 Rectangle\char95 Tail}\;\Varid{get\char95 Rectangle\char95 Tail}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Because the nested types can at times become quite lengthy we mold the types into a type synonym structure. 
This makes it easier for the programmer to read type errors, provide type annotations when necessary, and for the macros to generate code.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{type}\;\Conid{Shape\char95 }\;\Varid{t}\mathrel{=}\Conid{IShape}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Shape}\mathrel{=}\Conid{Shape\char95 }\;(){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{type}\;\Conid{Rectangle\char95 }\;\Varid{t}\mathrel{=}\Conid{Shape\char95 }\;(\Conid{IRectangle}\;\Varid{t}){}\<[E]%
\\
\>[B]{}\Keyword{type}\;\Conid{Rectangle}\mathrel{=}\Conid{Rectangle\char95 }\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \text{\tt DefineClass} macro can be used to derive the boilerplate for top-level classes, \text{\tt DefineSubClass} for subclasses. Their definition is somewhat complicated by the fact that they are also suited for parameterized classes.

\begin{tabbing}\tt
~\char35{}define~DefineClass\char40{}X\char44{}XC\char44{}XTAIL\char44{}AP\char44{}NP\char41{}\\
\tt ~\char35{}define~DefineSubClass\char40{}X\char44{}Y\char44{}XC\char44{}XTAIL\char44{}AP\char44{}YP\char44{}XP\char44{}NP\char44{}CONSTR\char41{}
\end{tabbing}

\begin{itemize}
  \item $X$, the name of the class
  \item $Y$, the name of the parent class
  \item $XC$, the name of the data type representing the class
  \item $XTAIL$, is the name of the function for manipulating the tail
  \item $AP$, all type parameters except the tail
  \item $YP \subseteq AP$, all type parameters that distribute to $Y$
  \item $XP \subseteq AP$, all type parameters that distribute to $X$
  \item $NP = |AP| + 1$, the number of type parameters
  \item $CONSTR$, a listing of \ensuremath{\TClassId{Typeable}} constraints on the $AP$ type parameters used for the \ensuremath{\TClassId{Narrow}} and \ensuremath{\TClassId{Widen}} instances
\end{itemize}


\begin{tabbing}\tt
~\char35{}define~DefineClass\char40{}X\char44{}XC\char44{}XTAIL\char44{}P\char44{}NP\char41{}~\char92{}\\
\tt ~type~X~\char35{}\char35{}~\char95{}~P~t~\char61{}~XC~P~t~\char59{}~\char92{}\\
\tt ~type~X~P~\char61{}~X~\char35{}\char35{}~\char95{}~P~\char40{}\char41{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~deriving~instance~Typeable~\char35{}\char35{}~NP~XC~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~instance~ModTail~\char40{}XC~P\char41{}~where~\char123{}~\char92{}\\
\tt ~~~~getTail~\char61{}~\char95{}~\char35{}\char35{}~XTAIL~\char59{}~\char92{}\\
\tt ~~~~setTail~o~v~\char61{}~o~\char123{}~\char95{}~\char35{}\char35{}~XTAIL~\char61{}~v~\char125{}~\char125{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char58{}\char58{}~X~\char35{}\char35{}~\char95{}~P~t~\char45{}\char62{}~Record~t~\char59{}~\char92{}\\
\tt ~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char61{}~getTail~\char59{}~\char92{}\\
\tt ~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char58{}\char58{}~X~\char35{}\char35{}~\char95{}~P~t~\char45{}\char62{}~Record~tt~\char45{}\char62{}~X~\char35{}\char35{}~\char95{}~P~tt~\char59{}~\char92{}\\
\tt ~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~o~v~\char61{}~setTail~o~v~\char59{}~\char92{}\\
\tt ~modify\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char61{}~mkMod~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char59{}\\
\tt ~\\
\tt ~\char35{}define~DefineSubClass\char40{}X\char44{}Y\char44{}XC\char44{}XTAIL\char44{}AP\char44{}YP\char44{}XP\char44{}NP\char44{}CONSTR\char41{}~\char92{}\\
\tt ~type~X~\char35{}\char35{}~\char95{}~AP~t~\char61{}~Y~\char35{}\char35{}~\char95{}~YP~\char40{}XC~XP~t\char41{}~\char59{}~\char92{}\\
\tt ~type~X~AP~\char61{}~X~\char35{}\char35{}~\char95{}~AP~\char40{}\char41{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~instance~\char40{}CONSTR\char41{}~\char61{}\char62{}~Narrow~\char40{}X~AP\char41{}~\char40{}Y~YP\char41{}~where~\char123{}~\char92{}\\
\tt ~~~~narrow~\char61{}~modify\char95{}~\char35{}\char35{}~Y~\char35{}\char35{}~\char95{}Tail~hideImpl~\char125{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~instance~\char40{}CONSTR\char41{}~\char61{}\char62{}~Widen~\char40{}Y~YP\char41{}~\char40{}X~AP\char41{}~where~\char123{}~\char92{}\\
\tt ~~~~widen~o~\char61{}~genericWiden~o~get\char95{}~\char35{}\char35{}~Y~\char35{}\char35{}~\char95{}Tail~set\char95{}~\char35{}\char35{}~Y~\char35{}\char35{}~\char95{}Tail~\char125{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~deriving~instance~Typeable~\char35{}\char35{}~NP~XC~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~instance~ModTail~\char40{}XC~XP\char41{}~where~\char123{}~\char92{}\\
\tt ~~~~getTail~\char61{}~\char95{}~\char35{}\char35{}~XTAIL~\char59{}~\char92{}\\
\tt ~~~~setTail~o~v~\char61{}~o~\char123{}~\char95{}~\char35{}\char35{}~XTAIL~\char61{}~v~\char125{}~\char125{}~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char58{}\char58{}~X~\char35{}\char35{}~\char95{}~AP~t~\char45{}\char62{}~Record~t~\char59{}~\char92{}\\
\tt ~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char61{}~getTail~\char46{}~headRecord~\char46{}~get\char95{}~\char35{}\char35{}~Y~\char35{}\char35{}~\char95{}Tail~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char58{}\char58{}~X~\char35{}\char35{}~\char95{}~AP~t~\char45{}\char62{}~Record~tt~\char45{}\char62{}~X~\char35{}\char35{}~\char95{}~AP~tt~\char59{}~\char92{}\\
\tt ~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~o~v~\char61{}~\\
\tt ~~~modify\char95{}~\char35{}\char35{}~Y~\char35{}\char35{}~\char95{}Tail~\char40{}\char92{}o~\char45{}\char62{}~consRecord~\char36{}~setTail~\char40{}headRecord~o\char41{}~v\char41{}~o~\char59{}~\char92{}\\
\tt ~\char92{}\\
\tt ~modify\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char61{}~mkMod~set\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~get\char95{}~\char35{}\char35{}~X~\char35{}\char35{}~\char95{}Tail~\char59{}
\end{tabbing}

\bibliography{thesis}

\end{document}
